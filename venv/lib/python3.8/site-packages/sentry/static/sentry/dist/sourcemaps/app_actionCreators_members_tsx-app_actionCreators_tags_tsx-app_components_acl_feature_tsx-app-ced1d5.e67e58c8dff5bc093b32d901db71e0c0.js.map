{"version":3,"file":"chunks/app_actionCreators_members_tsx-app_actionCreators_tags_tsx-app_components_acl_feature_tsx-app-ced1d5.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actionCreators/members.tsx","webpack:///./app/actionCreators/savedSearches.tsx","webpack:///./app/actionCreators/tags.tsx","webpack:///./app/actions/savedSearchesActions.tsx","webpack:///./app/components/acl/comingSoon.tsx","webpack:///./app/components/acl/feature.tsx","webpack:///./app/components/checkbox.tsx","webpack:///./app/components/dropdownLink.tsx","webpack:///./app/components/dropdownMenuItemV2.tsx","webpack:///./app/components/dropdownMenuSectionV2.tsx","webpack:///./app/components/dropdownMenuV2.tsx","webpack:///./app/components/dropdownMenuControlV2.tsx","webpack:///./app/components/forms/controls/radioBoolean.tsx","webpack:///./app/components/forms/datePickerField.tsx","webpack:///./app/components/forms/radioBooleanField.tsx","webpack:///./app/components/hotkeysLabel.tsx","webpack:///./app/views/issueList/createSavedSearchModal.tsx","webpack:///./app/components/smartSearchBar/actions.tsx","webpack:///./app/components/smartSearchBar/searchHotkeysListener.tsx","webpack:///./app/components/smartSearchBar/index.tsx","webpack:///./app/utils/getDynamicComponent.tsx","webpack:///./app/components/smartSearchBar/searchDropdown.tsx","webpack:///./app/components/smartSearchBar/types.tsx","webpack:///./app/components/smartSearchBar/utils.tsx","webpack:///./app/stores/alertStore.tsx","webpack:///./app/stores/tagStore.tsx","webpack:///./app/utils/getKeyCode.ts","webpack:///./app/utils/useHotkeys.tsx"],"sourcesContent":["import * as Sentry from '@sentry/react';\n\nimport MemberActions from 'sentry/actions/memberActions';\nimport {Client} from 'sentry/api';\nimport MemberListStore from 'sentry/stores/memberListStore';\nimport {Member} from 'sentry/types';\n\nfunction getMemberUser(member: Member) {\n  return {\n    ...member.user,\n    role: member.role,\n  };\n}\n\nexport async function fetchOrgMembers(\n  api: Client,\n  orgId: string,\n  projectIds: string[] | null = null\n) {\n  const endpoint = `/organizations/${orgId}/users/`;\n  const query = projectIds ? {project: projectIds} : {};\n\n  try {\n    const members = await api.requestPromise(endpoint, {method: 'GET', query});\n\n    if (!members) {\n      // This shouldn't happen if the request was successful\n      // It should at least be an empty list\n      Sentry.withScope(scope => {\n        scope.setExtras({\n          orgId,\n          projectIds,\n        });\n        Sentry.captureException(new Error('Members is undefined'));\n      });\n    }\n\n    const memberUsers = members?.filter(({user}: Member) => user);\n\n    if (!memberUsers) {\n      return [];\n    }\n\n    // Update the store with just the users, as avatars rely on them.\n    MemberListStore.loadInitialData(memberUsers.map(getMemberUser));\n\n    return members;\n  } catch (err) {\n    Sentry.setExtras({\n      resp: err,\n    });\n    Sentry.captureException(err);\n  }\n\n  return [];\n}\n\ntype IndexedMembersByProject = Record<string, Member['user'][]>;\n\n/**\n * Convert a list of members with user & project data\n * into a object that maps project slugs : users in that project.\n */\nexport function indexMembersByProject(members: Member[]): IndexedMembersByProject {\n  return members.reduce((acc, member) => {\n    for (const project of member.projects) {\n      if (!acc.hasOwnProperty(project)) {\n        acc[project] = [];\n      }\n      acc[project].push(member.user);\n    }\n    return acc;\n  }, {});\n}\n\ntype UpdateMemberOptions = {\n  data: Member | null;\n  memberId: string;\n  orgId: string;\n};\n\nexport async function updateMember(\n  api: Client,\n  {orgId, memberId, data}: UpdateMemberOptions\n) {\n  MemberActions.update(memberId, data);\n\n  const endpoint = `/organizations/${orgId}/members/${memberId}/`;\n  try {\n    const resp = await api.requestPromise(endpoint, {\n      method: 'PUT',\n      data,\n    });\n    MemberActions.updateSuccess(resp);\n    return resp;\n  } catch (err) {\n    MemberActions.updateError(err);\n    throw err;\n  }\n}\n\ntype ResendMemberInviteOptions = {\n  memberId: string;\n  orgId: string;\n  data?: object;\n  regenerate?: boolean;\n};\n\nexport async function resendMemberInvite(\n  api: Client,\n  {orgId, memberId, regenerate, data}: ResendMemberInviteOptions\n) {\n  MemberActions.resendMemberInvite(orgId, data);\n\n  const endpoint = `/organizations/${orgId}/members/${memberId}/`;\n  try {\n    const resp = await api.requestPromise(endpoint, {\n      method: 'PUT',\n      data: {\n        regenerate,\n        reinvite: true,\n      },\n    });\n    MemberActions.resendMemberInviteSuccess(resp);\n    return resp;\n  } catch (err) {\n    MemberActions.resendMemberInviteError(err);\n    throw err;\n  }\n}\n\nexport function getCurrentMember(api: Client, orgId: string) {\n  return api.requestPromise(`/organizations/${orgId}/members/me/`);\n}\n","import {addErrorMessage} from 'sentry/actionCreators/indicator';\nimport SavedSearchesActions from 'sentry/actions/savedSearchesActions';\nimport {Client} from 'sentry/api';\nimport {MAX_AUTOCOMPLETE_RECENT_SEARCHES} from 'sentry/constants';\nimport {t} from 'sentry/locale';\nimport {RecentSearch, SavedSearch, SavedSearchType} from 'sentry/types';\nimport handleXhrErrorResponse from 'sentry/utils/handleXhrErrorResponse';\n\nexport function resetSavedSearches() {\n  SavedSearchesActions.resetSavedSearches();\n}\n\nexport function fetchSavedSearches(api: Client, orgSlug: string): Promise<SavedSearch[]> {\n  const url = `/organizations/${orgSlug}/searches/`;\n  SavedSearchesActions.startFetchSavedSearches();\n\n  const promise = api.requestPromise(url, {\n    method: 'GET',\n  });\n\n  promise\n    .then(resp => {\n      SavedSearchesActions.fetchSavedSearchesSuccess(resp);\n    })\n    .catch(err => {\n      SavedSearchesActions.fetchSavedSearchesError(err);\n      addErrorMessage(t('Unable to load saved searches'));\n    });\n\n  return promise;\n}\n\nexport function fetchProjectSavedSearches(\n  api: Client,\n  orgSlug: string,\n  projectId: string\n): Promise<SavedSearch[]> {\n  const url = `/projects/${orgSlug}/${projectId}/searches/`;\n  return api.requestPromise(url, {\n    method: 'GET',\n  });\n}\n\nconst getRecentSearchUrl = (orgSlug: string): string =>\n  `/organizations/${orgSlug}/recent-searches/`;\n\n/**\n * Saves search term for `user` + `orgSlug`\n *\n * @param api API client\n * @param orgSlug Organization slug\n * @param type Context for where search happened, 0 for issue, 1 for event\n * @param query The search term that was used\n */\nexport function saveRecentSearch(\n  api: Client,\n  orgSlug: string,\n  type: SavedSearchType,\n  query: string\n): Promise<SavedSearch> {\n  const url = getRecentSearchUrl(orgSlug);\n  const promise = api.requestPromise(url, {\n    method: 'POST',\n    data: {\n      query,\n      type,\n    },\n  });\n\n  promise.catch(handleXhrErrorResponse('Unable to save a recent search'));\n\n  return promise;\n}\n\n/**\n * Creates a saved search\n *\n * @param api API client\n * @param orgSlug Organization slug\n * @param name Saved search name\n * @param query Query to save\n */\nexport function createSavedSearch(\n  api: Client,\n  orgSlug: string,\n  name: string,\n  query: string,\n  sort: string | null\n): Promise<SavedSearch> {\n  const promise = api.requestPromise(`/organizations/${orgSlug}/searches/`, {\n    method: 'POST',\n    data: {\n      type: SavedSearchType.ISSUE,\n      query,\n      name,\n      sort,\n    },\n  });\n\n  // Need to wait for saved search to save unfortunately because we need to redirect\n  // to saved search URL\n  promise.then(resp => {\n    SavedSearchesActions.createSavedSearchSuccess(resp);\n  });\n\n  return promise;\n}\n\n/**\n * Fetches a list of recent search terms conducted by `user` for `orgSlug`\n *\n * @param api API client\n * @param orgSlug Organization slug\n * @param type Context for where search happened, 0 for issue, 1 for event\n * @param query A query term used to filter results\n *\n * @return Returns a list of objects of recent search queries performed by user\n */\nexport function fetchRecentSearches(\n  api: Client,\n  orgSlug: string,\n  type: SavedSearchType,\n  query?: string\n): Promise<RecentSearch[]> {\n  const url = getRecentSearchUrl(orgSlug);\n  const promise = api.requestPromise(url, {\n    query: {\n      query,\n      type,\n      limit: MAX_AUTOCOMPLETE_RECENT_SEARCHES,\n    },\n  });\n\n  promise.catch(resp => {\n    if (resp.status !== 401 && resp.status !== 403) {\n      handleXhrErrorResponse('Unable to fetch recent searches')(resp);\n    }\n  });\n\n  return promise;\n}\n\nconst getPinSearchUrl = (orgSlug: string): string =>\n  `/organizations/${orgSlug}/pinned-searches/`;\n\nexport function pinSearch(\n  api: Client,\n  orgSlug: string,\n  type: SavedSearchType,\n  query: string,\n  sort?: string\n): Promise<SavedSearch> {\n  const url = getPinSearchUrl(orgSlug);\n\n  // Optimistically update store\n  SavedSearchesActions.pinSearch(type, query, sort);\n\n  const promise = api.requestPromise(url, {\n    method: 'PUT',\n    data: {\n      query,\n      type,\n      sort,\n    },\n  });\n\n  promise.then(SavedSearchesActions.pinSearchSuccess);\n\n  promise.catch(handleXhrErrorResponse('Unable to pin search'));\n\n  promise.catch(() => {\n    SavedSearchesActions.unpinSearch(type);\n  });\n\n  return promise;\n}\n\nexport function unpinSearch(\n  api: Client,\n  orgSlug: string,\n  type: SavedSearchType,\n  pinnedSearch: SavedSearch\n) {\n  const url = getPinSearchUrl(orgSlug);\n\n  // Optimistically update store\n  SavedSearchesActions.unpinSearch(type);\n\n  const promise = api.requestPromise(url, {\n    method: 'DELETE',\n    data: {\n      type,\n    },\n  });\n\n  promise.catch(handleXhrErrorResponse('Unable to un-pin search'));\n\n  promise.catch(() => {\n    const {type: pinnedType, query} = pinnedSearch;\n    SavedSearchesActions.pinSearch(pinnedType, query);\n  });\n\n  return promise;\n}\n\n/**\n * Send a DELETE request to remove a saved search\n *\n * @param api API client\n * @param orgSlug Organization slug\n * @param search The search to remove.\n */\nexport function deleteSavedSearch(\n  api: Client,\n  orgSlug: string,\n  search: SavedSearch\n): Promise<void> {\n  const url = `/organizations/${orgSlug}/searches/${search.id}/`;\n\n  const promise = api\n    .requestPromise(url, {\n      method: 'DELETE',\n    })\n    .then(() => SavedSearchesActions.deleteSavedSearchSuccess(search))\n    .catch(handleXhrErrorResponse('Unable to delete a saved search'));\n\n  return promise;\n}\n","import {Query} from 'history';\n\nimport {Client} from 'sentry/api';\nimport {normalizeDateTimeParams} from 'sentry/components/organizations/pageFilters/parse';\nimport {t} from 'sentry/locale';\nimport AlertStore from 'sentry/stores/alertStore';\nimport TagStore from 'sentry/stores/tagStore';\nimport {PageFilters, Tag} from 'sentry/types';\n\nconst MAX_TAGS = 1000;\n\nfunction tagFetchSuccess(tags: Tag[] | undefined) {\n  // We occasionally get undefined passed in when APIs are having a bad time.\n  tags = tags || [];\n  const trimmedTags = tags.slice(0, MAX_TAGS);\n\n  if (tags.length > MAX_TAGS) {\n    AlertStore.addAlert({\n      message: t('You have too many unique tags and some have been truncated'),\n      type: 'warning',\n    });\n  }\n  TagStore.loadTagsSuccess(trimmedTags);\n}\n\n/**\n * Load an organization's tags based on a global selection value.\n */\nexport function loadOrganizationTags(api: Client, orgId: string, selection: PageFilters) {\n  TagStore.reset();\n\n  const url = `/organizations/${orgId}/tags/`;\n  const query: Query = selection.datetime\n    ? {...normalizeDateTimeParams(selection.datetime)}\n    : {};\n  query.use_cache = '1';\n\n  if (selection.projects) {\n    query.project = selection.projects.map(String);\n  }\n  const promise = api.requestPromise(url, {\n    method: 'GET',\n    query,\n  });\n\n  promise.then(tagFetchSuccess);\n\n  return promise;\n}\n\n/**\n * Fetch tags for an organization or a subset or projects.\n */\nexport function fetchOrganizationTags(\n  api: Client,\n  orgId: string,\n  projectIds: string[] | null = null\n) {\n  TagStore.reset();\n\n  const url = `/organizations/${orgId}/tags/`;\n  const query: Query = {use_cache: '1'};\n  if (projectIds) {\n    query.project = projectIds;\n  }\n\n  const promise = api.requestPromise(url, {\n    method: 'GET',\n    query,\n  });\n\n  promise.then(tagFetchSuccess);\n\n  return promise;\n}\n\n/**\n * Fetch tag values for an organization.\n * The `projectIds` argument can be used to subset projects.\n */\nexport function fetchTagValues(\n  api: Client,\n  orgId: string,\n  tagKey: string,\n  search: string | null = null,\n  projectIds: string[] | null = null,\n  endpointParams: Query | null = null,\n  includeTransactions = false,\n  includeSessions = false\n) {\n  const url = `/organizations/${orgId}/tags/${tagKey}/values/`;\n\n  const query: Query = {};\n  if (search) {\n    query.query = search;\n  }\n  if (projectIds) {\n    query.project = projectIds;\n  }\n  if (endpointParams) {\n    if (endpointParams.start) {\n      query.start = endpointParams.start;\n    }\n    if (endpointParams.end) {\n      query.end = endpointParams.end;\n    }\n    if (endpointParams.statsPeriod) {\n      query.statsPeriod = endpointParams.statsPeriod;\n    }\n  }\n  if (includeTransactions) {\n    query.includeTransactions = '1';\n  }\n\n  if (includeSessions) {\n    query.includeSessions = '1';\n  }\n\n  return api.requestPromise(url, {\n    method: 'GET',\n    query,\n  });\n}\n","import {createActions} from 'reflux';\n\nconst SavedSearchActions = createActions([\n  'resetSavedSearches',\n  'startFetchSavedSearches',\n  'fetchSavedSearchesSuccess',\n  'fetchSavedSearchesError',\n  'createSavedSearchSuccess',\n  'deleteSavedSearchSuccess',\n  'pinSearch',\n  'pinSearchSuccess',\n  'unpinSearch',\n]);\n\nexport default SavedSearchActions;\n","import Alert from 'sentry/components/alert';\nimport {t} from 'sentry/locale';\n\nconst ComingSoon = () => (\n  <Alert type=\"info\" showIcon>\n    {t('This feature is coming soon!')}\n  </Alert>\n);\n\nexport default ComingSoon;\n","import {Component} from 'react';\n\nimport HookStore from 'sentry/stores/hookStore';\nimport {Config, Organization, Project} from 'sentry/types';\nimport {FeatureDisabledHooks} from 'sentry/types/hooks';\nimport {isRenderFunc} from 'sentry/utils/isRenderFunc';\nimport withConfig from 'sentry/utils/withConfig';\nimport withOrganization from 'sentry/utils/withOrganization';\nimport withProject from 'sentry/utils/withProject';\n\nimport ComingSoon from './comingSoon';\n\ntype Props = {\n  /**\n   * If children is a function then will be treated as a render prop and\n   * passed FeatureRenderProps.\n   *\n   * The other interface is more simple, only show `children` if org/project has\n   * all the required feature.\n   */\n  children: React.ReactNode | ChildrenRenderFn;\n  config: Config;\n  /**\n   * List of required feature tags. Note we do not enforce uniqueness of tags anywhere.\n   * On the backend end, feature tags have a scope prefix string that is stripped out on the\n   * frontend (since feature tags are attached to a context object).\n   *\n   * Use `organizations:` or `projects:` prefix strings to specify a feature with context.\n   */\n  features: string[];\n  /**\n   * The following properties will be set by the HoCs\n   */\n  organization: Organization;\n  /**\n   * Specify the key to use for hookstore functionality.\n   *\n   * The hookName should be prefixed with `feature-disabled`.\n   *\n   * When specified, the hookstore will be checked if the feature is\n   * disabled, and the first available hook will be used as the render\n   * function.\n   */\n  hookName?: keyof FeatureDisabledHooks;\n  project?: Project;\n  /**\n   * Custom renderer function for when the feature is not enabled.\n   *\n   *  - [default] Set this to false to disable rendering anything. If the\n   *    feature is not enabled no children will be rendered.\n   *\n   *  - Set this to `true` to use the default `ComingSoon` alert component.\n   *\n   *  - Provide a custom render function to customize the rendered component.\n   *\n   * When a custom render function is used, the same object that would be\n   * passed to `children` if a func is provided there, will be used here,\n   * additionally `children` will also be passed.\n   */\n  renderDisabled?: boolean | RenderDisabledFn;\n  /**\n   * Should the component require all features or just one or more.\n   */\n  requireAll?: boolean;\n};\n\n/**\n * Common props passed to children and disabled render handlers.\n */\ntype FeatureRenderProps = {\n  features: string[];\n  hasFeature: boolean;\n  organization: Organization;\n  project?: Project;\n};\n\n/**\n * When a feature is disabled the caller of Feature may provide a `renderDisabled`\n * prop. This prop can be overridden by getsentry via hooks. Often getsentry will\n * call the original children function  but override the `renderDisabled`\n * with another function/component.\n */\ntype RenderDisabledProps = FeatureRenderProps & {\n  children: React.ReactNode | ChildrenRenderFn;\n  renderDisabled?: (props: FeatureRenderProps) => React.ReactNode;\n};\n\nexport type RenderDisabledFn = (props: RenderDisabledProps) => React.ReactNode;\n\ntype ChildRenderProps = FeatureRenderProps & {\n  renderDisabled?: undefined | boolean | RenderDisabledFn;\n};\n\nexport type ChildrenRenderFn = (props: ChildRenderProps) => React.ReactNode;\n\ntype AllFeatures = {\n  configFeatures: string[];\n  organization: string[];\n  project: string[];\n};\n\n/**\n * Component to handle feature flags.\n */\nclass Feature extends Component<Props> {\n  static defaultProps = {\n    renderDisabled: false,\n    requireAll: true,\n  };\n\n  getAllFeatures(): AllFeatures {\n    const {organization, project, config} = this.props;\n\n    return {\n      configFeatures: config.features ? Array.from(config.features) : [],\n      organization: (organization && organization.features) || [],\n      project: (project && project.features) || [],\n    };\n  }\n\n  hasFeature(feature: string, features: AllFeatures) {\n    const shouldMatchOnlyProject = feature.match(/^projects:(.+)/);\n    const shouldMatchOnlyOrg = feature.match(/^organizations:(.+)/);\n\n    // Array of feature strings\n    const {configFeatures, organization, project} = features;\n\n    // Check config store first as this overrides features scoped to org or\n    // project contexts.\n    if (configFeatures.includes(feature)) {\n      return true;\n    }\n\n    if (shouldMatchOnlyProject) {\n      return project.includes(shouldMatchOnlyProject[1]);\n    }\n\n    if (shouldMatchOnlyOrg) {\n      return organization.includes(shouldMatchOnlyOrg[1]);\n    }\n\n    // default, check all feature arrays\n    return organization.includes(feature) || project.includes(feature);\n  }\n\n  render() {\n    const {\n      children,\n      features,\n      renderDisabled,\n      hookName,\n      organization,\n      project,\n      requireAll,\n    } = this.props;\n\n    const allFeatures = this.getAllFeatures();\n    const method = requireAll ? 'every' : 'some';\n    const hasFeature =\n      !features || features[method](feat => this.hasFeature(feat, allFeatures));\n\n    // Default renderDisabled to the ComingSoon component\n    let customDisabledRender =\n      renderDisabled === false\n        ? false\n        : typeof renderDisabled === 'function'\n        ? renderDisabled\n        : () => <ComingSoon />;\n\n    // Override the renderDisabled function with a hook store function if there\n    // is one registered for the feature.\n    if (hookName) {\n      const hooks = HookStore.get(hookName);\n\n      if (hooks.length > 0) {\n        customDisabledRender = hooks[0];\n      }\n    }\n    const renderProps = {\n      organization,\n      project,\n      features,\n      hasFeature,\n    };\n\n    if (!hasFeature && customDisabledRender !== false) {\n      return customDisabledRender({children, ...renderProps});\n    }\n\n    if (isRenderFunc<ChildrenRenderFn>(children)) {\n      return children({renderDisabled, ...renderProps});\n    }\n\n    return hasFeature && children ? children : null;\n  }\n}\n\nexport default withOrganization(withProject(withConfig(Feature)));\n","const Checkbox = (props: React.InputHTMLAttributes<HTMLInputElement>) => (\n  <input type=\"checkbox\" {...props} />\n);\n\nCheckbox.defaultProps = {\n  checked: false,\n};\n\nexport default Checkbox;\n","import {css, useTheme} from '@emotion/react';\nimport classNames from 'classnames';\n\nimport DropdownMenu from 'sentry/components/dropdownMenu';\nimport {IconChevron} from 'sentry/icons';\nimport {Theme} from 'sentry/utils/theme';\n\nconst getRootCss = (theme: Theme) => css`\n  .dropdown-menu {\n    & > li > a {\n      color: ${theme.textColor};\n\n      &:hover,\n      &:focus {\n        color: inherit;\n        background-color: ${theme.hover};\n      }\n    }\n\n    & .disabled {\n      cursor: not-allowed;\n      &:hover {\n        background: inherit;\n        color: inherit;\n      }\n    }\n  }\n\n  .dropdown-submenu:hover > span {\n    color: ${theme.textColor};\n    background: ${theme.hover};\n  }\n`;\n\n// .dropdown-actor-title = flexbox to fix vertical alignment on firefox Need\n// the extra container because dropdown-menu alignment is off if\n// `dropdown-actor` is a flexbox\n\ntype Props = Omit<\n  Omit<DropdownMenu['props'], 'children'>,\n  keyof typeof DropdownMenu.defaultProps\n> &\n  Partial<typeof DropdownMenu.defaultProps> & {\n    children: React.ReactNode;\n    /**\n     * Always render children of dropdown menu, this is included to support menu\n     * items that open a confirm modal. Otherwise when dropdown menu hides, the\n     * modal also gets unmounted\n     */\n    alwaysRenderMenu?: boolean;\n    anchorMiddle?: boolean;\n    /**\n     * Anchors menu to the right\n     */\n    anchorRight?: boolean;\n    /**\n     * display dropdown caret\n     */\n    caret?: boolean;\n    className?: string;\n    customTitle?: React.ReactNode;\n    disabled?: boolean;\n    menuClasses?: string;\n    title?: React.ReactNode;\n    topLevelClasses?: string;\n  };\n\nfunction DropdownLink({\n  anchorMiddle,\n  title,\n  customTitle,\n  children,\n  menuClasses,\n  className,\n  topLevelClasses,\n  anchorRight = false,\n  disabled = false,\n  caret = true,\n  alwaysRenderMenu = true,\n  ...otherProps\n}: Props) {\n  const theme = useTheme();\n\n  return (\n    <DropdownMenu alwaysRenderMenu={alwaysRenderMenu} {...otherProps}>\n      {({isOpen, getRootProps, getActorProps, getMenuProps}) => {\n        const shouldRenderMenu = alwaysRenderMenu || isOpen;\n        const cx = classNames('dropdown-actor', className, {\n          'dropdown-menu-right': anchorRight,\n          'dropdown-toggle': true,\n          hover: isOpen,\n          disabled,\n        });\n        const topLevelCx = classNames('dropdown', topLevelClasses, {\n          'pull-right': anchorRight,\n          'anchor-right': anchorRight,\n          'anchor-middle': anchorMiddle,\n          open: isOpen,\n        });\n\n        const {onClick: onClickActor, ...actorProps} = getActorProps({\n          className: cx,\n        });\n\n        return (\n          <span\n            css={getRootCss(theme)}\n            {...getRootProps({\n              className: topLevelCx,\n            })}\n            data-test-id=\"dropdown-link\"\n          >\n            <a onClick={disabled ? undefined : onClickActor} {...actorProps}>\n              {customTitle || (\n                <div className=\"dropdown-actor-title\">\n                  {title}\n                  {caret && <IconChevron direction={isOpen ? 'up' : 'down'} size=\"xs\" />}\n                </div>\n              )}\n            </a>\n\n            {shouldRenderMenu && (\n              <ul\n                {...getMenuProps({\n                  className: classNames(menuClasses, 'dropdown-menu'),\n                })}\n              >\n                {children}\n              </ul>\n            )}\n          </span>\n        );\n      }}\n    </DropdownMenu>\n  );\n}\n\nexport default DropdownLink;\n","import {Fragment, useEffect, useRef, useState} from 'react';\nimport {useHover, useKeyboard} from '@react-aria/interactions';\nimport {useMenuItem} from '@react-aria/menu';\nimport {mergeProps} from '@react-aria/utils';\nimport {TreeState} from '@react-stately/tree';\nimport {Node} from '@react-types/shared';\nimport {LocationDescriptor} from 'history';\n\nimport Link from 'sentry/components/links/link';\nimport MenuListItem, {\n  InnerWrap as MenuListItemInnerWrap,\n  MenuListItemProps,\n} from 'sentry/components/menuListItem';\nimport {IconChevron} from 'sentry/icons';\n\nexport type MenuItemProps = MenuListItemProps & {\n  /**\n   * Item key. Must be unique across the entire menu, including sub-menus.\n   */\n  key: string;\n  /**\n   * Sub-items that are nested inside this item. By default, sub-items are\n   * rendered collectively as menu sections inside the current menu. If\n   * `isSubmenu` is true, then they will be rendered together in a sub-menu.\n   */\n  children?: MenuItemProps[];\n  /**\n   * Hide item from the dropdown menu. Note: this will also remove the item\n   * from the selection manager.\n   */\n  hidden?: boolean;\n  /*\n   * Whether this menu item is a trigger for a nested sub-menu. Only works\n   * when `children` is also defined.\n   */\n  isSubmenu?: boolean;\n  /**\n   * Function to call when user selects/clicks/taps on the menu item. The\n   * item's key is passed as an argument.\n   */\n  onAction?: (key: MenuItemProps['key']) => void;\n  /**\n   * Whether to show a line divider below this menu item\n   */\n  showDividers?: boolean;\n  /**\n   * Passed as the `menuTitle` prop onto the associated sub-menu (applicable\n   * if `children` is defined and `isSubmenu` is true)\n   */\n  submenuTitle?: string;\n  /**\n   * Destination if this menu item is a link. See also: `isExternalLink`.\n   */\n  to?: LocationDescriptor;\n};\n\ntype Props = {\n  /**\n   * Whether to close the menu when an item has been clicked/selected\n   */\n  closeOnSelect: boolean;\n  /**\n   * Whether this is the last node in the collection\n   */\n  isLastNode: boolean;\n  /**\n   * Node representation (from @react-aria) of the item\n   */\n  node: Node<MenuItemProps>;\n  /**\n   * Used to close the menu when needed (e.g. when the item is\n   * clicked/selected)\n   */\n  onClose: () => void;\n  /**\n   * Tree state (from @react-stately) inherited from parent menu\n   */\n  state: TreeState<MenuItemProps>;\n  /**\n   * Whether this is a trigger button (displayed as a normal menu item) for a\n   * submenu\n   */\n  isSubmenuTrigger?: boolean;\n  /**\n   * Tag name for item wrapper\n   */\n  renderAs?: React.ElementType;\n  /**\n   * If isSubmenuTrigger is true, then replace the internal ref object with\n   * this ref\n   */\n  submenuTriggerRef?: React.RefObject<HTMLLIElement>;\n};\n\n/**\n * A menu item with a label, optional details, leading and trailing elements.\n * Can also be used as a trigger button for a submenu. See:\n * https://react-spectrum.adobe.com/react-aria/useMenu.html\n */\nconst MenuItem = ({\n  node,\n  isLastNode,\n  state,\n  onClose,\n  closeOnSelect,\n  isSubmenuTrigger = false,\n  submenuTriggerRef,\n  renderAs = 'li' as React.ElementType,\n  ...submenuTriggerProps\n}: Props) => {\n  const [isHovering, setIsHovering] = useState(false);\n  const ourRef = useRef(null);\n  const isDisabled = state.disabledKeys.has(node.key);\n  const isFocused = state.selectionManager.focusedKey === node.key;\n  const {key, onAction, to, label, showDividers, ...itemProps} = node.value;\n\n  const ref = submenuTriggerRef ?? ourRef;\n\n  const actionHandler = () => {\n    if (to) {\n      return;\n    }\n    if (isSubmenuTrigger) {\n      state.selectionManager.select(node.key);\n      return;\n    }\n    onAction?.(key);\n  };\n\n  // Open submenu on hover\n  const {hoverProps} = useHover({onHoverChange: setIsHovering});\n  useEffect(() => {\n    if (isHovering && isFocused) {\n      if (isSubmenuTrigger) {\n        state.selectionManager.select(node.key);\n        return;\n      }\n      state.selectionManager.clearSelection();\n    }\n  }, [isHovering, isFocused]);\n\n  // Open submenu on arrow right key press\n  const {keyboardProps} = useKeyboard({\n    onKeyDown: e => {\n      if (e.key === 'Enter' && to) {\n        const mouseEvent = new MouseEvent('click', {\n          ctrlKey: e.ctrlKey,\n          metaKey: e.metaKey,\n        });\n        ref.current?.querySelector(`${MenuListItemInnerWrap}`)?.dispatchEvent(mouseEvent);\n        onClose();\n        return;\n      }\n\n      if (e.key === 'ArrowRight' && isSubmenuTrigger) {\n        state.selectionManager.select(node.key);\n        return;\n      }\n\n      e.continuePropagation();\n    },\n  });\n\n  // Manage interactive events & create aria attributes\n  const {menuItemProps, labelProps, descriptionProps} = useMenuItem(\n    {\n      key: node.key,\n      onAction: actionHandler,\n      closeOnSelect: to ? false : closeOnSelect,\n      onClose,\n      isDisabled,\n    },\n    state,\n    ref\n  );\n\n  // Merged menu item props, class names are combined, event handlers chained,\n  // etc. See: https://react-spectrum.adobe.com/react-aria/mergeProps.html\n  const props = mergeProps(submenuTriggerProps, menuItemProps, hoverProps, keyboardProps);\n  const itemLabel = node.rendered ?? label;\n  const showDivider = showDividers && !isLastNode;\n  const innerWrapProps = {as: to ? Link : 'div', to};\n\n  return (\n    <MenuListItem\n      ref={ref}\n      as={renderAs}\n      data-test-id={key}\n      label={itemLabel}\n      isDisabled={isDisabled}\n      isFocused={isFocused}\n      showDivider={showDivider}\n      innerWrapProps={innerWrapProps}\n      labelProps={labelProps}\n      detailsProps={descriptionProps}\n      {...props}\n      {...itemProps}\n      {...(isSubmenuTrigger && {\n        role: 'menuitemradio',\n        trailingItems: (\n          <Fragment>\n            {itemProps.trailingItems}\n            <IconChevron size=\"xs\" direction=\"right\" aria-hidden=\"true\" />\n          </Fragment>\n        ),\n      })}\n    />\n  );\n};\n\nexport default MenuItem;\n","import styled from '@emotion/styled';\nimport {useMenuSection} from '@react-aria/menu';\nimport {Node} from '@react-types/shared';\n\nimport {MenuItemProps} from 'sentry/components/dropdownMenuItemV2';\nimport space from 'sentry/styles/space';\n\ntype Props = {\n  children: React.ReactNode;\n  node: Node<MenuItemProps>;\n};\n\n/**\n * A wrapper component for menu sections. See:\n * https://react-spectrum.adobe.com/react-aria/useMenu.html\n */\nfunction MenuSection({node, children}: Props) {\n  const {itemProps, headingProps, groupProps} = useMenuSection({\n    heading: node.rendered,\n    'aria-label': node['aria-label'],\n  });\n\n  return (\n    <MenuSectionWrap {...itemProps}>\n      {node.rendered && <Heading {...headingProps}>{node.rendered}</Heading>}\n      <Group {...groupProps}>{children}</Group>\n    </MenuSectionWrap>\n  );\n}\n\nexport default MenuSection;\n\nconst MenuSectionWrap = styled('li')`\n  list-style-type: none;\n`;\n\nconst Heading = styled('span')`\n  display: inline-block;\n  font-weight: 600;\n  font-size: ${p => p.theme.fontSizeSmall};\n  color: ${p => p.theme.subText};\n  text-transform: uppercase;\n  white-space: nowrap;\n  margin: ${space(1)} ${space(1.5)} ${space(0.5)};\n  padding-right: ${space(1)};\n\n  ${/* sc-selector */ MenuSectionWrap}:first-of-type & {\n    margin-top: ${space(0.5)};\n  }\n`;\n\nconst Group = styled('ul')`\n  list-style-type: none;\n  padding: 0;\n  margin: 0;\n`;\n","import {Fragment, useEffect, useMemo, useRef, useState} from 'react';\nimport styled from '@emotion/styled';\nimport {FocusScope} from '@react-aria/focus';\nimport {useKeyboard} from '@react-aria/interactions';\nimport {AriaMenuOptions, useMenu} from '@react-aria/menu';\nimport {\n  AriaPositionProps,\n  OverlayProps,\n  PositionAria,\n  useOverlay,\n  useOverlayPosition,\n} from '@react-aria/overlays';\nimport {useSeparator} from '@react-aria/separator';\nimport {mergeProps} from '@react-aria/utils';\nimport {useTreeState} from '@react-stately/tree';\nimport {Node} from '@react-types/shared';\n\nimport MenuControl from 'sentry/components/dropdownMenuControlV2';\nimport MenuItem, {MenuItemProps} from 'sentry/components/dropdownMenuItemV2';\nimport MenuSection from 'sentry/components/dropdownMenuSectionV2';\nimport space from 'sentry/styles/space';\n\ntype Props = {\n  /**\n   * If this is a submenu, it will in some cases need to close the root menu\n   * (e.g. when a submenu item is clicked).\n   */\n  closeRootMenu: () => void;\n  /**\n   * Whether this is a submenu\n   */\n  isSubmenu: boolean;\n  /**\n   * Ref object to the trigger element, needed for useOverlayPosition()\n   */\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  /**\n   * If this is a submenu, it will in some cases need to close itself (e.g.\n   * when the user presses the arrow left key)\n   */\n  closeCurrentSubmenu?: () => void;\n  /**\n   * Whether the menu should close when an item has been clicked/selected\n   */\n  closeOnSelect?: boolean;\n  /*\n   * Title to display on top of the menu\n   */\n  menuTitle?: string;\n  onClose?: () => void;\n  /**\n   * Current width of the trigger element. This is used as the menu's minumum\n   * width.\n   */\n  triggerWidth?: number;\n} & AriaMenuOptions<MenuItemProps> &\n  Partial<OverlayProps> &\n  Partial<AriaPositionProps>;\n\nfunction Menu({\n  offset = 8,\n  crossOffset = 0,\n  containerPadding = 0,\n  placement = 'bottom left',\n  closeOnSelect = true,\n  triggerRef,\n  triggerWidth,\n  isSubmenu,\n  menuTitle,\n  closeRootMenu,\n  closeCurrentSubmenu,\n  isDismissable = true,\n  shouldCloseOnBlur = true,\n  ...props\n}: Props) {\n  const state = useTreeState<MenuItemProps>({...props, selectionMode: 'single'});\n  const stateCollection = useMemo(() => [...state.collection], [state.collection]);\n\n  // Implement focus states, keyboard navigation, aria-label,...\n  const menuRef = useRef(null);\n  const {menuProps} = useMenu({...props, selectionMode: 'single'}, state, menuRef);\n  const {separatorProps} = useSeparator({elementType: 'li'});\n\n  // If this is a submenu, pressing arrow left should close it (but not the\n  // root menu).\n  const {keyboardProps} = useKeyboard({\n    onKeyDown: e => {\n      if (isSubmenu && e.key === 'ArrowLeft') {\n        closeCurrentSubmenu?.();\n        return;\n      }\n      e.continuePropagation();\n    },\n  });\n\n  // Close the menu on outside interaction, blur, or Esc key press, and\n  // control its position relative to the trigger button. See:\n  // https://react-spectrum.adobe.com/react-aria/useOverlay.html\n  // https://react-spectrum.adobe.com/react-aria/useOverlayPosition.html\n  const overlayRef = useRef(null);\n  const {overlayProps} = useOverlay(\n    {\n      onClose: closeRootMenu,\n      shouldCloseOnBlur,\n      isDismissable,\n      isOpen: true,\n      shouldCloseOnInteractOutside: target =>\n        target && triggerRef.current !== target && !triggerRef.current?.contains(target),\n    },\n    overlayRef\n  );\n  const {overlayProps: positionProps, placement: placementProp} = useOverlayPosition({\n    targetRef: triggerRef,\n    overlayRef,\n    offset,\n    crossOffset,\n    placement,\n    containerPadding,\n    isOpen: true,\n    // useOverlayPosition's algorithm doesn't work well for submenus on viewport\n    // scroll. Changing the boundary element (document.body by default) seems to\n    // fix this.\n    boundaryElement: document.querySelector<HTMLElement>('.app') ?? undefined,\n  });\n\n  // Store whether this menu/submenu is the current focused one, which in a\n  // nested, tree-like menu system should be the leaf submenu. This\n  // information is used for controlling keyboard events. See:\n  // modifiedMenuProps below.\n  const [hasFocus, setHasFocus] = useState(true);\n  useEffect(() => {\n    // A submenu is a leaf when it does not contain any expanded submenu. This\n    // logically follows from the tree-like structure and single-selection\n    // nature of menus.\n    const isLeafSubmenu = !stateCollection.some(node => {\n      const isSection = node.hasChildNodes && !node.value.isSubmenu;\n      // A submenu with key [key] is expanded if\n      // state.selectionManager.isSelected([key]) = true\n      return isSection\n        ? [...node.childNodes].some(child =>\n            state.selectionManager.isSelected(`${child.key}`)\n          )\n        : state.selectionManager.isSelected(`${node.key}`);\n    });\n    setHasFocus(isLeafSubmenu);\n  }, [stateCollection, state.selectionManager]);\n  // Menu props from useMenu, modified to disable keyboard events if the\n  // current menu does not have focus.\n  const modifiedMenuProps = {\n    ...menuProps,\n    ...(!hasFocus && {\n      onKeyUp: () => null,\n      onKeyDown: () => null,\n    }),\n  };\n\n  // Render a single menu item\n  const renderItem = (node: Node<MenuItemProps>, isLastNode: boolean) => {\n    return (\n      <MenuItem\n        node={node}\n        isLastNode={isLastNode}\n        state={state}\n        onClose={closeRootMenu}\n        closeOnSelect={closeOnSelect}\n      />\n    );\n  };\n\n  // Render a submenu whose trigger button is a menu item\n  const renderItemWithSubmenu = (node: Node<MenuItemProps>, isLastNode: boolean) => {\n    const trigger = ({props: submenuTriggerProps, ref: submenuTriggerRef}) => (\n      <MenuItem\n        renderAs=\"div\"\n        node={node}\n        isLastNode={isLastNode}\n        state={state}\n        isSubmenuTrigger\n        submenuTriggerRef={submenuTriggerRef}\n        {...submenuTriggerProps}\n      />\n    );\n\n    return (\n      <MenuControl\n        items={node.value.children as MenuItemProps[]}\n        trigger={trigger}\n        menuTitle={node.value.submenuTitle}\n        placement=\"right top\"\n        offset={-4}\n        crossOffset={-8}\n        closeOnSelect={closeOnSelect}\n        isOpen={state.selectionManager.isSelected(node.key)}\n        isSubmenu\n        closeRootMenu={closeRootMenu}\n        closeCurrentSubmenu={() => state.selectionManager.clearSelection()}\n        renderWrapAs=\"li\"\n      />\n    );\n  };\n\n  // Render a collection of menu items\n  const renderCollection = (collection: Node<MenuItemProps>[]) =>\n    collection.map((node, i) => {\n      const isLastNode = collection.length - 1 === i;\n      const showSeparator =\n        !isLastNode && (node.type === 'section' || collection[i + 1]?.type === 'section');\n\n      let itemToRender: React.ReactNode;\n\n      if (node.type === 'section') {\n        itemToRender = (\n          <MenuSection node={node}>{renderCollection([...node.childNodes])}</MenuSection>\n        );\n      } else {\n        itemToRender = node.value.isSubmenu\n          ? renderItemWithSubmenu(node, isLastNode)\n          : renderItem(node, isLastNode);\n      }\n\n      return (\n        <Fragment key={node.key}>\n          {itemToRender}\n          {showSeparator && <Separator {...separatorProps} />}\n        </Fragment>\n      );\n    });\n\n  return (\n    <FocusScope restoreFocus autoFocus>\n      <Overlay\n        ref={overlayRef}\n        placementProp={placementProp}\n        {...mergeProps(overlayProps, positionProps, keyboardProps)}\n      >\n        <MenuWrap\n          ref={menuRef}\n          {...modifiedMenuProps}\n          style={{\n            maxHeight: positionProps.style?.maxHeight,\n            minWidth: triggerWidth,\n          }}\n        >\n          {menuTitle && <MenuTitle>{menuTitle}</MenuTitle>}\n          {renderCollection(stateCollection)}\n        </MenuWrap>\n      </Overlay>\n    </FocusScope>\n  );\n}\n\nexport default Menu;\n\nconst Overlay = styled('div')<{placementProp: PositionAria['placement']}>`\n  max-width: 24rem;\n  border-radius: ${p => p.theme.borderRadius};\n  background: ${p => p.theme.backgroundElevated};\n  box-shadow: 0 0 0 1px ${p => p.theme.translucentBorder}, ${p => p.theme.dropShadowHeavy};\n  font-size: ${p => p.theme.fontSizeMedium};\n\n  margin: ${space(1)} 0;\n  ${p => p.placementProp === 'top' && `margin-bottom: 0;`}\n  ${p => p.placementProp === 'bottom' && `margin-top: 0;`}\n\n  /* Override z-index from useOverlayPosition */\n  z-index: ${p => p.theme.zIndex.dropdown} !important;\n`;\n\nconst MenuWrap = styled('ul')`\n  margin: 0;\n  padding: ${space(0.5)} 0;\n  font-size: ${p => p.theme.fontSizeMedium};\n  overflow-x: hidden;\n  overflow-y: auto;\n\n  &:focus {\n    outline: none;\n  }\n`;\n\nconst MenuTitle = styled('div')`\n  font-weight: 600;\n  font-size: ${p => p.theme.fontSizeSmall};\n  color: ${p => p.theme.headingColor};\n  white-space: nowrap;\n  padding: ${space(0.25)} ${space(1.5)} ${space(0.75)};\n  margin-bottom: ${space(0.5)};\n  border-bottom: solid 1px ${p => p.theme.innerBorder};\n`;\n\nconst Separator = styled('li')`\n  list-style-type: none;\n  border-top: solid 1px ${p => p.theme.innerBorder};\n  margin: ${space(0.5)} ${space(1.5)};\n`;\n","import {useCallback, useEffect, useRef, useState} from 'react';\nimport styled from '@emotion/styled';\nimport {useButton} from '@react-aria/button';\nimport {AriaMenuOptions, useMenuTrigger} from '@react-aria/menu';\nimport {AriaPositionProps, OverlayProps} from '@react-aria/overlays';\nimport {useResizeObserver} from '@react-aria/utils';\nimport {Item, Section} from '@react-stately/collections';\nimport {useMenuTriggerState} from '@react-stately/menu';\nimport {MenuTriggerProps} from '@react-types/menu';\n\nimport DropdownButton, {DropdownButtonProps} from 'sentry/components/dropdownButtonV2';\nimport {MenuItemProps} from 'sentry/components/dropdownMenuItemV2';\nimport Menu from 'sentry/components/dropdownMenuV2';\n\ntype TriggerProps = {\n  props: Omit<React.HTMLAttributes<Element>, 'children'> & {\n    onClick?: (e: MouseEvent) => void;\n  };\n  ref: React.RefObject<HTMLButtonElement>;\n};\n\ntype Props = {\n  /**\n   * Items to display inside the dropdown menu. If the item has a `children`\n   * prop, it will be rendered as a menu section. If it has a `children` prop\n   * and its `isSubmenu` prop is true, it will be rendered as a submenu.\n   */\n  items: MenuItemProps[];\n  /**\n   * Pass class name to the outer wrap\n   */\n  className?: string;\n  /**\n   * If this is a submenu, it will in some cases need to close itself (e.g.\n   * when the user presses the arrow left key)\n   */\n  closeCurrentSubmenu?: () => void;\n  /**\n   * If this is a submenu, it will in some cases need to close the root menu\n   * (e.g. when a submenu item is clicked).\n   */\n  closeRootMenu?: () => void;\n  /**\n   * Whether the trigger is disabled.\n   */\n  isDisabled?: boolean;\n  /**\n   * Whether this is a submenu.\n   */\n  isSubmenu?: boolean;\n  /**\n   * Title for the current menu.\n   */\n  menuTitle?: string;\n  /**\n   * Tag name for the outer wrap, defaults to `div`\n   */\n  renderWrapAs?: React.ElementType;\n  /**\n   * Optionally replace the trigger button with a different component. Note\n   * that the replacement must have the `props` and `ref` (supplied in\n   * TriggerProps) forwarded its outer wrap, otherwise the accessibility\n   * features won't work correctly.\n   */\n  trigger?: (props: TriggerProps) => React.ReactNode;\n  /**\n   * By default, the menu trigger will be rendered as a button, with\n   * triggerLabel as the button label.\n   */\n  triggerLabel?: React.ReactNode;\n  /**\n   * If using the default button trigger (i.e. the custom `trigger` prop has\n   * not been provided), then `triggerProps` will be passed on to the button\n   * component.\n   */\n  triggerProps?: DropdownButtonProps;\n} & Partial<MenuTriggerProps> &\n  Partial<AriaMenuOptions<MenuItemProps>> &\n  Partial<OverlayProps> &\n  Partial<AriaPositionProps>;\n\n/**\n * A menu component that renders both the trigger button and the dropdown\n * menu. See: https://react-spectrum.adobe.com/react-aria/useMenuTrigger.html\n */\nfunction MenuControl({\n  items,\n  trigger,\n  triggerLabel,\n  triggerProps = {},\n  isDisabled: disabledProp,\n  isSubmenu = false,\n  closeRootMenu,\n  closeCurrentSubmenu,\n  renderWrapAs = 'div',\n  className,\n  ...props\n}: Props) {\n  const ref = useRef<HTMLButtonElement>(null);\n  const isDisabled = disabledProp ?? (!items || items.length === 0);\n\n  // Control the menu open state. See:\n  // https://react-spectrum.adobe.com/react-aria/useMenuTrigger.html\n  const state = useMenuTriggerState(props);\n  const {menuTriggerProps, menuProps} = useMenuTrigger(\n    {type: 'menu', isDisabled},\n    state,\n    ref\n  );\n  const {buttonProps} = useButton(\n    {\n      isDisabled,\n      ...menuTriggerProps,\n      ...(isSubmenu && {\n        onKeyUp: e => e.continuePropagation(),\n        onKeyDown: e => e.continuePropagation(),\n        onPress: () => null,\n        onPressStart: () => null,\n        onPressEnd: () => null,\n      }),\n    },\n    ref\n  );\n\n  // Calculate the current trigger element's width. This will be used as\n  // the min width for the menu.\n  const [triggerWidth, setTriggerWidth] = useState<number>();\n  // Update triggerWidth when its size changes using useResizeObserver\n  const updateTriggerWidth = useCallback(async () => {\n    // Wait until the trigger element finishes rendering, otherwise\n    // ResizeObserver might throw an infinite loop error.\n    await new Promise(resolve => window.setTimeout(resolve));\n\n    const newTriggerWidth = ref.current?.offsetWidth;\n    !isSubmenu && newTriggerWidth && setTriggerWidth(newTriggerWidth);\n  }, [trigger, triggerLabel, triggerProps]);\n  useResizeObserver({ref, onResize: updateTriggerWidth});\n  // If ResizeObserver is not available, manually update the width\n  // when any of [trigger, triggerLabel, triggerProps] changes.\n  useEffect(() => {\n    if (typeof window.ResizeObserver !== 'undefined') {\n      return;\n    }\n    updateTriggerWidth();\n  }, [updateTriggerWidth]);\n\n  // Recursively remove hidden items, including those nested in submenus\n  function removeHiddenItems(source) {\n    return source\n      .filter(item => !item.hidden)\n      .map(item => ({\n        ...item,\n        ...(item.children ? {children: removeHiddenItems(item.children)} : {}),\n      }));\n  }\n\n  function renderTrigger() {\n    if (trigger) {\n      return trigger({\n        props: {\n          ...triggerProps,\n          ...buttonProps,\n          isOpen: state.isOpen,\n        },\n        ref,\n      });\n    }\n    return (\n      <DropdownButton ref={ref} isOpen={state.isOpen} {...triggerProps} {...buttonProps}>\n        {triggerLabel}\n      </DropdownButton>\n    );\n  }\n\n  function renderMenu() {\n    if (!state.isOpen) {\n      return null;\n    }\n\n    return (\n      <Menu\n        {...props}\n        {...menuProps}\n        triggerRef={ref}\n        triggerWidth={triggerWidth}\n        isSubmenu={isSubmenu}\n        isDismissable={!isSubmenu && props.isDismissable}\n        shouldCloseOnBlur={!isSubmenu && props.shouldCloseOnBlur}\n        closeRootMenu={closeRootMenu ?? state.close}\n        closeCurrentSubmenu={closeCurrentSubmenu}\n        items={removeHiddenItems(items)}\n      >\n        {(item: MenuItemProps) => {\n          if (item.children && item.children.length > 0 && !item.isSubmenu) {\n            return (\n              <Section key={item.key} title={item.label} items={item.children}>\n                {sectionItem => <Item {...sectionItem}>{sectionItem.label}</Item>}\n              </Section>\n            );\n          }\n          return <Item {...item}>{item.label}</Item>;\n        }}\n      </Menu>\n    );\n  }\n\n  return (\n    <MenuControlWrap className={className} as={renderWrapAs} role=\"presentation\">\n      {renderTrigger()}\n      {renderMenu()}\n    </MenuControlWrap>\n  );\n}\n\nexport default MenuControl;\n\nconst MenuControlWrap = styled('div')`\n  list-style-type: none;\n`;\n","import {forwardRef} from 'react';\n\ntype OnChangeHandler = (\n  value: boolean,\n  event: React.ChangeEvent<HTMLInputElement>\n) => void;\n\ntype OptionProps = {\n  label: string;\n  value: string;\n  checked?: boolean;\n  disabled?: boolean;\n  name?: string;\n  onChange?: OnChangeHandler;\n};\n\nconst Option = forwardRef(function Option(\n  {name, disabled, label, value, checked, onChange}: OptionProps,\n  ref: React.Ref<HTMLInputElement>\n) {\n  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {\n    const isTrue = e.target.value === 'true';\n\n    onChange?.(isTrue, e);\n  }\n\n  return (\n    <div className=\"radio\">\n      <label style={{fontWeight: 'normal'}}>\n        <input\n          ref={ref}\n          type=\"radio\"\n          value={value}\n          name={name}\n          checked={checked}\n          onChange={handleChange}\n          disabled={disabled}\n        />{' '}\n        {label}\n      </label>\n    </div>\n  );\n});\n\ntype Props = {\n  disabled?: boolean;\n  name?: string;\n  noLabel?: string;\n  onChange?: OnChangeHandler;\n  value?: boolean;\n  yesFirst?: boolean;\n  yesLabel?: string;\n};\n\nconst RadioBoolean = forwardRef(function RadioBoolean(\n  {\n    disabled,\n    name,\n    onChange,\n    value,\n    yesFirst = true,\n    yesLabel = 'Yes',\n    noLabel = 'No',\n  }: Props,\n  ref: React.Ref<HTMLInputElement>\n) {\n  const yesOption = (\n    <Option\n      ref={ref}\n      value=\"true\"\n      checked={value === true}\n      name={name}\n      disabled={disabled}\n      label={yesLabel}\n      onChange={onChange}\n    />\n  );\n  const noOption = (\n    <Option\n      value=\"false\"\n      checked={value === false}\n      name={name}\n      disabled={disabled}\n      label={noLabel}\n      onChange={onChange}\n    />\n  );\n\n  return (\n    <div>\n      {yesFirst ? yesOption : noOption}\n      {yesFirst ? noOption : yesOption}\n    </div>\n  );\n});\n\nexport default RadioBoolean;\n","import {lazy, Suspense} from 'react';\nimport type {OnChangeProps} from 'react-date-range';\nimport styled from '@emotion/styled';\nimport moment from 'moment';\n\nimport DropdownMenu from 'sentry/components/dropdownMenu';\nimport LoadingIndicator from 'sentry/components/loadingIndicator';\nimport Placeholder from 'sentry/components/placeholder';\nimport {IconCalendar} from 'sentry/icons';\nimport {inputStyles} from 'sentry/styles/input';\nimport space from 'sentry/styles/space';\n\nimport InputField, {InputFieldProps, onEvent} from './inputField';\n\ninterface DatePickerFieldProps extends Omit<InputFieldProps, 'field'> {}\n\nfunction handleChangeDate(\n  onChange: onEvent,\n  onBlur: onEvent,\n  date: OnChangeProps,\n  close: Function\n) {\n  onChange(date);\n  onBlur(date);\n\n  // close dropdown menu\n  close();\n}\n\nconst Calendar = lazy(() => import('./calendarField'));\n\nexport default function DatePickerField(props: DatePickerFieldProps) {\n  return (\n    <InputField\n      {...props}\n      field={({onChange, onBlur, value, id}) => {\n        const dateObj = new Date(value);\n        const inputValue = !isNaN(dateObj.getTime()) ? dateObj : new Date();\n        const dateString = moment(inputValue).format('LL');\n\n        return (\n          <DropdownMenu keepMenuOpen>\n            {({isOpen, getRootProps, getActorProps, getMenuProps, actions}) => (\n              <div {...getRootProps()}>\n                <InputWrapper id={id} {...getActorProps()} isOpen={isOpen}>\n                  <StyledInput readOnly value={dateString} />\n                  <CalendarIcon>\n                    <IconCalendar />\n                  </CalendarIcon>\n                </InputWrapper>\n\n                {isOpen && (\n                  <CalendarMenu {...getMenuProps()}>\n                    <Suspense\n                      fallback={\n                        <Placeholder width=\"332px\" height=\"282px\">\n                          <LoadingIndicator />\n                        </Placeholder>\n                      }\n                    >\n                      <Calendar\n                        date={inputValue}\n                        onChange={date =>\n                          handleChangeDate(onChange, onBlur, date, actions.close)\n                        }\n                      />\n                    </Suspense>\n                  </CalendarMenu>\n                )}\n              </div>\n            )}\n          </DropdownMenu>\n        );\n      }}\n    />\n  );\n}\n\ntype InputWrapperProps = {\n  isOpen: boolean;\n};\n\nconst InputWrapper = styled('div')<InputWrapperProps>`\n  ${inputStyles}\n  cursor: text;\n  display: flex;\n  z-index: ${p => p.theme.zIndex.dropdownAutocomplete.actor};\n  ${p => p.isOpen && 'border-bottom-left-radius: 0'}\n`;\n\nconst StyledInput = styled('input')`\n  border: none;\n  outline: none;\n  flex: 1;\n`;\n\nconst CalendarMenu = styled('div')`\n  display: flex;\n  background: ${p => p.theme.background};\n  position: absolute;\n  left: 0;\n  border: 1px solid ${p => p.theme.border};\n  border-top: none;\n  z-index: ${p => p.theme.zIndex.dropdownAutocomplete.menu};\n  margin-top: -1px;\n\n  .rdrMonthAndYearWrapper {\n    height: 50px;\n    padding-top: 0;\n  }\n`;\n\nconst CalendarIcon = styled('div')`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: ${space(1)};\n`;\n","import omit from 'lodash/omit';\n\nimport RadioBoolean from './controls/radioBoolean';\nimport InputField, {InputFieldProps} from './inputField';\n\nexport default function RadioBooleanField(props: Omit<InputFieldProps, 'field'>) {\n  return (\n    <InputField\n      {...props}\n      field={fieldProps => (\n        <RadioBoolean {...omit(fieldProps, ['onKeyDown', 'children'])} />\n      )}\n    />\n  );\n}\n","import styled from '@emotion/styled';\n\nimport space from 'sentry/styles/space';\nimport {getKeyCode} from 'sentry/utils/getKeyCode';\n\nconst macModifiers = {\n  18: '⌥',\n  17: '⌃',\n  91: '⌘',\n};\n\nconst normalModifiers = {\n  18: 'ALT',\n  17: 'CTRL',\n};\n\nconst genericGlyphs = {\n  16: '⇧',\n  8: '⌫',\n  37: '←',\n  38: '↑',\n  39: '→',\n  40: '↓',\n  107: '+',\n};\n\nconst keyToDisplay = (\n  key: string,\n  isMac: boolean\n): {label: React.ReactNode; specificToOs: 'macos' | 'generic'} => {\n  const keyCode = getKeyCode(key);\n\n  // Not a special key\n  if (!keyCode) {\n    return {label: <Key>{key.toUpperCase()}</Key>, specificToOs: 'generic'};\n  }\n\n  const modifierMap = isMac ? macModifiers : normalModifiers;\n  const keyStr = modifierMap[keyCode] ?? genericGlyphs[keyCode] ?? key.toUpperCase();\n\n  const specificToOs = keyCode === getKeyCode('command') ? 'macos' : 'generic';\n\n  return {label: <Key key={keyStr}>{keyStr}</Key>, specificToOs};\n};\n\ntype Props = {\n  /**\n   * Pass key combinations in with + as the separator.\n   * For example: `'command+option+x'`\n   *\n   * Pass an array of strings for fallback key combos when the first one contains a key that does not exist on that os (non-mac):\n   * `['command+option+x', 'ctrl+shift+x']`\n   * (does not have to be the same combo)\n   */\n  value: string[] | string;\n  forcePlatform?: 'macos' | 'generic';\n};\n\nconst HotkeysLabel = ({value, forcePlatform}: Props) => {\n  // Split by commas and then split by +, but allow escaped /+\n  const hotkeySets = (Array.isArray(value) ? value : [value]).map(o =>\n    o.trim().split('+')\n  );\n\n  const isMac = forcePlatform\n    ? forcePlatform === 'macos'\n    : window?.navigator?.platform?.toLowerCase().startsWith('mac') ?? false;\n\n  // If we're not using mac find the first key set that is generic.\n  // Otherwise show whatever the first hotkey is.\n  const finalKeySet = hotkeySets\n    .map(keySet => keySet.map(key => keyToDisplay(key, isMac)))\n    .find(keySet =>\n      !isMac ? keySet.every(key => key.specificToOs === 'generic') : true\n    );\n\n  // No key available for the OS. Don't show a hotkey\n  if (finalKeySet === undefined) {\n    return null;\n  }\n\n  return <HotkeysContainer>{finalKeySet.map(key => key.label)}</HotkeysContainer>;\n};\n\nexport default HotkeysLabel;\n\nconst Key = styled('span')`\n  font-size: ${p => p.theme.fontSizeMedium};\n`;\n\nconst HotkeysContainer = styled('div')`\n  font-family: ${p => p.theme.text.family};\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  > * {\n    margin-right: ${space(0.5)};\n  }\n`;\n","import {Component} from 'react';\n\nimport {addLoadingMessage, clearIndicators} from 'sentry/actionCreators/indicator';\nimport {ModalRenderProps} from 'sentry/actionCreators/modal';\nimport {createSavedSearch} from 'sentry/actionCreators/savedSearches';\nimport {Client} from 'sentry/api';\nimport Alert from 'sentry/components/alert';\nimport {Form, SelectField, TextField} from 'sentry/components/forms';\nimport {OnSubmitCallback} from 'sentry/components/forms/type';\nimport {t} from 'sentry/locale';\nimport {Organization} from 'sentry/types';\nimport withApi from 'sentry/utils/withApi';\n\nimport {getSortLabel, IssueSortOptions} from './utils';\n\ntype Props = ModalRenderProps & {\n  api: Client;\n  organization: Organization;\n  query: string;\n  sort?: string;\n};\n\ntype State = {\n  error: string | null;\n  isSaving: boolean;\n};\n\nconst DEFAULT_SORT_OPTIONS = [\n  IssueSortOptions.DATE,\n  IssueSortOptions.NEW,\n  IssueSortOptions.FREQ,\n  IssueSortOptions.PRIORITY,\n  IssueSortOptions.USER,\n];\n\nclass CreateSavedSearchModal extends Component<Props, State> {\n  state: State = {\n    isSaving: false,\n    error: null,\n  };\n\n  /** Handle \"date added\" sort not being available for saved searches */\n  validateSortOption(sort?: string | null): string {\n    if (this.sortOptions().find(option => option === sort)) {\n      return sort as string;\n    }\n\n    return IssueSortOptions.DATE;\n  }\n\n  handleSubmit: OnSubmitCallback = (data, onSubmitSuccess, onSubmitError, event) => {\n    const {api, organization} = this.props;\n    const sort = this.validateSortOption(data.sort);\n\n    event.preventDefault();\n\n    this.setState({isSaving: true});\n\n    addLoadingMessage(t('Saving Changes'));\n\n    createSavedSearch(api, organization.slug, data.name, data.query, sort)\n      .then(_data => {\n        this.props.closeModal();\n        this.setState({\n          error: null,\n          isSaving: false,\n        });\n        clearIndicators();\n        onSubmitSuccess(data);\n      })\n      .catch(err => {\n        let error = t('Unable to save your changes.');\n        if (err.responseJSON && err.responseJSON.detail) {\n          error = err.responseJSON.detail;\n        }\n        this.setState({\n          error,\n          isSaving: false,\n        });\n        clearIndicators();\n        onSubmitError(error);\n      });\n  };\n\n  sortOptions() {\n    const {organization} = this.props;\n    const options = [...DEFAULT_SORT_OPTIONS];\n    if (organization?.features?.includes('issue-list-trend-sort')) {\n      options.push(IssueSortOptions.TREND);\n    }\n\n    return options;\n  }\n\n  render() {\n    const {error} = this.state;\n    const {Header, Body, closeModal, query, sort} = this.props;\n\n    const sortOptions = this.sortOptions().map(sortOption => ({\n      value: sortOption,\n      label: getSortLabel(sortOption),\n    }));\n    const initialData = {\n      name: '',\n      query,\n      sort: this.validateSortOption(sort),\n    };\n\n    return (\n      <Form\n        onSubmit={this.handleSubmit}\n        onCancel={closeModal}\n        saveOnBlur={false}\n        initialData={initialData}\n        submitLabel={t('Save')}\n      >\n        <Header>\n          <h4>{t('Save Current Search')}</h4>\n        </Header>\n\n        <Body>\n          {this.state.error && <Alert type=\"error\">{error}</Alert>}\n\n          <p>{t('All team members will now have access to this search.')}</p>\n          <TextField\n            key=\"name\"\n            name=\"name\"\n            label={t('Name')}\n            placeholder=\"e.g. My Search Results\"\n            inline={false}\n            stacked\n            flexibleControlStateSize\n            required\n          />\n          <TextField\n            key=\"query\"\n            name=\"query\"\n            label={t('Query')}\n            inline={false}\n            stacked\n            flexibleControlStateSize\n            required\n          />\n          <SelectField\n            key=\"sort\"\n            name=\"sort\"\n            label={t('Sort By')}\n            options={sortOptions}\n            required\n            clearable={false}\n            inline={false}\n            stacked\n            flexibleControlStateSize\n          />\n        </Body>\n      </Form>\n    );\n  }\n}\n\nexport default withApi(CreateSavedSearchModal);\n","import {browserHistory, withRouter, WithRouterProps} from 'react-router';\nimport styled from '@emotion/styled';\n\nimport {openModal} from 'sentry/actionCreators/modal';\nimport {pinSearch, unpinSearch} from 'sentry/actionCreators/savedSearches';\nimport Access from 'sentry/components/acl/access';\nimport Button from 'sentry/components/button';\nimport MenuItem from 'sentry/components/menuItem';\nimport {IconAdd, IconPin, IconSliders} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport {SavedSearch, SavedSearchType} from 'sentry/types';\nimport {trackAnalyticsEvent} from 'sentry/utils/analytics';\nimport CreateSavedSearchModal from 'sentry/views/issueList/createSavedSearchModal';\n\nimport SmartSearchBar from './index';\nimport {removeSpace} from './utils';\n\ntype SmartSearchBarProps = React.ComponentProps<typeof SmartSearchBar>;\n\ntype ActionItem = NonNullable<SmartSearchBarProps['actionBarItems']>[number];\ntype ActionProps = React.ComponentProps<ActionItem['Action']>;\n\ntype PinSearchActionOpts = {\n  /**\n   * The current issue sort\n   */\n  sort: string;\n  /**\n   * The currently pinned search\n   */\n  pinnedSearch?: SavedSearch;\n};\n\n/**\n * The Pin Search action toggles the current as a pinned search\n */\nexport function makePinSearchAction({pinnedSearch, sort}: PinSearchActionOpts) {\n  const PinSearchAction = ({\n    menuItemVariant,\n    savedSearchType,\n    organization,\n    api,\n    query,\n    location,\n  }: ActionProps & WithRouterProps) => {\n    const onTogglePinnedSearch = async (evt: React.MouseEvent) => {\n      evt.preventDefault();\n      evt.stopPropagation();\n\n      if (savedSearchType === undefined) {\n        return;\n      }\n\n      const {cursor: _cursor, page: _page, ...currentQuery} = location.query;\n\n      trackAnalyticsEvent({\n        eventKey: 'search.pin',\n        eventName: 'Search: Pin',\n        organization_id: organization.id,\n        action: !!pinnedSearch ? 'unpin' : 'pin',\n        search_type: savedSearchType === SavedSearchType.ISSUE ? 'issues' : 'events',\n        query: pinnedSearch?.query ?? query,\n      });\n\n      if (!!pinnedSearch) {\n        unpinSearch(api, organization.slug, savedSearchType, pinnedSearch).then(() => {\n          browserHistory.push({\n            ...location,\n            pathname: `/organizations/${organization.slug}/issues/`,\n            query: {\n              ...currentQuery,\n              query: pinnedSearch.query,\n              sort: pinnedSearch.sort,\n            },\n          });\n        });\n        return;\n      }\n\n      const resp = await pinSearch(\n        api,\n        organization.slug,\n        savedSearchType,\n        removeSpace(query),\n        sort\n      );\n\n      if (!resp || !resp.id) {\n        return;\n      }\n\n      browserHistory.push({\n        ...location,\n        pathname: `/organizations/${organization.slug}/issues/searches/${resp.id}/`,\n        query: currentQuery,\n      });\n    };\n\n    const pinTooltip = !!pinnedSearch ? t('Unpin this search') : t('Pin this search');\n\n    return menuItemVariant ? (\n      <MenuItem\n        withBorder\n        data-test-id=\"pin-icon\"\n        icon={<IconPin isSolid={!!pinnedSearch} size=\"xs\" />}\n        onClick={onTogglePinnedSearch}\n      >\n        {!!pinnedSearch ? t('Unpin Search') : t('Pin Search')}\n      </MenuItem>\n    ) : (\n      <ActionButton\n        title={pinTooltip}\n        disabled={!query}\n        aria-label={pinTooltip}\n        onClick={onTogglePinnedSearch}\n        isActive={!!pinnedSearch}\n        data-test-id=\"pin-icon\"\n        icon={<IconPin isSolid={!!pinnedSearch} size=\"xs\" />}\n      />\n    );\n  };\n\n  return {key: 'pinSearch', Action: withRouter(PinSearchAction)};\n}\n\ntype SaveSearchActionOpts = {\n  /**\n   * The current issue sort\n   */\n  sort: string;\n};\n\n/**\n * The Save Search action triggers the create saved search modal from the\n * current query.\n */\nexport function makeSaveSearchAction({sort}: SaveSearchActionOpts) {\n  const SavedSearchAction = ({menuItemVariant, query, organization}: ActionProps) => {\n    const onClick = () =>\n      openModal(deps => (\n        <CreateSavedSearchModal {...deps} {...{organization, query, sort}} />\n      ));\n\n    return (\n      <Access organization={organization} access={['org:write']}>\n        {menuItemVariant ? (\n          <MenuItem withBorder icon={<IconAdd size=\"xs\" />} onClick={onClick}>\n            {t('Create Saved Search')}\n          </MenuItem>\n        ) : (\n          <ActionButton\n            onClick={onClick}\n            data-test-id=\"save-current-search\"\n            icon={<IconAdd size=\"xs\" />}\n            title={t('Add to organization saved searches')}\n            aria-label={t('Add to organization saved searches')}\n          />\n        )}\n      </Access>\n    );\n  };\n\n  return {key: 'saveSearch', Action: SavedSearchAction};\n}\n\ntype SearchBuilderActionOpts = {\n  onSidebarToggle: React.MouseEventHandler;\n};\n\n/**\n * The Search Builder action toggles the Issue Stream search builder\n */\nexport function makeSearchBuilderAction({onSidebarToggle}: SearchBuilderActionOpts) {\n  const SearchBuilderAction = ({menuItemVariant}: ActionProps) =>\n    menuItemVariant ? (\n      <MenuItem withBorder icon={<IconSliders size=\"xs\" />} onClick={onSidebarToggle}>\n        {t('Toggle sidebar')}\n      </MenuItem>\n    ) : (\n      <ActionButton\n        title={t('Toggle search builder')}\n        tooltipProps={{containerDisplayMode: 'inline-flex'}}\n        aria-label={t('Toggle search builder')}\n        onClick={onSidebarToggle}\n        icon={<IconSliders size=\"xs\" />}\n      />\n    );\n\n  return {key: 'searchBuilder', Action: SearchBuilderAction};\n}\n\nexport const ActionButton = styled(Button)<{isActive?: boolean}>`\n  color: ${p => (p.isActive ? p.theme.blue300 : p.theme.gray300)};\n  width: 18px;\n\n  &,\n  &:hover,\n  &:focus {\n    background: transparent;\n  }\n\n  &:hover {\n    color: ${p => p.theme.gray400};\n  }\n`;\n\nActionButton.defaultProps = {\n  type: 'button',\n  borderless: true,\n  size: 'zero',\n};\n","import {useHotkeys} from 'sentry/utils/useHotkeys';\n\nimport {QuickAction} from './types';\nimport {quickActions} from './utils';\n\nconst SearchHotkeysListener = ({\n  runQuickAction,\n}: {\n  runQuickAction: (action: QuickAction) => void;\n}) => {\n  useHotkeys(\n    quickActions\n      .filter(action => typeof action.hotkeys !== 'undefined')\n      .map(action => ({\n        match: action.hotkeys?.actual ?? [],\n        callback: e => {\n          e.preventDefault();\n          runQuickAction(action);\n        },\n      })),\n    [runQuickAction]\n  );\n\n  return null;\n};\n\nexport default SearchHotkeysListener;\n","import {Component, createRef} from 'react';\nimport TextareaAutosize from 'react-autosize-textarea';\nimport {withRouter, WithRouterProps} from 'react-router';\nimport isPropValid from '@emotion/is-prop-valid';\nimport styled from '@emotion/styled';\nimport * as Sentry from '@sentry/react';\nimport debounce from 'lodash/debounce';\n\nimport {addErrorMessage} from 'sentry/actionCreators/indicator';\nimport {fetchRecentSearches, saveRecentSearch} from 'sentry/actionCreators/savedSearches';\nimport {Client} from 'sentry/api';\nimport ButtonBar from 'sentry/components/buttonBar';\nimport DropdownLink from 'sentry/components/dropdownLink';\nimport {normalizeDateTimeParams} from 'sentry/components/organizations/pageFilters/parse';\nimport {\n  FilterType,\n  ParseResult,\n  parseSearch,\n  TermOperator,\n  Token,\n  TokenResult,\n} from 'sentry/components/searchSyntax/parser';\nimport HighlightQuery from 'sentry/components/searchSyntax/renderer';\nimport {\n  getKeyName,\n  isWithinToken,\n  treeResultLocator,\n} from 'sentry/components/searchSyntax/utils';\nimport {\n  DEFAULT_DEBOUNCE_DURATION,\n  MAX_AUTOCOMPLETE_RELEASES,\n  NEGATION_OPERATOR,\n} from 'sentry/constants';\nimport {IconClose, IconEllipsis, IconSearch} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport MemberListStore from 'sentry/stores/memberListStore';\nimport space from 'sentry/styles/space';\nimport {Organization, SavedSearchType, Tag, User} from 'sentry/types';\nimport {defined} from 'sentry/utils';\nimport trackAdvancedAnalyticsEvent from 'sentry/utils/analytics/trackAdvancedAnalyticsEvent';\nimport {callIfFunction} from 'sentry/utils/callIfFunction';\nimport getDynamicComponent from 'sentry/utils/getDynamicComponent';\nimport withApi from 'sentry/utils/withApi';\nimport withOrganization from 'sentry/utils/withOrganization';\n\nimport {ActionButton} from './actions';\nimport SearchDropdown from './searchDropdown';\nimport SearchHotkeysListener from './searchHotkeysListener';\nimport {ItemType, QuickAction, QuickActionType, SearchGroup, SearchItem} from './types';\nimport {\n  addSpace,\n  createSearchGroups,\n  filterSearchGroupsByIndex,\n  generateOperatorEntryMap,\n  getValidOps,\n  quickActions,\n  removeSpace,\n} from './utils';\n\nconst DROPDOWN_BLUR_DURATION = 200;\n\n/**\n * The max width in pixels of the search bar at which the buttons will\n * have overflowed into the dropdown.\n */\nconst ACTION_OVERFLOW_WIDTH = 400;\n\n/**\n * Actions are moved to the overflow dropdown after each pixel step is reached.\n */\nconst ACTION_OVERFLOW_STEPS = 75;\n\nconst makeQueryState = (query: string) => ({\n  query,\n  parsedQuery: parseSearch(query),\n});\n\nconst generateOpAutocompleteGroup = (\n  validOps: readonly TermOperator[],\n  tagName: string\n): AutocompleteGroup => {\n  const operatorMap = generateOperatorEntryMap(tagName);\n  const operatorItems = validOps.map(op => operatorMap[op]);\n  return {\n    searchItems: operatorItems,\n    recentSearchItems: undefined,\n    tagName: '',\n    type: ItemType.TAG_OPERATOR,\n  };\n};\n\nconst escapeValue = (value: string): string => {\n  // Wrap in quotes if there is a space\n  return value.includes(' ') || value.includes('\"')\n    ? `\"${value.replace(/\"/g, '\\\\\"')}\"`\n    : value;\n};\n\ntype ActionProps = {\n  api: Client;\n  /**\n   * The organization\n   */\n  organization: Organization;\n  /**\n   * The current query\n   */\n  query: string;\n  /**\n   * Render the actions as a menu item\n   */\n  menuItemVariant?: boolean;\n  /**\n   * The saved search type passed to the search bar\n   */\n  savedSearchType?: SavedSearchType;\n};\n\ntype ActionBarItem = {\n  /**\n   * The action component to render\n   */\n  Action: React.ComponentType<ActionProps>;\n  /**\n   * Name of the action\n   */\n  key: string;\n};\n\ntype AutocompleteGroup = {\n  recentSearchItems: SearchItem[] | undefined;\n  searchItems: SearchItem[];\n  tagName: string;\n  type: ItemType;\n};\n\ntype Props = WithRouterProps & {\n  api: Client;\n  organization: Organization;\n  /**\n   * Additional components to render as actions on the right of the search bar\n   */\n  actionBarItems?: ActionBarItem[];\n  className?: string;\n\n  defaultQuery?: string;\n  /**\n   * Search items to display when there's no tag key. Is a tuple of search\n   * items and recent search items\n   */\n  defaultSearchItems?: [SearchItem[], SearchItem[]];\n  /**\n   * Disabled control (e.g. read-only)\n   */\n  disabled?: boolean;\n  dropdownClassName?: string;\n  /**\n   * If true, excludes the environment tag from the autocompletion list. This\n   * is because we don't want to treat environment as a tag in some places such\n   * as the stream view where it is a top level concept\n   */\n  excludeEnvironment?: boolean;\n  /**\n   * A function to get documentation for a field\n   */\n  getFieldDoc?: (key: string) => React.ReactNode;\n  /**\n   * List user's recent searches\n   */\n  hasRecentSearches?: boolean;\n  /**\n   * Allows additional content to be played before the search bar and icon\n   */\n  inlineLabel?: React.ReactNode;\n  /**\n   * Maximum height for the search dropdown menu\n   */\n  maxMenuHeight?: number;\n  /**\n   * Used to enforce length on the query\n   */\n  maxQueryLength?: number;\n  /**\n   * Maximum number of search items to display or a falsey value for no\n   * maximum\n   */\n  maxSearchItems?: number;\n  /**\n   * While the data is unused, this list of members can be updated to\n   * trigger re-renders.\n   */\n  members?: User[];\n  /**\n   * Called when the search is blurred\n   */\n  onBlur?: (value: string) => void;\n  /**\n   * Called when the search input changes\n   */\n  onChange?: (value: string, e: React.ChangeEvent) => void;\n  /**\n   * Get a list of recent searches for the current query\n   */\n  onGetRecentSearches?: (query: string) => Promise<SearchItem[]>;\n  /**\n   * Get a list of tag values for the passed tag\n   */\n  onGetTagValues?: (tag: Tag, query: string, params: object) => Promise<string[]>;\n  /**\n   * Called on key down\n   */\n  onKeyDown?: (evt: React.KeyboardEvent<HTMLTextAreaElement>) => void;\n  /**\n   * Called when a recent search is saved\n   */\n  onSavedRecentSearch?: (query: string) => void;\n  /**\n   * Called when the user makes a search\n   */\n  onSearch?: (query: string) => void;\n  /**\n   * Input placeholder\n   */\n  placeholder?: string;\n  /**\n   * Prepare query value before filtering dropdown items\n   */\n  prepareQuery?: (query: string) => string;\n  query?: string | null;\n  /**\n   * If this is defined, attempt to save search term scoped to the user and\n   * the current org\n   */\n  savedSearchType?: SavedSearchType;\n  /**\n   * Indicates the usage of the search bar for analytics\n   */\n  searchSource?: string;\n  /**\n   * Type of supported tags\n   */\n  supportedTagType?: ItemType;\n  /**\n   * Map of tags\n   */\n  supportedTags?: {[key: string]: Tag};\n  /**\n   * Wrap the input with a form. Useful if search bar is used within a parent\n   * form\n   */\n  useFormWrapper?: boolean;\n};\n\ntype State = {\n  /**\n   * Index of the focused search item\n   */\n  activeSearchItem: number;\n  flatSearchItems: SearchItem[];\n  inputHasFocus: boolean;\n  loading: boolean;\n  /**\n   * The number of actions that are not in the overflow menu.\n   */\n  numActionsVisible: number;\n  /**\n   * The query parsed into an AST. If the query fails to parse this will be\n   * null.\n   */\n  parsedQuery: ParseResult | null;\n  /**\n   * The current search query in the input\n   */\n  query: string;\n  searchGroups: SearchGroup[];\n  /**\n   * The current search term (or 'key') that that we will be showing\n   * autocompletion for.\n   */\n  searchTerm: string;\n  tags: Record<string, string>;\n  /**\n   * Indicates that we have a query that we've already determined not to have\n   * any values. This is used to stop the autocompleter from querying if we\n   * know we will find nothing.\n   */\n  noValueQuery?: string;\n  /**\n   * The query in the input since we last updated our autocomplete list.\n   */\n  previousQuery?: string;\n};\n\nclass SmartSearchBar extends Component<Props, State> {\n  static defaultProps = {\n    defaultQuery: '',\n    query: null,\n    onSearch: function () {},\n    excludeEnvironment: false,\n    placeholder: t('Search for events, users, tags, and more'),\n    supportedTags: {},\n    defaultSearchItems: [[], []],\n    useFormWrapper: true,\n    savedSearchType: SavedSearchType.ISSUE,\n  };\n\n  state: State = {\n    query: this.initialQuery,\n    parsedQuery: parseSearch(this.initialQuery),\n    searchTerm: '',\n    searchGroups: [],\n    flatSearchItems: [],\n    activeSearchItem: -1,\n    tags: {},\n    inputHasFocus: false,\n    loading: false,\n    numActionsVisible: this.props.actionBarItems?.length ?? 0,\n  };\n\n  componentDidMount() {\n    if (!window.ResizeObserver) {\n      return;\n    }\n\n    if (this.containerRef.current === null) {\n      return;\n    }\n\n    this.inputResizeObserver = new ResizeObserver(this.updateActionsVisible);\n    this.inputResizeObserver.observe(this.containerRef.current);\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const {query} = this.props;\n    const {query: lastQuery} = prevProps;\n\n    if (query !== lastQuery && (defined(query) || defined(lastQuery))) {\n      // eslint-disable-next-line react/no-did-update-set-state\n      this.setState(makeQueryState(addSpace(query ?? undefined)));\n    }\n  }\n\n  componentWillUnmount() {\n    this.inputResizeObserver?.disconnect();\n    window.clearTimeout(this.blurTimeout);\n  }\n\n  get initialQuery() {\n    const {query, defaultQuery} = this.props;\n    return query !== null ? addSpace(query) : defaultQuery ?? '';\n  }\n\n  /**\n   * Tracks the dropdown blur\n   */\n  blurTimeout: number | undefined = undefined;\n\n  /**\n   * Ref to the search element itself\n   */\n  searchInput = createRef<HTMLTextAreaElement>();\n\n  /**\n   * Ref to the search container\n   */\n  containerRef = createRef<HTMLDivElement>();\n\n  /**\n   * Used to determine when actions should be moved to the action overflow menu\n   */\n  inputResizeObserver: ResizeObserver | null = null;\n\n  /**\n   * Updates the numActionsVisible count as the search bar is resized\n   */\n  updateActionsVisible = (entries: ResizeObserverEntry[]) => {\n    if (entries.length === 0) {\n      return;\n    }\n\n    const entry = entries[0];\n    const {width} = entry.contentRect;\n    const actionCount = this.props.actionBarItems?.length ?? 0;\n\n    const numActionsVisible = Math.min(\n      actionCount,\n      Math.floor(Math.max(0, width - ACTION_OVERFLOW_WIDTH) / ACTION_OVERFLOW_STEPS)\n    );\n\n    if (this.state.numActionsVisible === numActionsVisible) {\n      return;\n    }\n\n    this.setState({numActionsVisible});\n  };\n\n  blur() {\n    if (!this.searchInput.current) {\n      return;\n    }\n    this.searchInput.current.blur();\n  }\n\n  async doSearch() {\n    this.blur();\n\n    if (!this.hasValidSearch) {\n      return;\n    }\n\n    const query = removeSpace(this.state.query);\n    const {\n      onSearch,\n      onSavedRecentSearch,\n      api,\n      organization,\n      savedSearchType,\n      searchSource,\n    } = this.props;\n    trackAdvancedAnalyticsEvent('search.searched', {\n      organization,\n      query,\n      search_type: savedSearchType === 0 ? 'issues' : 'events',\n      search_source: searchSource,\n    });\n\n    callIfFunction(onSearch, query);\n\n    // Only save recent search query if we have a savedSearchType (also 0 is a valid value)\n    // Do not save empty string queries (i.e. if they clear search)\n    if (typeof savedSearchType === 'undefined' || !query) {\n      return;\n    }\n\n    try {\n      await saveRecentSearch(api, organization.slug, savedSearchType, query);\n\n      if (onSavedRecentSearch) {\n        onSavedRecentSearch(query);\n      }\n    } catch (err) {\n      // Silently capture errors if it fails to save\n      Sentry.captureException(err);\n    }\n  }\n\n  moveToNextToken = (\n    token: TokenResult<any> | undefined,\n    filterTokens: TokenResult<Token.Filter>[]\n  ) => {\n    let offset = this.state.query.length;\n\n    if (this.searchInput.current && filterTokens.length > 0) {\n      this.searchInput.current.focus();\n\n      if (token) {\n        const tokenIndex = filterTokens.findIndex(tok => tok === token);\n        if (typeof tokenIndex !== 'undefined') {\n          if (tokenIndex + 1 < filterTokens.length) {\n            offset = filterTokens[tokenIndex + 1].location.end.offset;\n          }\n        }\n      }\n\n      if (this.cursorPosition === this.state.query.length) {\n        offset = filterTokens[0].location.end.offset;\n      }\n\n      this.searchInput.current.selectionStart = offset;\n      this.searchInput.current.selectionEnd = offset;\n      this.updateAutoCompleteItems();\n    }\n  };\n\n  runQuickAction = (action: QuickAction) => {\n    const {query} = this.state;\n    const token = this.cursorToken ?? undefined;\n\n    const filterTokens = this.filterTokens;\n\n    const {actionType, canRunAction} = action;\n\n    if (!canRunAction || canRunAction(token, this.filterTokens.length)) {\n      switch (actionType) {\n        case QuickActionType.Delete: {\n          if (token && filterTokens.length > 0) {\n            const index = filterTokens.findIndex(tok => tok === token) ?? -1;\n\n            if (typeof document.execCommand === 'function' && this.searchInput.current) {\n              // Only use exec command if exists\n              this.searchInput.current.focus();\n\n              this.searchInput.current.selectionStart = token.location.start.offset;\n              this.searchInput.current.selectionEnd = token.location.end.offset + 1;\n\n              document.execCommand('insertText', false, '');\n            } else {\n              // Otherwise we fall back to the non-undo-able version\n              const newQuery =\n                // We trim to remove any remaining spaces\n                query.slice(0, token.location.start.offset).trim() +\n                (index > 0 && index < filterTokens.length - 1 ? ' ' : '') +\n                query.slice(token.location.end.offset).trim();\n              this.updateQuery(newQuery);\n            }\n          }\n\n          break;\n        }\n        case QuickActionType.Negate: {\n          if (token && token.type === Token.Filter) {\n            if (token.negated) {\n              if (\n                typeof document.execCommand === 'function' &&\n                this.searchInput.current\n              ) {\n                this.searchInput.current.focus();\n\n                this.searchInput.current.selectionStart = token.location.start.offset;\n                this.searchInput.current.selectionEnd = token.key.location.start.offset;\n\n                document.execCommand('insertText', false, '');\n              } else {\n                const newQuery =\n                  query.slice(0, token.location.start.offset) +\n                  query.slice(token.key.location.start.offset);\n                this.updateQuery(newQuery, this.cursorPosition - 1);\n              }\n            } else {\n              if (\n                typeof document.execCommand === 'function' &&\n                this.searchInput.current\n              ) {\n                this.searchInput.current.focus();\n\n                this.searchInput.current.selectionStart = token.location.start.offset;\n                this.searchInput.current.selectionEnd = token.location.start.offset;\n\n                document.execCommand('insertText', false, '!');\n              } else {\n                const newQuery =\n                  query.slice(0, token.key.location.start.offset) +\n                  '!' +\n                  query.slice(token.key.location.start.offset);\n                this.updateQuery(newQuery, this.cursorPosition + 1);\n              }\n            }\n          }\n          break;\n        }\n        case QuickActionType.Next: {\n          this.moveToNextToken(token, filterTokens);\n\n          break;\n        }\n        case QuickActionType.Previous: {\n          this.moveToNextToken(token, filterTokens.reverse());\n\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  };\n\n  onSubmit = (evt: React.FormEvent) => {\n    evt.preventDefault();\n    this.doSearch();\n  };\n\n  clearSearch = () =>\n    this.setState(makeQueryState(''), () =>\n      callIfFunction(this.props.onSearch, this.state.query)\n    );\n\n  onQueryFocus = () => this.setState({inputHasFocus: true});\n\n  onQueryBlur = (e: React.FocusEvent<HTMLTextAreaElement>) => {\n    // wait before closing dropdown in case blur was a result of clicking a\n    // menu option\n    const blurHandler = () => {\n      this.blurTimeout = undefined;\n      this.setState({inputHasFocus: false});\n      callIfFunction(this.props.onBlur, e.target.value);\n    };\n\n    window.clearTimeout(this.blurTimeout);\n    this.blurTimeout = window.setTimeout(blurHandler, DROPDOWN_BLUR_DURATION);\n  };\n\n  onQueryChange = (evt: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const query = evt.target.value.replace('\\n', '');\n\n    this.setState(makeQueryState(query), this.updateAutoCompleteItems);\n    callIfFunction(this.props.onChange, evt.target.value, evt);\n  };\n\n  /**\n   * Prevent pasting extra spaces from formatted text\n   */\n  onPaste = (evt: React.ClipboardEvent<HTMLTextAreaElement>) => {\n    // Cancel paste\n    evt.preventDefault();\n\n    // Get text representation of clipboard\n    const text = evt.clipboardData.getData('text/plain').replace('\\n', '').trim();\n\n    // Create new query\n    const currentQuery = this.state.query;\n    const cursorPosStart = this.searchInput.current!.selectionStart;\n    const cursorPosEnd = this.searchInput.current!.selectionEnd;\n    const textBefore = currentQuery.substring(0, cursorPosStart);\n    const textAfter = currentQuery.substring(cursorPosEnd, currentQuery.length);\n    const mergedText = `${textBefore}${text}${textAfter}`;\n\n    // Insert text manually\n    this.setState(makeQueryState(mergedText), () => {\n      this.updateAutoCompleteItems();\n      // Update cursor position after updating text\n      const newCursorPosition = cursorPosStart + text.length;\n      this.searchInput.current!.selectionStart = newCursorPosition;\n      this.searchInput.current!.selectionEnd = newCursorPosition;\n    });\n    callIfFunction(this.props.onChange, mergedText, evt);\n  };\n\n  onInputClick = () => this.updateAutoCompleteItems();\n\n  /**\n   * Handle keyboard navigation\n   */\n  onKeyDown = (evt: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    const {onKeyDown} = this.props;\n    const {key} = evt;\n\n    callIfFunction(onKeyDown, evt);\n\n    const hasSearchGroups = this.state.searchGroups.length > 0;\n    const isSelectingDropdownItems = this.state.activeSearchItem !== -1;\n\n    if ((key === 'ArrowDown' || key === 'ArrowUp') && hasSearchGroups) {\n      evt.preventDefault();\n\n      const {flatSearchItems, activeSearchItem} = this.state;\n      const searchGroups = [...this.state.searchGroups];\n\n      const [groupIndex, childrenIndex] = isSelectingDropdownItems\n        ? filterSearchGroupsByIndex(searchGroups, activeSearchItem)\n        : [];\n\n      // Remove the previous 'active' property\n      if (typeof groupIndex !== 'undefined') {\n        if (\n          childrenIndex !== undefined &&\n          searchGroups[groupIndex]?.children?.[childrenIndex]\n        ) {\n          delete searchGroups[groupIndex].children[childrenIndex].active;\n        }\n      }\n\n      const currIndex = isSelectingDropdownItems ? activeSearchItem : 0;\n      const totalItems = flatSearchItems.length;\n\n      // Move the selected index up/down\n      const nextActiveSearchItem =\n        key === 'ArrowUp'\n          ? (currIndex - 1 + totalItems) % totalItems\n          : isSelectingDropdownItems\n          ? (currIndex + 1) % totalItems\n          : 0;\n\n      const [nextGroupIndex, nextChildrenIndex] = filterSearchGroupsByIndex(\n        searchGroups,\n        nextActiveSearchItem\n      );\n\n      // Make sure search items exist (e.g. both groups could be empty) and\n      // attach the 'active' property to the item\n      if (\n        nextGroupIndex !== undefined &&\n        nextChildrenIndex !== undefined &&\n        searchGroups[nextGroupIndex]?.children\n      ) {\n        searchGroups[nextGroupIndex].children[nextChildrenIndex] = {\n          ...searchGroups[nextGroupIndex].children[nextChildrenIndex],\n          active: true,\n        };\n      }\n\n      this.setState({searchGroups, activeSearchItem: nextActiveSearchItem});\n    }\n\n    if (\n      (key === 'Tab' || key === 'Enter') &&\n      isSelectingDropdownItems &&\n      hasSearchGroups\n    ) {\n      evt.preventDefault();\n\n      const {activeSearchItem, searchGroups} = this.state;\n      const [groupIndex, childrenIndex] = filterSearchGroupsByIndex(\n        searchGroups,\n        activeSearchItem\n      );\n      const item =\n        groupIndex !== undefined &&\n        childrenIndex !== undefined &&\n        searchGroups[groupIndex].children[childrenIndex];\n\n      if (item) {\n        if (item.callback) {\n          item.callback();\n        } else {\n          this.onAutoComplete(item.value ?? '', item);\n        }\n      }\n      return;\n    }\n\n    if (key === 'Enter' && !isSelectingDropdownItems) {\n      this.doSearch();\n      return;\n    }\n\n    const cursorToken = this.cursorToken;\n    if (\n      key === '[' &&\n      cursorToken?.type === Token.Filter &&\n      cursorToken.value.text.length === 0 &&\n      isWithinToken(cursorToken.value, this.cursorPosition)\n    ) {\n      const {query} = this.state;\n      evt.preventDefault();\n      let clauseStart: null | number = null;\n      let clauseEnd: null | number = null;\n      // the new text that will exist between clauseStart and clauseEnd\n      const replaceToken = '[]';\n      const location = cursorToken.value.location;\n      const keyLocation = cursorToken.key.location;\n      // Include everything after the ':'\n      clauseStart = keyLocation.end.offset + 1;\n      clauseEnd = location.end.offset + 1;\n      const beforeClause = query.substring(0, clauseStart);\n      let endClause = query.substring(clauseEnd);\n      // Add space before next clause if it exists\n      if (endClause) {\n        endClause = ` ${endClause}`;\n      }\n      const newQuery = `${beforeClause}${replaceToken}${endClause}`;\n      // Place cursor between inserted brackets\n      this.updateQuery(newQuery, beforeClause.length + replaceToken.length - 1);\n      return;\n    }\n  };\n\n  onKeyUp = (evt: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (evt.key === 'ArrowLeft' || evt.key === 'ArrowRight') {\n      this.updateAutoCompleteItems();\n    }\n\n    // Other keys are managed at onKeyDown function\n    if (evt.key !== 'Escape') {\n      return;\n    }\n\n    evt.preventDefault();\n    const isSelectingDropdownItems = this.state.activeSearchItem > -1;\n\n    if (!isSelectingDropdownItems) {\n      this.blur();\n      return;\n    }\n\n    const {searchGroups, activeSearchItem} = this.state;\n    const [groupIndex, childrenIndex] = isSelectingDropdownItems\n      ? filterSearchGroupsByIndex(searchGroups, activeSearchItem)\n      : [];\n\n    if (groupIndex !== undefined && childrenIndex !== undefined) {\n      delete searchGroups[groupIndex].children[childrenIndex].active;\n    }\n\n    this.setState({\n      activeSearchItem: -1,\n      searchGroups: [...this.state.searchGroups],\n    });\n  };\n\n  /**\n   * Check if any filters are invalid within the search query\n   */\n  get hasValidSearch() {\n    const {parsedQuery} = this.state;\n\n    // If we fail to parse be optimistic that it's valid\n    if (parsedQuery === null) {\n      return true;\n    }\n\n    return treeResultLocator<boolean>({\n      tree: parsedQuery,\n      noResultValue: true,\n      visitorTest: ({token, returnResult, skipToken}) =>\n        token.type !== Token.Filter\n          ? null\n          : token.invalid\n          ? returnResult(false)\n          : skipToken,\n    });\n  }\n\n  /**\n   * Get the active filter or free text actively focused.\n   */\n  get cursorToken() {\n    const matchedTokens = [Token.Filter, Token.FreeText] as const;\n    return this.findTokensAtCursor(matchedTokens);\n  }\n\n  /**\n   * Get the active parsed text value\n   */\n  get cursorValue() {\n    const matchedTokens = [Token.ValueText] as const;\n    return this.findTokensAtCursor(matchedTokens);\n  }\n\n  /**\n   * Get the current cursor position within the input\n   */\n  get cursorPosition() {\n    if (!this.searchInput.current) {\n      return -1;\n    }\n\n    // No cursor position when the input loses focus. This is important for\n    // updating the search highlighters active state\n    if (!this.state.inputHasFocus) {\n      return -1;\n    }\n\n    return this.searchInput.current.selectionStart ?? -1;\n  }\n\n  get filterTokens(): TokenResult<Token.Filter>[] {\n    return (this.state.parsedQuery?.filter(tok => tok.type === Token.Filter) ??\n      []) as TokenResult<Token.Filter>[];\n  }\n\n  /**\n   * Finds tokens that exist at the current cursor position\n   * @param matchedTokens acceptable list of tokens\n   */\n  findTokensAtCursor<T extends readonly Token[]>(matchedTokens: T) {\n    const {parsedQuery} = this.state;\n\n    if (parsedQuery === null) {\n      return null;\n    }\n\n    const cursor = this.cursorPosition;\n\n    return treeResultLocator<TokenResult<T[number]> | null>({\n      tree: parsedQuery,\n      noResultValue: null,\n      visitorTest: ({token, returnResult, skipToken}) =>\n        !matchedTokens.includes(token.type)\n          ? null\n          : isWithinToken(token, cursor)\n          ? returnResult(token)\n          : skipToken,\n    });\n  }\n\n  /**\n   * Returns array of possible key values that substring match `query`\n   */\n  getTagKeys(query: string): [SearchItem[], ItemType] {\n    const {prepareQuery, supportedTagType, getFieldDoc} = this.props;\n\n    const supportedTags = this.props.supportedTags ?? {};\n\n    // Return all if query is empty\n    let tagKeys = Object.keys(supportedTags).map(key => `${key}:`);\n\n    if (query) {\n      const preparedQuery =\n        typeof prepareQuery === 'function' ? prepareQuery(query) : query;\n      tagKeys = tagKeys.filter(key => key.indexOf(preparedQuery) > -1);\n    }\n\n    // If the environment feature is active and excludeEnvironment = true\n    // then remove the environment key\n    if (this.props.excludeEnvironment) {\n      tagKeys = tagKeys.filter(key => key !== 'environment:');\n    }\n\n    return [\n      tagKeys\n        .map(value => ({\n          value,\n          desc: value,\n          documentation: getFieldDoc?.(value.slice(0, -1)) ?? '',\n        }))\n        .sort((a, b) => a.value.localeCompare(b.value)),\n      supportedTagType ?? ItemType.TAG_KEY,\n    ];\n  }\n\n  /**\n   * Returns array of tag values that substring match `query`; invokes `callback`\n   * with data when ready\n   */\n  getTagValues = debounce(\n    async (tag: Tag, query: string) => {\n      // Strip double quotes if there are any\n      query = query.replace(/\"/g, '').trim();\n\n      if (!this.props.onGetTagValues) {\n        return [];\n      }\n\n      if (\n        this.state.noValueQuery !== undefined &&\n        query.startsWith(this.state.noValueQuery)\n      ) {\n        return [];\n      }\n\n      const {location} = this.props;\n      const endpointParams = normalizeDateTimeParams(location.query);\n\n      this.setState({loading: true});\n      let values: string[] = [];\n\n      try {\n        values = await this.props.onGetTagValues(tag, query, endpointParams);\n        this.setState({loading: false});\n      } catch (err) {\n        this.setState({loading: false});\n        Sentry.captureException(err);\n        return [];\n      }\n\n      if (tag.key === 'release:' && !values.includes('latest')) {\n        values.unshift('latest');\n      }\n\n      const noValueQuery = values.length === 0 && query.length > 0 ? query : undefined;\n      this.setState({noValueQuery});\n\n      return values.map(value => {\n        const escapedValue = escapeValue(value);\n        return {\n          value: escapedValue,\n          desc: escapedValue,\n          type: ItemType.TAG_VALUE,\n        };\n      });\n    },\n    DEFAULT_DEBOUNCE_DURATION,\n    {leading: true}\n  );\n\n  /**\n   * Returns array of tag values that substring match `query`; invokes `callback`\n   * with results\n   */\n  getPredefinedTagValues = (tag: Tag, query: string): SearchItem[] =>\n    (tag.values ?? [])\n      .filter(value => value.indexOf(query) > -1)\n      .map((value, i) => {\n        const escapedValue = escapeValue(value);\n        return {\n          value: escapedValue,\n          desc: escapedValue,\n          type: ItemType.TAG_VALUE,\n          ignoreMaxSearchItems: tag.maxSuggestedValues\n            ? i < tag.maxSuggestedValues\n            : false,\n        };\n      });\n\n  /**\n   * Get recent searches\n   */\n  getRecentSearches = debounce(\n    async () => {\n      const {savedSearchType, hasRecentSearches, onGetRecentSearches} = this.props;\n\n      // `savedSearchType` can be 0\n      if (!defined(savedSearchType) || !hasRecentSearches) {\n        return [];\n      }\n\n      const fetchFn = onGetRecentSearches || this.fetchRecentSearches;\n      return await fetchFn(this.state.query);\n    },\n    DEFAULT_DEBOUNCE_DURATION,\n    {leading: true}\n  );\n\n  fetchRecentSearches = async (fullQuery: string): Promise<SearchItem[]> => {\n    const {api, organization, savedSearchType} = this.props;\n    if (savedSearchType === undefined) {\n      return [];\n    }\n\n    try {\n      const recentSearches: any[] = await fetchRecentSearches(\n        api,\n        organization.slug,\n        savedSearchType,\n        fullQuery\n      );\n\n      // If `recentSearches` is undefined or not an array, the function will\n      // return an array anyway\n      return recentSearches.map(searches => ({\n        desc: searches.query,\n        value: searches.query,\n        type: ItemType.RECENT_SEARCH,\n      }));\n    } catch (e) {\n      Sentry.captureException(e);\n    }\n\n    return [];\n  };\n\n  getReleases = debounce(\n    async (tag: Tag, query: string) => {\n      const releasePromise = this.fetchReleases(query);\n\n      const tags = this.getPredefinedTagValues(tag, query);\n      const tagValues = tags.map<SearchItem>(v => ({\n        ...v,\n        type: ItemType.FIRST_RELEASE,\n      }));\n\n      const releases = await releasePromise;\n      const releaseValues = releases.map<SearchItem>((r: any) => ({\n        value: r.shortVersion,\n        desc: r.shortVersion,\n        type: ItemType.FIRST_RELEASE,\n      }));\n\n      return [...tagValues, ...releaseValues];\n    },\n    DEFAULT_DEBOUNCE_DURATION,\n    {leading: true}\n  );\n\n  /**\n   * Fetches latest releases from a organization/project. Returns an empty array\n   * if an error is encountered.\n   */\n  fetchReleases = async (releaseVersion: string): Promise<any[]> => {\n    const {api, location, organization} = this.props;\n\n    const project = location && location.query ? location.query.projectId : undefined;\n\n    const url = `/organizations/${organization.slug}/releases/`;\n    const fetchQuery: {[key: string]: string | number} = {\n      per_page: MAX_AUTOCOMPLETE_RELEASES,\n    };\n\n    if (releaseVersion) {\n      fetchQuery.query = releaseVersion;\n    }\n\n    if (project) {\n      fetchQuery.project = project;\n    }\n\n    try {\n      return await api.requestPromise(url, {\n        method: 'GET',\n        query: fetchQuery,\n      });\n    } catch (e) {\n      addErrorMessage(t('Unable to fetch releases'));\n      Sentry.captureException(e);\n    }\n\n    return [];\n  };\n\n  async generateTagAutocompleteGroup(tagName: string): Promise<AutocompleteGroup> {\n    const [tagKeys, tagType] = this.getTagKeys(tagName);\n    const recentSearches = await this.getRecentSearches();\n\n    return {\n      searchItems: tagKeys,\n      recentSearchItems: recentSearches ?? [],\n      tagName,\n      type: tagType,\n    };\n  }\n\n  generateValueAutocompleteGroup = async (\n    tagName: string,\n    query: string\n  ): Promise<AutocompleteGroup | null> => {\n    const {prepareQuery, excludeEnvironment} = this.props;\n    const supportedTags = this.props.supportedTags ?? {};\n\n    const preparedQuery =\n      typeof prepareQuery === 'function' ? prepareQuery(query) : query;\n\n    // filter existing items immediately, until API can return\n    // with actual tag value results\n    const filteredSearchGroups = !preparedQuery\n      ? this.state.searchGroups\n      : this.state.searchGroups.filter(\n          item => item.value && item.value.indexOf(preparedQuery) !== -1\n        );\n\n    this.setState({\n      searchTerm: query,\n      searchGroups: filteredSearchGroups,\n    });\n\n    const tag = supportedTags[tagName];\n\n    if (!tag) {\n      return {\n        searchItems: [],\n        recentSearchItems: [],\n        tagName,\n        type: ItemType.INVALID_TAG,\n      };\n    }\n\n    // Ignore the environment tag if the feature is active and\n    // excludeEnvironment = true\n    if (excludeEnvironment && tagName === 'environment') {\n      return null;\n    }\n\n    const fetchTagValuesFn =\n      tag.key === 'firstRelease'\n        ? this.getReleases\n        : tag.predefined\n        ? this.getPredefinedTagValues\n        : this.getTagValues;\n\n    const [tagValues, recentSearches] = await Promise.all([\n      fetchTagValuesFn(tag, preparedQuery),\n      this.getRecentSearches(),\n    ]);\n\n    return {\n      searchItems: tagValues ?? [],\n      recentSearchItems: recentSearches ?? [],\n      tagName: tag.key,\n      type: ItemType.TAG_VALUE,\n    };\n  };\n\n  showDefaultSearches = async () => {\n    const {query} = this.state;\n    const [defaultSearchItems, defaultRecentItems] = this.props.defaultSearchItems!;\n\n    if (!defaultSearchItems.length) {\n      // Update searchTerm, otherwise <SearchDropdown> will have wrong state\n      // (e.g. if you delete a query, the last letter will be highlighted if `searchTerm`\n      // does not get updated)\n      this.setState({searchTerm: query});\n\n      const [tagKeys, tagType] = this.getTagKeys('');\n      const recentSearches = await this.getRecentSearches();\n\n      this.updateAutoCompleteState(tagKeys, recentSearches ?? [], '', tagType);\n      return;\n    }\n    // cursor on whitespace show default \"help\" search terms\n    this.setState({searchTerm: ''});\n\n    this.updateAutoCompleteState(\n      defaultSearchItems,\n      defaultRecentItems,\n      '',\n      ItemType.DEFAULT\n    );\n    return;\n  };\n\n  updateAutoCompleteFromAst = async () => {\n    const cursor = this.cursorPosition;\n    const cursorToken = this.cursorToken;\n\n    if (!cursorToken) {\n      this.showDefaultSearches();\n      return;\n    }\n\n    if (cursorToken.type === Token.Filter) {\n      const tagName = getKeyName(cursorToken.key, {aggregateWithArgs: true});\n      // check if we are on the tag, value, or operator\n      if (isWithinToken(cursorToken.value, cursor)) {\n        const node = cursorToken.value;\n        const cursorValue = this.cursorValue;\n        let searchText = cursorValue?.text ?? node.text;\n        if (searchText === '[]' || cursorValue === null) {\n          searchText = '';\n        }\n\n        const valueGroup = await this.generateValueAutocompleteGroup(tagName, searchText);\n        const autocompleteGroups = valueGroup ? [valueGroup] : [];\n        // show operator group if at beginning of value\n        if (cursor === node.location.start.offset) {\n          const opGroup = generateOpAutocompleteGroup(getValidOps(cursorToken), tagName);\n          autocompleteGroups.unshift(opGroup);\n        }\n        this.updateAutoCompleteStateMultiHeader(autocompleteGroups);\n        return;\n      }\n\n      if (isWithinToken(cursorToken.key, cursor)) {\n        const node = cursorToken.key;\n        const autocompleteGroups = [await this.generateTagAutocompleteGroup(tagName)];\n        // show operator group if at end of key\n        if (cursor === node.location.end.offset) {\n          const opGroup = generateOpAutocompleteGroup(getValidOps(cursorToken), tagName);\n          autocompleteGroups.unshift(opGroup);\n        }\n        this.setState({searchTerm: tagName});\n        this.updateAutoCompleteStateMultiHeader(autocompleteGroups);\n        return;\n      }\n\n      // show operator autocomplete group\n      const opGroup = generateOpAutocompleteGroup(getValidOps(cursorToken), tagName);\n      this.updateAutoCompleteStateMultiHeader([opGroup]);\n      return;\n    }\n\n    if (cursorToken.type === Token.FreeText) {\n      const lastToken = cursorToken.text.trim().split(' ').pop() ?? '';\n      const keyText = lastToken.replace(new RegExp(`^${NEGATION_OPERATOR}`), '');\n      const autocompleteGroups = [await this.generateTagAutocompleteGroup(keyText)];\n      this.setState({searchTerm: keyText});\n      this.updateAutoCompleteStateMultiHeader(autocompleteGroups);\n      return;\n    }\n  };\n\n  updateAutoCompleteItems = () => {\n    window.clearTimeout(this.blurTimeout);\n    this.blurTimeout = undefined;\n\n    this.updateAutoCompleteFromAst();\n  };\n\n  /**\n   * Updates autocomplete dropdown items and autocomplete index state\n   *\n   * @param searchItems List of search item objects with keys: title, desc, value\n   * @param recentSearchItems List of recent search items, same format as searchItem\n   * @param tagName The current tag name in scope\n   * @param type Defines the type/state of the dropdown menu items\n   */\n  updateAutoCompleteState(\n    searchItems: SearchItem[],\n    recentSearchItems: SearchItem[],\n    tagName: string,\n    type: ItemType\n  ) {\n    const {hasRecentSearches, maxSearchItems, maxQueryLength} = this.props;\n    const {query} = this.state;\n\n    const queryCharsLeft =\n      maxQueryLength && query ? maxQueryLength - query.length : undefined;\n\n    const searchGroups = createSearchGroups(\n      searchItems,\n      hasRecentSearches ? recentSearchItems : undefined,\n      tagName,\n      type,\n      maxSearchItems,\n      queryCharsLeft\n    );\n\n    this.setState(searchGroups);\n  }\n\n  /**\n   * Updates autocomplete dropdown items and autocomplete index state\n   *\n   * @param groups Groups that will be used to populate the autocomplete dropdown\n   */\n  updateAutoCompleteStateMultiHeader = (groups: AutocompleteGroup[]) => {\n    const {hasRecentSearches, maxSearchItems, maxQueryLength} = this.props;\n    const {query} = this.state;\n    const queryCharsLeft =\n      maxQueryLength && query ? maxQueryLength - query.length : undefined;\n\n    const searchGroups = groups\n      .map(({searchItems, recentSearchItems, tagName, type}) =>\n        createSearchGroups(\n          searchItems,\n          hasRecentSearches ? recentSearchItems : undefined,\n          tagName,\n          type,\n          maxSearchItems,\n          queryCharsLeft\n        )\n      )\n      .reduce(\n        (acc, item) => ({\n          searchGroups: [...acc.searchGroups, ...item.searchGroups],\n          flatSearchItems: [...acc.flatSearchItems, ...item.flatSearchItems],\n          activeSearchItem: -1,\n        }),\n        {\n          searchGroups: [] as SearchGroup[],\n          flatSearchItems: [] as SearchItem[],\n          activeSearchItem: -1,\n        }\n      );\n\n    this.setState(searchGroups);\n  };\n\n  updateQuery = (newQuery: string, cursorPosition?: number) =>\n    this.setState(makeQueryState(newQuery), () => {\n      // setting a new input value will lose focus; restore it\n      if (this.searchInput.current) {\n        this.searchInput.current.focus();\n        if (cursorPosition) {\n          this.searchInput.current.selectionStart = cursorPosition;\n          this.searchInput.current.selectionEnd = cursorPosition;\n        }\n      }\n      // then update the autocomplete box with new items\n      this.updateAutoCompleteItems();\n      this.props.onChange?.(newQuery, new MouseEvent('click') as any);\n    });\n\n  onAutoCompleteFromAst = (replaceText: string, item: SearchItem) => {\n    const cursor = this.cursorPosition;\n    const {query} = this.state;\n\n    const cursorToken = this.cursorToken;\n\n    if (!cursorToken) {\n      this.updateQuery(`${query}${replaceText}`);\n      return;\n    }\n\n    // the start and end of what to replace\n    let clauseStart: null | number = null;\n    let clauseEnd: null | number = null;\n    // the new text that will exist between clauseStart and clauseEnd\n    let replaceToken = replaceText;\n    if (cursorToken.type === Token.Filter) {\n      if (item.type === ItemType.TAG_OPERATOR) {\n        trackAdvancedAnalyticsEvent('search.operator_autocompleted', {\n          organization: this.props.organization,\n          query: removeSpace(query),\n          search_operator: replaceText,\n          search_type: this.props.savedSearchType === 0 ? 'issues' : 'events',\n        });\n        const valueLocation = cursorToken.value.location;\n        clauseStart = cursorToken.location.start.offset;\n        clauseEnd = valueLocation.start.offset;\n        if (replaceText === '!:') {\n          replaceToken = `!${cursorToken.key.text}:`;\n        } else {\n          replaceToken = `${cursorToken.key.text}${replaceText}`;\n        }\n      } else if (isWithinToken(cursorToken.value, cursor)) {\n        const valueToken = this.cursorValue ?? cursorToken.value;\n        const location = valueToken.location;\n\n        if (cursorToken.filter === FilterType.TextIn) {\n          // Current value can be null when adding a 2nd value\n          //             ▼ cursor\n          // key:[value1, ]\n          const currentValueNull = this.cursorValue === null;\n          clauseStart = currentValueNull\n            ? this.cursorPosition\n            : valueToken.location.start.offset;\n          clauseEnd = currentValueNull\n            ? this.cursorPosition\n            : valueToken.location.end.offset;\n        } else {\n          const keyLocation = cursorToken.key.location;\n          clauseStart = keyLocation.end.offset + 1;\n          clauseEnd = location.end.offset + 1;\n          // The user tag often contains : within its value and we need to quote it.\n          if (getKeyName(cursorToken.key) === 'user') {\n            replaceToken = `\"${replaceText.trim()}\"`;\n          }\n          // handle using autocomplete with key:[]\n          if (valueToken.text === '[]') {\n            clauseStart += 1;\n            clauseEnd -= 2;\n          } else {\n            replaceToken += ' ';\n          }\n        }\n      } else if (isWithinToken(cursorToken.key, cursor)) {\n        const location = cursorToken.key.location;\n        clauseStart = location.start.offset;\n        // If the token is a key, then trim off the end to avoid duplicate ':'\n        clauseEnd = location.end.offset + 1;\n      }\n    }\n\n    if (cursorToken.type === Token.FreeText) {\n      const startPos = cursorToken.location.start.offset;\n      clauseStart = cursorToken.text.startsWith(NEGATION_OPERATOR)\n        ? startPos + 1\n        : startPos;\n      clauseEnd = cursorToken.location.end.offset;\n    }\n\n    if (clauseStart !== null && clauseEnd !== null) {\n      const beforeClause = query.substring(0, clauseStart);\n      const endClause = query.substring(clauseEnd);\n      const newQuery = `${beforeClause}${replaceToken}${endClause}`;\n      this.updateQuery(newQuery, beforeClause.length + replaceToken.length);\n    }\n  };\n\n  onAutoComplete = (replaceText: string, item: SearchItem) => {\n    if (item.type === ItemType.RECENT_SEARCH) {\n      trackAdvancedAnalyticsEvent('search.searched', {\n        organization: this.props.organization,\n        query: replaceText,\n        search_type: this.props.savedSearchType === 0 ? 'issues' : 'events',\n        search_source: 'recent_search',\n      });\n\n      this.setState(makeQueryState(replaceText), () => {\n        // Propagate onSearch and save to recent searches\n        this.doSearch();\n      });\n\n      return;\n    }\n\n    this.onAutoCompleteFromAst(replaceText, item);\n  };\n\n  render() {\n    const {\n      api,\n      className,\n      savedSearchType,\n      dropdownClassName,\n      actionBarItems,\n      organization,\n      placeholder,\n      disabled,\n      useFormWrapper,\n      inlineLabel,\n      maxQueryLength,\n      maxMenuHeight,\n    } = this.props;\n\n    const {\n      query,\n      parsedQuery,\n      searchGroups,\n      searchTerm,\n      inputHasFocus,\n      numActionsVisible,\n      loading,\n    } = this.state;\n\n    const input = (\n      <SearchInput\n        type=\"text\"\n        placeholder={placeholder}\n        id=\"smart-search-input\"\n        data-test-id=\"smart-search-input\"\n        name=\"query\"\n        ref={this.searchInput}\n        autoComplete=\"off\"\n        value={query}\n        onFocus={this.onQueryFocus}\n        onBlur={this.onQueryBlur}\n        onKeyUp={this.onKeyUp}\n        onKeyDown={this.onKeyDown}\n        onChange={this.onQueryChange}\n        onClick={this.onInputClick}\n        onPaste={this.onPaste}\n        disabled={disabled}\n        maxLength={maxQueryLength}\n        spellCheck={false}\n      />\n    );\n\n    // Segment actions into visible and overflowed groups\n    const actionItems = actionBarItems ?? [];\n    const actionProps = {\n      api,\n      organization,\n      query,\n      savedSearchType,\n    };\n\n    const visibleActions = actionItems\n      .slice(0, numActionsVisible)\n      .map(({key, Action}) => <Action key={key} {...actionProps} />);\n\n    const overflowedActions = actionItems\n      .slice(numActionsVisible)\n      .map(({key, Action}) => <Action key={key} {...actionProps} menuItemVariant />);\n\n    const cursor = this.cursorPosition;\n\n    return (\n      <Container\n        ref={this.containerRef}\n        className={className}\n        inputHasFocus={inputHasFocus}\n      >\n        <SearchHotkeysListener runQuickAction={this.runQuickAction} />\n        <SearchLabel htmlFor=\"smart-search-input\" aria-label={t('Search events')}>\n          <IconSearch />\n          {inlineLabel}\n        </SearchLabel>\n\n        <InputWrapper>\n          <Highlight>\n            {parsedQuery !== null ? (\n              <HighlightQuery\n                parsedQuery={parsedQuery}\n                cursorPosition={cursor === -1 ? undefined : cursor}\n              />\n            ) : (\n              query\n            )}\n          </Highlight>\n          {useFormWrapper ? <form onSubmit={this.onSubmit}>{input}</form> : input}\n        </InputWrapper>\n\n        <ActionsBar gap={0.5}>\n          {query !== '' && (\n            <ActionButton\n              onClick={this.clearSearch}\n              icon={<IconClose size=\"xs\" />}\n              title={t('Clear search')}\n              aria-label={t('Clear search')}\n            />\n          )}\n          {visibleActions}\n          {overflowedActions.length > 0 && (\n            <DropdownLink\n              anchorRight\n              caret={false}\n              title={\n                <ActionButton\n                  aria-label={t('Show more')}\n                  icon={<VerticalEllipsisIcon size=\"xs\" />}\n                />\n              }\n            >\n              {overflowedActions}\n            </DropdownLink>\n          )}\n        </ActionsBar>\n\n        {(loading || searchGroups.length > 0) && (\n          <SearchDropdown\n            css={{display: inputHasFocus ? 'block' : 'none'}}\n            className={dropdownClassName}\n            items={searchGroups}\n            onClick={this.onAutoComplete}\n            loading={loading}\n            searchSubstring={searchTerm}\n            runQuickAction={this.runQuickAction}\n            visibleActions={quickActions.filter(\n              action =>\n                action.hotkeys &&\n                (!action.canRunAction ||\n                  action.canRunAction(this.cursorToken, this.filterTokens.length))\n            )}\n            maxMenuHeight={maxMenuHeight}\n          />\n        )}\n      </Container>\n    );\n  }\n}\n\ntype ContainerState = {\n  members: ReturnType<typeof MemberListStore.getAll>;\n};\n\nclass SmartSearchBarContainer extends Component<Props, ContainerState> {\n  state: ContainerState = {\n    members: MemberListStore.getAll(),\n  };\n\n  componentWillUnmount() {\n    this.unsubscribe();\n  }\n\n  unsubscribe = MemberListStore.listen(\n    (members: ContainerState['members']) => this.setState({members}),\n    undefined\n  );\n\n  render() {\n    // SmartSearchBar doesn't use members, but we forward it to cause a re-render.\n    return <SmartSearchBar {...this.props} members={this.state.members} />;\n  }\n}\n\nexport default withApi(withRouter(withOrganization(SmartSearchBarContainer)));\n\nexport {SmartSearchBar, Props as SmartSearchBarProps};\n\nconst Container = styled('div')<{inputHasFocus: boolean}>`\n  border: 1px solid ${p => p.theme.border};\n  box-shadow: inset ${p => p.theme.dropShadowLight};\n  background: ${p => p.theme.background};\n  padding: 7px ${space(1)};\n  position: relative;\n  display: grid;\n  grid-template-columns: max-content 1fr max-content;\n  gap: ${space(1)};\n  align-items: start;\n\n  border-radius: ${p => p.theme.borderRadius};\n\n  .show-sidebar & {\n    background: ${p => p.theme.backgroundSecondary};\n  }\n\n  ${p =>\n    p.inputHasFocus &&\n    `\n    border-color: ${p.theme.focusBorder};\n    box-shadow: 0 0 0 1px ${p.theme.focusBorder};\n  `}\n`;\n\nconst SearchLabel = styled('label')`\n  display: flex;\n  padding: ${space(0.5)} 0;\n  margin: 0;\n  color: ${p => p.theme.gray300};\n`;\n\nconst InputWrapper = styled('div')`\n  position: relative;\n`;\n\nconst Highlight = styled('div')`\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  user-select: none;\n  white-space: pre-wrap;\n  word-break: break-word;\n  line-height: 25px;\n  font-size: ${p => p.theme.fontSizeSmall};\n  font-family: ${p => p.theme.text.familyMono};\n`;\n\nconst SearchInput = styled(\n  getDynamicComponent<typeof TextareaAutosize>({\n    value: TextareaAutosize,\n    fixed: 'textarea',\n  }),\n  {\n    shouldForwardProp: prop => typeof prop === 'string' && isPropValid(prop),\n  }\n)`\n  position: relative;\n  display: flex;\n  resize: none;\n  outline: none;\n  border: 0;\n  width: 100%;\n  padding: 0;\n  line-height: 25px;\n  margin-bottom: -1px;\n  background: transparent;\n  font-size: ${p => p.theme.fontSizeSmall};\n  font-family: ${p => p.theme.text.familyMono};\n  caret-color: ${p => p.theme.subText};\n  color: transparent;\n\n  &::selection {\n    background: rgba(0, 0, 0, 0.2);\n  }\n  &::placeholder {\n    color: ${p => p.theme.formPlaceholder};\n  }\n\n  [disabled] {\n    color: ${p => p.theme.disabled};\n  }\n`;\n\nconst ActionsBar = styled(ButtonBar)`\n  height: ${space(2)};\n  margin: ${space(0.5)} 0;\n`;\n\nconst VerticalEllipsisIcon = styled(IconEllipsis)`\n  transform: rotate(90deg);\n`;\n","import {FunctionComponent} from 'react';\n\n/**\n * Returns a replacement component, this function is mocked in tests and will use the second argument.\n * (This only happens during tests)\n */\nexport default function getDynamicComponent<Original extends FunctionComponent>({\n  value,\n}: {\n  fixed: 'textarea';\n  value: Original;\n}): Original {\n  // Overridden with fixed in tests.\n  return value;\n}\n","import {Fragment, PureComponent} from 'react';\nimport styled from '@emotion/styled';\nimport color from 'color';\n\nimport LoadingIndicator from 'sentry/components/loadingIndicator';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\n\nimport Button from '../button';\nimport HotkeysLabel from '../hotkeysLabel';\n\nimport {ItemType, QuickAction, SearchGroup, SearchItem} from './types';\n\ntype Props = {\n  items: SearchGroup[];\n  loading: boolean;\n  onClick: (value: string, item: SearchItem) => void;\n  searchSubstring: string;\n  className?: string;\n  maxMenuHeight?: number;\n  runQuickAction?: (action: QuickAction) => void;\n  visibleActions?: QuickAction[];\n};\n\nclass SearchDropdown extends PureComponent<Props> {\n  static defaultProps = {\n    searchSubstring: '',\n    onClick: function () {},\n  };\n\n  renderDescription = (item: SearchItem) => {\n    const searchSubstring = this.props.searchSubstring;\n    if (!searchSubstring) {\n      return item.desc;\n    }\n\n    const text = item.desc;\n\n    if (!text) {\n      return null;\n    }\n\n    const idx = text.toLowerCase().indexOf(searchSubstring.toLowerCase());\n\n    if (idx === -1) {\n      return item.desc;\n    }\n\n    return (\n      <span>\n        {text.substr(0, idx)}\n        <strong>{text.substr(idx, searchSubstring.length)}</strong>\n        {text.substr(idx + searchSubstring.length)}\n      </span>\n    );\n  };\n\n  renderHeaderItem = (item: SearchGroup) => (\n    <SearchDropdownGroup key={item.title}>\n      <SearchDropdownGroupTitle>\n        {item.icon}\n        {item.title && item.title}\n        {item.desc && <span>{item.desc}</span>}\n      </SearchDropdownGroupTitle>\n    </SearchDropdownGroup>\n  );\n\n  renderItem = (item: SearchItem) => (\n    <SearchListItem\n      key={item.value || item.desc || item.title}\n      className={item.active ? 'active' : undefined}\n      data-test-id=\"search-autocomplete-item\"\n      onClick={item.callback ?? this.props.onClick.bind(this, item.value, item)}\n      ref={element => item.active && element?.scrollIntoView?.({block: 'nearest'})}\n    >\n      <SearchItemTitleWrapper>\n        {item.title && item.title + (item.desc ? ' · ' : '')}\n        <Description>{this.renderDescription(item)}</Description>\n        <Documentation>{item.documentation}</Documentation>\n      </SearchItemTitleWrapper>\n    </SearchListItem>\n  );\n\n  render() {\n    const {className, loading, items, runQuickAction, visibleActions, maxMenuHeight} =\n      this.props;\n    return (\n      <StyledSearchDropdown className={className}>\n        {loading ? (\n          <LoadingWrapper key=\"loading\" data-test-id=\"search-autocomplete-loading\">\n            <LoadingIndicator mini />\n          </LoadingWrapper>\n        ) : (\n          <SearchItemsList maxMenuHeight={maxMenuHeight}>\n            {items.map(item => {\n              const isEmpty = item.children && !item.children.length;\n              const invalidTag = item.type === ItemType.INVALID_TAG;\n\n              // Hide header if `item.children` is defined, an array, and is empty\n              return (\n                <Fragment key={item.title}>\n                  {invalidTag && <Info>{t('Invalid tag')}</Info>}\n                  {item.type === 'header' && this.renderHeaderItem(item)}\n                  {item.children && item.children.map(this.renderItem)}\n                  {isEmpty && !invalidTag && <Info>{t('No items found')}</Info>}\n                </Fragment>\n              );\n            })}\n          </SearchItemsList>\n        )}\n        <DropdownFooter>\n          <ActionsRow>\n            {runQuickAction &&\n              visibleActions?.map(action => {\n                return (\n                  <ActionButtonContainer\n                    key={action.text}\n                    onClick={() => runQuickAction(action)}\n                  >\n                    <HotkeyGlyphWrapper>\n                      <HotkeysLabel value={action.hotkeys?.display ?? []} />\n                    </HotkeyGlyphWrapper>\n                    <HotkeyTitle>{action.text}</HotkeyTitle>\n                  </ActionButtonContainer>\n                );\n              })}\n          </ActionsRow>\n          <Button\n            size=\"xsmall\"\n            href=\"https://docs.sentry.io/product/sentry-basics/search/\"\n          >\n            Read the docs\n          </Button>\n        </DropdownFooter>\n      </StyledSearchDropdown>\n    );\n  }\n}\n\nexport default SearchDropdown;\n\nconst StyledSearchDropdown = styled('div')`\n  /* Container has a border that we need to account for */\n  position: absolute;\n  top: 100%;\n  left: -1px;\n  right: -1px;\n  z-index: ${p => p.theme.zIndex.dropdown};\n  overflow: hidden;\n  margin-top: ${space(1)};\n  background: ${p => p.theme.background};\n  box-shadow: ${p => p.theme.dropShadowHeavy};\n  border: 1px solid ${p => p.theme.border};\n  border-radius: ${p => p.theme.borderRadius};\n`;\n\nconst LoadingWrapper = styled('div')`\n  display: flex;\n  justify-content: center;\n  padding: ${space(1)};\n`;\n\nconst Info = styled('div')`\n  display: flex;\n  padding: ${space(1)} ${space(2)};\n  font-size: ${p => p.theme.fontSizeLarge};\n  color: ${p => p.theme.gray300};\n\n  &:not(:last-child) {\n    border-bottom: 1px solid ${p => p.theme.innerBorder};\n  }\n`;\n\nconst ListItem = styled('li')`\n  &:not(:last-child) {\n    border-bottom: 1px solid ${p => p.theme.innerBorder};\n  }\n`;\n\nconst SearchDropdownGroup = styled(ListItem)``;\n\nconst SearchDropdownGroupTitle = styled('header')`\n  display: flex;\n  align-items: center;\n\n  background-color: ${p => p.theme.backgroundSecondary};\n  color: ${p => p.theme.gray300};\n  font-weight: normal;\n  font-size: ${p => p.theme.fontSizeMedium};\n\n  margin: 0;\n  padding: ${space(1)} ${space(2)};\n\n  & > svg {\n    margin-right: ${space(1)};\n  }\n`;\n\nconst SearchItemsList = styled('ul')<{maxMenuHeight?: number}>`\n  padding-left: 0;\n  list-style: none;\n  margin-bottom: 0;\n  ${p => {\n    if (p.maxMenuHeight !== undefined) {\n      return `\n        max-height: ${p.maxMenuHeight}px;\n        overflow-y: scroll;\n      `;\n    }\n\n    return `\n      height: auto;\n    `;\n  }}\n`;\n\nconst SearchListItem = styled(ListItem)`\n  scroll-margin: 40px 0;\n  font-size: ${p => p.theme.fontSizeLarge};\n  padding: ${space(1)} ${space(2)};\n  cursor: pointer;\n\n  &:hover,\n  &.active {\n    background: ${p => p.theme.hover};\n  }\n`;\n\nconst SearchItemTitleWrapper = styled('div')`\n  color: ${p => p.theme.textColor};\n  font-weight: normal;\n  font-size: ${p => p.theme.fontSizeMedium};\n  margin: 0;\n  line-height: ${p => p.theme.text.lineHeightHeading};\n  ${p => p.theme.overflowEllipsis};\n`;\n\nconst Description = styled('span')`\n  font-size: ${p => p.theme.fontSizeSmall};\n  font-family: ${p => p.theme.text.familyMono};\n`;\n\nconst Documentation = styled('span')`\n  font-size: ${p => p.theme.fontSizeSmall};\n  font-family: ${p => p.theme.text.familyMono};\n  float: right;\n  color: ${p => p.theme.gray300};\n`;\n\nconst DropdownFooter = styled(`div`)`\n  width: 100%;\n  min-height: 45px;\n  background-color: ${p => p.theme.backgroundSecondary};\n  border-top: 1px solid ${p => p.theme.innerBorder};\n  flex-direction: row;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: ${space(1)};\n  flex-wrap: wrap;\n`;\n\nconst ActionsRow = styled('div')`\n  flex-direction: row;\n  display: flex;\n  align-items: center;\n`;\n\nconst ActionButtonContainer = styled('div')`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  height: auto;\n  padding: 0 ${space(1.5)};\n\n  cursor: pointer;\n\n  :hover {\n    border-radius: ${p => p.theme.borderRadius};\n    background-color: ${p => color(p.theme.hover).darken(0.02).string()};\n  }\n`;\n\nconst HotkeyGlyphWrapper = styled('span')`\n  color: ${p => p.theme.gray300};\n  margin-right: ${space(0.5)};\n`;\n\nconst HotkeyTitle = styled(`span`)`\n  font-size: ${p => p.theme.fontSizeSmall};\n`;\n","import {TokenResult} from '../searchSyntax/parser';\n\nexport enum ItemType {\n  DEFAULT = 'default',\n  TAG_KEY = 'tag-key',\n  TAG_VALUE = 'tag-value',\n  TAG_OPERATOR = 'tag-operator',\n  FIRST_RELEASE = 'first-release',\n  INVALID_TAG = 'invalid-tag',\n  RECENT_SEARCH = 'recent-search',\n  PROPERTY = 'property',\n}\n\nexport type SearchGroup = {\n  children: SearchItem[];\n  icon: React.ReactNode;\n  title: string;\n  type: ItemType | 'header';\n  desc?: string;\n  value?: string;\n};\n\nexport type SearchItem = {\n  active?: boolean;\n  /**\n   * Call a callback instead of setting a value in the search query\n   */\n  callback?: () => void;\n  children?: React.ReactNode[];\n  desc?: string;\n  documentation?: React.ReactNode;\n  ignoreMaxSearchItems?: boolean;\n  title?: string;\n  type?: ItemType;\n  value?: string;\n};\n\nexport type Tag = {\n  desc: string;\n  key: string;\n  predefined: boolean;\n  values: string[];\n};\n\nexport enum QuickActionType {\n  Delete = 'delete',\n  Negate = 'negate',\n  Next = 'next',\n  Previous = 'previous',\n}\n\nexport type QuickAction = {\n  actionType: QuickActionType;\n  text: string;\n  canRunAction?: (\n    token: TokenResult<any> | null | undefined,\n    filterTokenCount: number\n  ) => boolean;\n  hotkeys?: {\n    actual: string[] | string;\n    display: string[] | string;\n  };\n};\n","import {\n  filterTypeConfig,\n  interchangeableFilterOperators,\n  TermOperator,\n  Token,\n  TokenResult,\n} from 'sentry/components/searchSyntax/parser';\nimport {IconClock, IconStar, IconTag, IconToggle, IconUser} from 'sentry/icons';\nimport {t} from 'sentry/locale';\n\nimport HotkeysLabel from '../hotkeysLabel';\n\nimport {ItemType, QuickAction, QuickActionType, SearchGroup, SearchItem} from './types';\n\nexport function addSpace(query = '') {\n  if (query.length !== 0 && query[query.length - 1] !== ' ') {\n    return query + ' ';\n  }\n\n  return query;\n}\n\nexport function removeSpace(query = '') {\n  if (query[query.length - 1] === ' ') {\n    return query.slice(0, query.length - 1);\n  }\n\n  return query;\n}\n\n/**\n * Given a query, and the current cursor position, return the string-delimiting\n * index of the search term designated by the cursor.\n */\nexport function getLastTermIndex(query: string, cursor: number) {\n  // TODO: work with quoted-terms\n  const cursorOffset = query.slice(cursor).search(/\\s|$/);\n  return cursor + (cursorOffset === -1 ? 0 : cursorOffset);\n}\n\n/**\n * Returns an array of query terms, including incomplete terms\n *\n * e.g. [\"is:unassigned\", \"browser:\\\"Chrome 33.0\\\"\", \"assigned\"]\n */\nexport function getQueryTerms(query: string, cursor: number) {\n  return query.slice(0, cursor).match(/\\S+:\"[^\"]*\"?|\\S+/g);\n}\n\nfunction getTitleForType(type: ItemType) {\n  if (type === ItemType.TAG_VALUE) {\n    return t('Tag Values');\n  }\n\n  if (type === ItemType.RECENT_SEARCH) {\n    return t('Recent Searches');\n  }\n\n  if (type === ItemType.DEFAULT) {\n    return t('Common Search Terms');\n  }\n\n  if (type === ItemType.TAG_OPERATOR) {\n    return t('Operator Helpers');\n  }\n\n  if (type === ItemType.PROPERTY) {\n    return t('Properties');\n  }\n\n  return t('Tags');\n}\n\nfunction getIconForTypeAndTag(type: ItemType, tagName: string) {\n  if (type === ItemType.RECENT_SEARCH) {\n    return <IconClock size=\"xs\" />;\n  }\n\n  if (type === ItemType.DEFAULT) {\n    return <IconStar size=\"xs\" />;\n  }\n\n  // Change based on tagName and default to \"icon-tag\"\n  switch (tagName) {\n    case 'is':\n      return <IconToggle size=\"xs\" />;\n    case 'assigned':\n    case 'bookmarks':\n      return <IconUser size=\"xs\" />;\n    case 'firstSeen':\n    case 'lastSeen':\n    case 'event.timestamp':\n      return <IconClock size=\"xs\" />;\n    default:\n      return <IconTag size=\"xs\" />;\n  }\n}\n\nexport function createSearchGroups(\n  searchItems: SearchItem[],\n  recentSearchItems: SearchItem[] | undefined,\n  tagName: string,\n  type: ItemType,\n  maxSearchItems: number | undefined,\n  queryCharsLeft?: number\n) {\n  const activeSearchItem = 0;\n\n  if (maxSearchItems && maxSearchItems > 0) {\n    searchItems = searchItems.filter(\n      (value: SearchItem, index: number) =>\n        index < maxSearchItems || value.ignoreMaxSearchItems\n    );\n  }\n\n  if (queryCharsLeft || queryCharsLeft === 0) {\n    searchItems = searchItems.filter(\n      (value: SearchItem) =>\n        typeof value.value !== 'undefined' && value.value.length <= queryCharsLeft\n    );\n    if (recentSearchItems) {\n      recentSearchItems = recentSearchItems.filter(\n        (value: SearchItem) =>\n          typeof value.value !== 'undefined' && value.value.length <= queryCharsLeft\n      );\n    }\n  }\n\n  const searchGroup: SearchGroup = {\n    title: getTitleForType(type),\n    type: type === ItemType.INVALID_TAG ? type : 'header',\n    icon: getIconForTypeAndTag(type, tagName),\n    children: [...searchItems],\n  };\n\n  const recentSearchGroup: SearchGroup | undefined =\n    recentSearchItems && recentSearchItems.length > 0\n      ? {\n          title: t('Recent Searches'),\n          type: 'header',\n          icon: <IconClock size=\"xs\" />,\n          children: [...recentSearchItems],\n        }\n      : undefined;\n\n  if (searchGroup.children && !!searchGroup.children.length) {\n    searchGroup.children[activeSearchItem] = {\n      ...searchGroup.children[activeSearchItem],\n    };\n  }\n\n  return {\n    searchGroups: [searchGroup, ...(recentSearchGroup ? [recentSearchGroup] : [])],\n    flatSearchItems: [...searchItems, ...(recentSearchItems ? recentSearchItems : [])],\n    activeSearchItem: -1,\n  };\n}\n\n/**\n * Items is a list of dropdown groups that have a `children` field. Only the\n * `children` are selectable, so we need to find which child is selected given\n * an index that is in range of the sum of all `children` lengths\n *\n * @return Returns a tuple of [groupIndex, childrenIndex]\n */\nexport function filterSearchGroupsByIndex(items: SearchGroup[], index: number) {\n  let _index = index;\n  let foundSearchItem: [number?, number?] = [undefined, undefined];\n\n  items.find(({children}, i) => {\n    if (!children || !children.length) {\n      return false;\n    }\n    if (_index < children.length) {\n      foundSearchItem = [i, _index];\n      return true;\n    }\n\n    _index -= children.length;\n    return false;\n  });\n\n  return foundSearchItem;\n}\n\nexport function generateOperatorEntryMap(tag: string) {\n  return {\n    [TermOperator.Default]: {\n      type: ItemType.TAG_OPERATOR,\n      value: ':',\n      desc: `${tag}:${t('[value]')}`,\n      documentation: 'is equal to',\n    },\n    [TermOperator.GreaterThanEqual]: {\n      type: ItemType.TAG_OPERATOR,\n      value: ':>=',\n      desc: `${tag}:${t('>=[value]')}`,\n      documentation: 'is greater than or equal to',\n    },\n    [TermOperator.LessThanEqual]: {\n      type: ItemType.TAG_OPERATOR,\n      value: ':<=',\n      desc: `${tag}:${t('<=[value]')}`,\n      documentation: 'is less than or equal to',\n    },\n    [TermOperator.GreaterThan]: {\n      type: ItemType.TAG_OPERATOR,\n      value: ':>',\n      desc: `${tag}:${t('>[value]')}`,\n      documentation: 'is greater than',\n    },\n    [TermOperator.LessThan]: {\n      type: ItemType.TAG_OPERATOR,\n      value: ':<',\n      desc: `${tag}:${t('<[value]')}`,\n      documentation: 'is less than',\n    },\n    [TermOperator.Equal]: {\n      type: ItemType.TAG_OPERATOR,\n      value: ':=',\n      desc: `${tag}:${t('=[value]')}`,\n      documentation: 'is equal to',\n    },\n    [TermOperator.NotEqual]: {\n      type: ItemType.TAG_OPERATOR,\n      value: '!:',\n      desc: `!${tag}:${t('[value]')}`,\n      documentation: 'is not equal to',\n    },\n  };\n}\n\nexport function getValidOps(\n  filterToken: TokenResult<Token.Filter>\n): readonly TermOperator[] {\n  // If the token is invalid we want to use the possible expected types as our filter type\n  const validTypes = filterToken.invalid?.expectedType ?? [filterToken.filter];\n\n  // Determine any interchangable filter types for our valid types\n  const interchangeableTypes = validTypes.map(\n    type => interchangeableFilterOperators[type] ?? []\n  );\n\n  // Combine all types\n  const allValidTypes = [...new Set([...validTypes, ...interchangeableTypes.flat()])];\n\n  // Find all valid operations\n  const validOps = new Set<TermOperator>(\n    allValidTypes.map(type => filterTypeConfig[type].validOps).flat()\n  );\n\n  return [...validOps];\n}\n\nexport const quickActions: QuickAction[] = [\n  {\n    text: 'Delete',\n    actionType: QuickActionType.Delete,\n    hotkeys: {\n      actual: 'option+backspace',\n      display: 'option+backspace',\n    },\n    canRunAction: tok => {\n      return tok?.type === Token.Filter;\n    },\n  },\n  {\n    text: 'Negate',\n    actionType: QuickActionType.Negate,\n    hotkeys: {\n      actual: ['option+1', 'cmd+1'],\n      display: 'option+!',\n    },\n    canRunAction: tok => {\n      return tok?.type === Token.Filter;\n    },\n  },\n  {\n    text: 'Previous',\n    actionType: QuickActionType.Previous,\n    hotkeys: {\n      actual: ['option+left'],\n      display: 'option+left',\n    },\n    canRunAction: (tok, count) => {\n      return count > 1 || (count > 0 && tok?.type !== Token.Filter);\n    },\n  },\n  {\n    text: 'Next',\n    actionType: QuickActionType.Next,\n    hotkeys: {\n      actual: ['option+right'],\n      display: 'option+right',\n    },\n    canRunAction: (tok, count) => {\n      return count > 1 || (count > 0 && tok?.type !== Token.Filter);\n    },\n  },\n];\n\nexport function getQuickActionsSearchGroup(\n  runTokenActionOnCursorToken: (action: QuickAction) => void,\n  filterTokenCount: number,\n  activeToken?: TokenResult<any>\n): {searchGroup: SearchGroup; searchItems: SearchItem[]} | undefined {\n  const searchItems = quickActions\n    .filter(\n      action => !action.canRunAction || action.canRunAction(activeToken, filterTokenCount)\n    )\n    .map(action => ({\n      title: action.text,\n      callback: () => runTokenActionOnCursorToken(action),\n      documentation: action.hotkeys && <HotkeysLabel value={action.hotkeys.display} />,\n    }));\n\n  return searchItems.length > 0 && filterTokenCount > 0\n    ? {\n        searchGroup: {\n          title: t('Quick Actions'),\n          type: 'header',\n          icon: <IconStar size=\"xs\" />,\n          children: searchItems,\n        },\n        searchItems,\n      }\n    : undefined;\n}\n","import {createStore} from 'reflux';\n\nimport {defined} from 'sentry/utils';\nimport localStorage from 'sentry/utils/localStorage';\nimport {Theme} from 'sentry/utils/theme';\n\nimport {CommonStoreDefinition} from './types';\n\ntype Alert = {\n  message: React.ReactNode;\n  type: keyof Theme['alert'];\n  expireAfter?: number;\n  id?: string;\n  key?: number;\n  neverExpire?: boolean;\n  noDuplicates?: boolean;\n  onClose?: () => void;\n  opaque?: boolean;\n  url?: string;\n};\n\ninterface InternalAlertStoreDefinition {\n  alerts: Alert[];\n  count: number;\n}\ninterface AlertStoreDefinition\n  extends CommonStoreDefinition<Alert[]>,\n    InternalAlertStoreDefinition {\n  addAlert(alert: Alert): void;\n  closeAlert(alert: Alert, duration?: number): void;\n  init(): void;\n}\n\nconst storeConfig: AlertStoreDefinition = {\n  alerts: [],\n  count: 0,\n\n  init() {\n    this.alerts = [];\n    this.count = 0;\n  },\n\n  addAlert(alert) {\n    const alertAlreadyExists = this.alerts.some(a => a.id === alert.id);\n    if (alertAlreadyExists && alert.noDuplicates) {\n      return;\n    }\n\n    if (defined(alert.id)) {\n      const mutedData = localStorage.getItem('alerts:muted');\n      if (typeof mutedData === 'string' && mutedData.length) {\n        const expirations: Record<string, number> = JSON.parse(mutedData);\n\n        // Remove any objects that have passed their mute duration.\n        const now = Math.floor(new Date().valueOf() / 1000);\n        for (const key in expirations) {\n          if (expirations.hasOwnProperty(key) && expirations[key] < now) {\n            delete expirations[key];\n          }\n        }\n        localStorage.setItem('alerts:muted', JSON.stringify(expirations));\n\n        if (expirations.hasOwnProperty(alert.id)) {\n          return;\n        }\n      }\n    } else {\n      if (!defined(alert.expireAfter)) {\n        alert.expireAfter = 5000;\n      }\n    }\n\n    if (alert.expireAfter && !alert.neverExpire) {\n      window.setTimeout(() => {\n        this.closeAlert(alert);\n      }, alert.expireAfter);\n    }\n\n    alert.key = this.count++;\n\n    // intentionally recreate array via concat because of Reflux\n    // \"bug\" where React components are given same reference to tracked\n    // data objects, and don't *see* that values have changed\n    this.alerts = this.alerts.concat([alert]);\n    this.trigger(this.alerts);\n  },\n\n  closeAlert(alert, duration = 60 * 60 * 7 * 24) {\n    if (defined(alert.id) && defined(duration)) {\n      const expiry = Math.floor(new Date().valueOf() / 1000) + duration;\n      const mutedData = localStorage.getItem('alerts:muted');\n\n      let expirations: Record<string, number> = {};\n      if (typeof mutedData === 'string' && expirations.length) {\n        expirations = JSON.parse(mutedData);\n      }\n      expirations[alert.id] = expiry;\n      localStorage.setItem('alerts:muted', JSON.stringify(expirations));\n    }\n\n    // TODO(dcramer): we need some animations here for closing alerts\n    this.alerts = this.alerts.filter(item => alert !== item);\n    this.trigger(this.alerts);\n  },\n\n  getState() {\n    return this.alerts;\n  },\n};\n\nconst AlertStore = createStore(storeConfig);\nexport default AlertStore;\n","import {createStore} from 'reflux';\n\nimport {Tag, TagCollection} from 'sentry/types';\nimport {SEMVER_TAGS} from 'sentry/utils/discover/fields';\nimport {makeSafeRefluxStore} from 'sentry/utils/makeSafeRefluxStore';\n\nimport {CommonStoreDefinition} from './types';\n\n// This list is only used on issues. Events/discover\n// have their own field list that exists elsewhere.\n// contexts.key and contexts.value omitted on purpose.\nconst BUILTIN_TAGS = [\n  'event.type',\n  'platform',\n  'message',\n  'title',\n  'location',\n  'timestamp',\n  'release',\n  'user.id',\n  'user.username',\n  'user.email',\n  'user.ip',\n  'sdk.name',\n  'sdk.version',\n  'http.method',\n  'http.url',\n  'os.build',\n  'os.kernel_version',\n  'device.brand',\n  'device.locale',\n  'device.uuid',\n  'device.model_id',\n  'device.arch',\n  'device.orientation',\n  'geo.country_code',\n  'geo.region',\n  'geo.city',\n  'error.type',\n  'error.handled',\n  'error.unhandled',\n  'error.value',\n  'error.mechanism',\n  'stack.abs_path',\n  'stack.filename',\n  'stack.package',\n  'stack.module',\n  'stack.function',\n  'stack.stack_level',\n].reduce<TagCollection>((acc, tag) => {\n  acc[tag] = {key: tag, name: tag};\n  return acc;\n}, {});\n\ninterface TagStoreDefinition extends CommonStoreDefinition<TagCollection> {\n  getAllTags(): TagCollection;\n  getBuiltInTags(): TagCollection;\n  getIssueAttributes(): TagCollection;\n  loadTagsSuccess(data: Tag[]): void;\n  reset(): void;\n  state: TagCollection;\n}\n\nconst storeConfig: TagStoreDefinition = {\n  state: {},\n  unsubscribeListeners: [],\n\n  init() {\n    this.state = {};\n  },\n\n  getBuiltInTags() {\n    return {...BUILTIN_TAGS, ...SEMVER_TAGS};\n  },\n\n  getIssueAttributes() {\n    // TODO(mitsuhiko): what do we do with translations here?\n    const isSuggestions = [\n      'resolved',\n      'unresolved',\n      'ignored',\n      'assigned',\n      'for_review',\n      'unassigned',\n      'linked',\n      'unlinked',\n    ];\n    return {\n      is: {\n        key: 'is',\n        name: 'Status',\n        values: isSuggestions,\n        maxSuggestedValues: isSuggestions.length,\n        predefined: true,\n      },\n      has: {\n        key: 'has',\n        name: 'Has Tag',\n        values: Object.keys(this.state),\n        predefined: true,\n      },\n      assigned: {\n        key: 'assigned',\n        name: 'Assigned To',\n        values: [],\n        predefined: true,\n      },\n      bookmarks: {\n        key: 'bookmarks',\n        name: 'Bookmarked By',\n        values: [],\n        predefined: true,\n      },\n      lastSeen: {\n        key: 'lastSeen',\n        name: 'Last Seen',\n        values: ['-1h', '+1d', '-1w'],\n        predefined: true,\n      },\n      firstSeen: {\n        key: 'firstSeen',\n        name: 'First Seen',\n        values: ['-1h', '+1d', '-1w'],\n        predefined: true,\n      },\n      firstRelease: {\n        key: 'firstRelease',\n        name: 'First Release',\n        values: ['latest'],\n        predefined: true,\n      },\n      'event.timestamp': {\n        key: 'event.timestamp',\n        name: 'Event Timestamp',\n        values: ['2017-01-02', '>=2017-01-02T01:00:00', '<2017-01-02T02:00:00'],\n        predefined: true,\n      },\n      timesSeen: {\n        key: 'timesSeen',\n        name: 'Times Seen',\n        isInput: true,\n        // Below values are required or else SearchBar will attempt to get values // This is required or else SearchBar will attempt to get values\n        values: [],\n        predefined: true,\n      },\n      assigned_or_suggested: {\n        key: 'assigned_or_suggested',\n        name: 'Assigned or Suggested',\n        isInput: true,\n        values: [],\n        predefined: true,\n      },\n    };\n  },\n\n  reset() {\n    this.state = {};\n    this.trigger(this.state);\n  },\n\n  getAllTags() {\n    return this.state;\n  },\n\n  getState() {\n    return this.getAllTags();\n  },\n\n  loadTagsSuccess(data) {\n    const newTags = data.reduce<TagCollection>((acc, tag) => {\n      acc[tag.key] = {\n        values: [],\n        ...tag,\n      };\n\n      return acc;\n    }, {});\n\n    this.state = {...this.state, ...newTags};\n    this.trigger(this.state);\n  },\n};\n\nconst TagStore = createStore(makeSafeRefluxStore(storeConfig));\nexport default TagStore;\n","// key maps and utils retrieved from https://github.com/jaywcjlove/hotkeys\n\n/**\n * Includes a lot of leftover unused codes for the future in case we\n * want glyphs for them\n */\nconst keyNameCodeMapping = {\n  backspace: 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  '⇪': 20,\n  ',': 188,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '-': 189,\n  '=': 187,\n  ';': 186,\n  \"'\": 222,\n  '[': 219,\n  ']': 221,\n  '\\\\': 220,\n};\n\n// Modifier Keys\nconst modifierNameKeyCodeMapping = {\n  // shiftKey\n  '⇧': 16,\n  shift: 16,\n  // altKey\n  '⌥': 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  '⌃': 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  '⌘': 91,\n  cmd: 91,\n  command: 91,\n};\n\nexport const getKeyCode = (x: string): number =>\n  keyNameCodeMapping[x.toLowerCase()] ||\n  modifierNameKeyCodeMapping[x.toLowerCase()] ||\n  x.toUpperCase().charCodeAt(0);\n","import {useCallback, useEffect, useMemo} from 'react';\n\nimport {getKeyCode} from './getKeyCode';\n\nconst isKeyPressed = (key: string, evt: KeyboardEvent): boolean => {\n  const keyCode = getKeyCode(key);\n  switch (keyCode) {\n    case getKeyCode('command'):\n      return evt.metaKey;\n    case getKeyCode('shift'):\n      return evt.shiftKey;\n    case getKeyCode('ctrl'):\n      return evt.ctrlKey;\n    case getKeyCode('alt'):\n      return evt.altKey;\n    default:\n      return keyCode === evt.keyCode;\n  }\n};\n\n/**\n * Pass in the hotkey combinations under match and the corresponding callback function to be called.\n * Separate key names with +. For example, 'command+alt+shift+x'\n * Alternate matchings as an array: ['command+alt+backspace', 'ctrl+alt+delete']\n *\n * Note: you can only use one non-modifier (keys other than shift, ctrl, alt, command) key at a time.\n */\nexport function useHotkeys(\n  hotkeys: {callback: (e: KeyboardEvent) => void; match: string[] | string}[],\n  deps: React.DependencyList\n): void {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoizedHotkeys = useMemo(() => hotkeys, deps);\n\n  const onKeyDown = useCallback(\n    (evt: KeyboardEvent) => {\n      for (const set of memoizedHotkeys) {\n        const keysets = Array.isArray(set.match) ? set.match : [set.match];\n        for (const keyset of keysets) {\n          const keys = keyset.split('+');\n\n          if (keys.every(key => isKeyPressed(key, evt))) {\n            set.callback(evt);\n            return;\n          }\n        }\n      }\n    },\n    [memoizedHotkeys]\n  );\n\n  useEffect(() => {\n    document.addEventListener('keydown', onKeyDown);\n\n    return () => {\n      document.removeEventListener('keydown', onKeyDown);\n    };\n  }, [onKeyDown]);\n}\n"],"names":["getMemberUser","member","user","role","async","fetchOrgMembers","api","orgId","projectIds","endpoint","query","project","members","requestPromise","method","Sentry","scope","setExtras","Error","memberUsers","filter","MemberListStore","map","err","resp","indexMembersByProject","reduce","acc","projects","hasOwnProperty","push","updateMember","memberId","data","MemberActions","resendMemberInvite","regenerate","reinvite","resetSavedSearches","SavedSearchesActions","fetchSavedSearches","orgSlug","url","promise","then","catch","addErrorMessage","t","getRecentSearchUrl","saveRecentSearch","type","handleXhrErrorResponse","createSavedSearch","name","sort","SavedSearchType","fetchRecentSearches","limit","MAX_AUTOCOMPLETE_RECENT_SEARCHES","status","getPinSearchUrl","pinSearch","unpinSearch","pinnedSearch","pinnedType","deleteSavedSearch","search","id","tagFetchSuccess","tags","trimmedTags","slice","length","AlertStore","message","TagStore","loadOrganizationTags","selection","datetime","normalizeDateTimeParams","use_cache","String","fetchOrganizationTags","fetchTagValues","tagKey","endpointParams","includeTransactions","includeSessions","start","end","statsPeriod","createActions","ComingSoon","showIcon","Feature","Component","getAllFeatures","organization","config","this","props","configFeatures","features","Array","from","hasFeature","feature","shouldMatchOnlyProject","match","shouldMatchOnlyOrg","includes","render","children","renderDisabled","hookName","requireAll","allFeatures","feat","customDisabledRender","hooks","HookStore","renderProps","isRenderFunc","withOrganization","withProject","withConfig","Checkbox","defaultProps","checked","getRootCss","theme","css","textColor","hover","DropdownLink","anchorMiddle","title","customTitle","menuClasses","className","topLevelClasses","anchorRight","disabled","caret","alwaysRenderMenu","otherProps","useTheme","isOpen","getRootProps","getActorProps","getMenuProps","shouldRenderMenu","cx","classNames","topLevelCx","open","onClick","onClickActor","actorProps","undefined","direction","size","MenuItem","node","isLastNode","state","onClose","closeOnSelect","isSubmenuTrigger","submenuTriggerRef","renderAs","submenuTriggerProps","isHovering","setIsHovering","useState","ourRef","useRef","isDisabled","disabledKeys","has","key","isFocused","selectionManager","focusedKey","onAction","to","label","showDividers","itemProps","value","ref","hoverProps","useHover","onHoverChange","useEffect","select","clearSelection","keyboardProps","useKeyboard","onKeyDown","e","mouseEvent","MouseEvent","ctrlKey","metaKey","current","querySelector","MenuListItemInnerWrap","dispatchEvent","continuePropagation","menuItemProps","labelProps","descriptionProps","useMenuItem","mergeProps","itemLabel","rendered","showDivider","innerWrapProps","as","Link","detailsProps","trailingItems","Fragment","MenuSection","headingProps","groupProps","useMenuSection","heading","MenuSectionWrap","Heading","Group","p","fontSizeSmall","subText","space","Menu","offset","crossOffset","containerPadding","placement","triggerRef","triggerWidth","isSubmenu","menuTitle","closeRootMenu","closeCurrentSubmenu","isDismissable","shouldCloseOnBlur","useTreeState","selectionMode","stateCollection","useMemo","collection","menuRef","menuProps","useMenu","separatorProps","useSeparator","elementType","overlayRef","overlayProps","useOverlay","shouldCloseOnInteractOutside","target","contains","positionProps","placementProp","useOverlayPosition","targetRef","boundaryElement","document","hasFocus","setHasFocus","isLeafSubmenu","some","hasChildNodes","childNodes","child","isSelected","modifiedMenuProps","onKeyUp","renderCollection","i","showSeparator","itemToRender","items","trigger","submenuTitle","renderWrapAs","renderItemWithSubmenu","renderItem","Separator","restoreFocus","autoFocus","Overlay","MenuWrap","style","maxHeight","minWidth","MenuTitle","borderRadius","backgroundElevated","translucentBorder","dropShadowHeavy","fontSizeMedium","zIndex","dropdown","headingColor","innerBorder","MenuControl","triggerLabel","triggerProps","disabledProp","useMenuTriggerState","menuTriggerProps","useMenuTrigger","buttonProps","useButton","onPress","onPressStart","onPressEnd","setTriggerWidth","updateTriggerWidth","useCallback","Promise","resolve","window","setTimeout","newTriggerWidth","offsetWidth","useResizeObserver","onResize","ResizeObserver","MenuControlWrap","close","removeHiddenItems","source","item","hidden","sectionItem","Option","forwardRef","onChange","fontWeight","isTrue","yesFirst","yesLabel","noLabel","yesOption","noOption","inputStyles","RadioBooleanField","field","fieldProps","omit","macModifiers","normalModifiers","genericGlyphs","HotkeysLabel","forcePlatform","hotkeySets","isArray","o","trim","split","isMac","navigator","platform","toLowerCase","startsWith","finalKeySet","keySet","keyCode","getKeyCode","Key","toUpperCase","specificToOs","keyStr","keyToDisplay","find","every","HotkeysContainer","text","family","DEFAULT_SORT_OPTIONS","IssueSortOptions","CreateSavedSearchModal","isSaving","error","onSubmitSuccess","onSubmitError","event","validateSortOption","preventDefault","setState","addLoadingMessage","slug","_data","closeModal","clearIndicators","responseJSON","detail","sortOptions","option","options","Header","Body","sortOption","getSortLabel","initialData","onSubmit","handleSubmit","onCancel","saveOnBlur","submitLabel","placeholder","inline","stacked","flexibleControlStateSize","required","clearable","withApi","makePinSearchAction","Action","withRouter","menuItemVariant","savedSearchType","location","onTogglePinnedSearch","evt","stopPropagation","cursor","_cursor","page","_page","currentQuery","trackAnalyticsEvent","eventKey","eventName","organization_id","action","search_type","browserHistory","pathname","removeSpace","pinTooltip","withBorder","icon","isSolid","ActionButton","isActive","makeSaveSearchAction","openModal","deps","access","makeSearchBuilderAction","onSidebarToggle","tooltipProps","containerDisplayMode","Button","blue300","gray300","gray400","borderless","runQuickAction","useHotkeys","quickActions","hotkeys","actual","callback","makeQueryState","parsedQuery","parseSearch","generateOpAutocompleteGroup","validOps","tagName","operatorMap","generateOperatorEntryMap","searchItems","op","recentSearchItems","ItemType","escapeValue","replace","SmartSearchBar","initialQuery","searchTerm","searchGroups","flatSearchItems","activeSearchItem","inputHasFocus","loading","numActionsVisible","actionBarItems","createRef","entries","entry","width","contentRect","actionCount","Math","min","floor","max","token","filterTokens","searchInput","focus","tokenIndex","findIndex","tok","cursorPosition","selectionStart","selectionEnd","updateAutoCompleteItems","cursorToken","actionType","canRunAction","QuickActionType","index","execCommand","newQuery","updateQuery","Token","negated","moveToNextToken","reverse","doSearch","callIfFunction","onSearch","clearTimeout","blurTimeout","onBlur","clipboardData","getData","cursorPosStart","cursorPosEnd","textBefore","substring","textAfter","mergedText","newCursorPosition","hasSearchGroups","isSelectingDropdownItems","groupIndex","childrenIndex","filterSearchGroupsByIndex","active","currIndex","totalItems","nextActiveSearchItem","nextGroupIndex","nextChildrenIndex","onAutoComplete","isWithinToken","clauseStart","clauseEnd","replaceToken","beforeClause","endClause","blur","debounce","tag","onGetTagValues","noValueQuery","values","unshift","escapedValue","desc","DEFAULT_DEBOUNCE_DURATION","leading","indexOf","ignoreMaxSearchItems","maxSuggestedValues","hasRecentSearches","onGetRecentSearches","defined","fetchFn","fullQuery","searches","releasePromise","fetchReleases","getPredefinedTagValues","v","r","shortVersion","projectId","fetchQuery","per_page","MAX_AUTOCOMPLETE_RELEASES","releaseVersion","prepareQuery","excludeEnvironment","supportedTags","preparedQuery","filteredSearchGroups","fetchTagValuesFn","getReleases","predefined","getTagValues","tagValues","recentSearches","all","getRecentSearches","defaultSearchItems","defaultRecentItems","updateAutoCompleteState","tagKeys","tagType","getTagKeys","keyText","pop","RegExp","NEGATION_OPERATOR","autocompleteGroups","generateTagAutocompleteGroup","updateAutoCompleteStateMultiHeader","getKeyName","aggregateWithArgs","cursorValue","searchText","valueGroup","generateValueAutocompleteGroup","opGroup","getValidOps","showDefaultSearches","updateAutoCompleteFromAst","groups","maxSearchItems","maxQueryLength","queryCharsLeft","createSearchGroups","replaceText","trackAdvancedAnalyticsEvent","search_operator","valueLocation","valueToken","FilterType","currentValueNull","startPos","search_source","onAutoCompleteFromAst","componentDidMount","containerRef","inputResizeObserver","updateActionsVisible","observe","componentDidUpdate","prevProps","lastQuery","addSpace","componentWillUnmount","disconnect","defaultQuery","hasValidSearch","onSavedRecentSearch","searchSource","treeResultLocator","tree","noResultValue","visitorTest","returnResult","skipToken","invalid","matchedTokens","findTokensAtCursor","supportedTagType","getFieldDoc","Object","keys","documentation","a","b","localeCompare","dropdownClassName","useFormWrapper","inlineLabel","maxMenuHeight","input","SearchInput","autoComplete","onFocus","onQueryFocus","onQueryBlur","onQueryChange","onInputClick","onPaste","maxLength","spellCheck","actionItems","actionProps","visibleActions","overflowedActions","Container","SearchLabel","htmlFor","InputWrapper","Highlight","ActionsBar","gap","clearSearch","VerticalEllipsisIcon","display","searchSubstring","SmartSearchBarContainer","unsubscribe","border","dropShadowLight","background","backgroundSecondary","focusBorder","familyMono","getDynamicComponent","TextareaAutosize","fixed","shouldForwardProp","prop","isPropValid","formPlaceholder","ButtonBar","IconEllipsis","SearchDropdown","PureComponent","idx","substr","SearchDropdownGroup","SearchDropdownGroupTitle","SearchListItem","bind","element","scrollIntoView","block","SearchItemTitleWrapper","Description","renderDescription","Documentation","StyledSearchDropdown","LoadingWrapper","mini","SearchItemsList","isEmpty","invalidTag","Info","renderHeaderItem","DropdownFooter","ActionsRow","ActionButtonContainer","HotkeyGlyphWrapper","HotkeyTitle","href","fontSizeLarge","ListItem","lineHeightHeading","overflowEllipsis","color","darken","string","getTitleForType","getIconForTypeAndTag","searchGroup","recentSearchGroup","_index","foundSearchItem","TermOperator","filterToken","validTypes","expectedType","interchangeableTypes","interchangeableFilterOperators","allValidTypes","Set","flat","filterTypeConfig","count","storeConfig","alerts","init","addAlert","alert","noDuplicates","mutedData","localStorage","expirations","JSON","parse","now","Date","valueOf","stringify","expireAfter","neverExpire","closeAlert","concat","duration","expiry","getState","createStore","BUILTIN_TAGS","unsubscribeListeners","getBuiltInTags","SEMVER_TAGS","getIssueAttributes","isSuggestions","is","assigned","bookmarks","lastSeen","firstSeen","firstRelease","timesSeen","isInput","assigned_or_suggested","reset","getAllTags","loadTagsSuccess","newTags","makeSafeRefluxStore","keyNameCodeMapping","backspace","tab","clear","enter","return","esc","escape","left","up","right","down","del","delete","ins","insert","home","pageup","pagedown","capslock","num_0","num_1","num_2","num_3","num_4","num_5","num_6","num_7","num_8","num_9","num_multiply","num_add","num_enter","num_subtract","num_decimal","num_divide","modifierNameKeyCodeMapping","shift","alt","ctrl","control","cmd","command","x","charCodeAt","isKeyPressed","shiftKey","altKey","memoizedHotkeys","set","keysets","keyset","addEventListener","removeEventListener"],"sourceRoot":""}