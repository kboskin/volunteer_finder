{"version":3,"file":"chunks/app_components_events_interfaces_breadcrumbs_breadcrumb_type_index_tsx-app_components_events_-5f76ed.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/events/interfaces/breadcrumbs/breadcrumb/type/icon.tsx","webpack:///./app/components/events/interfaces/breadcrumbs/breadcrumb/type/index.tsx","webpack:///./app/components/events/interfaces/breadcrumbs/utils.tsx","webpack:///./app/components/events/interfaces/spans/filter.tsx","webpack:///./app/components/events/interfaces/spans/dragManager.tsx","webpack:///./app/components/events/interfaces/spans/spanBarCursorGuide.tsx","webpack:///./app/components/events/interfaces/spans/styles.tsx","webpack:///./app/components/events/interfaces/spans/spanBar.tsx","webpack:///./app/components/events/interfaces/spans/spanGroupBar.tsx","webpack:///./app/components/events/interfaces/spans/spanDescendantGroupBar.tsx","webpack:///./app/components/events/interfaces/spans/spanRectangle.tsx","webpack:///./app/components/events/interfaces/spans/spanRectangleOverlay.tsx","webpack:///./app/components/events/interfaces/spans/spanSiblingGroupBar.tsx","webpack:///./app/components/events/interfaces/spans/spanTree.tsx","webpack:///./app/components/events/interfaces/spans/traceView.tsx","webpack:///./app/components/events/interfaces/spans/spanTreeModel.tsx","webpack:///./app/components/events/interfaces/spans/waterfallModel.tsx","webpack:///./app/components/events/interfaces/spans/index.tsx","webpack:///./app/types/breadcrumbs.tsx","webpack:///./app/utils/performance/quickTrace/quickTraceContext.tsx"],"sourcesContent":["import {\n  IconFire,\n  IconFix,\n  IconInfo,\n  IconLocation,\n  IconMobile,\n  IconRefresh,\n  IconSort,\n  IconSpan,\n  IconStack,\n  IconTerminal,\n  IconUser,\n  IconWarning,\n} from 'sentry/icons';\nimport {BreadcrumbType} from 'sentry/types/breadcrumbs';\n\ntype Props = {\n  type: BreadcrumbType;\n};\n\nfunction Icon({type}: Props) {\n  switch (type) {\n    case BreadcrumbType.USER:\n    case BreadcrumbType.UI:\n      return <IconUser size=\"xs\" />;\n    case BreadcrumbType.NAVIGATION:\n      return <IconLocation size=\"xs\" />;\n    case BreadcrumbType.DEBUG:\n      return <IconFix size=\"xs\" />;\n    case BreadcrumbType.INFO:\n      return <IconInfo size=\"xs\" />;\n    case BreadcrumbType.ERROR:\n      return <IconFire size=\"xs\" />;\n    case BreadcrumbType.HTTP:\n      return <IconSort size=\"xs\" rotated />;\n    case BreadcrumbType.WARNING:\n      return <IconWarning size=\"xs\" />;\n    case BreadcrumbType.QUERY:\n      return <IconStack size=\"xs\" />;\n    case BreadcrumbType.SYSTEM:\n      return <IconMobile size=\"xs\" />;\n    case BreadcrumbType.SESSION:\n      return <IconRefresh size=\"xs\" />;\n    case BreadcrumbType.TRANSACTION:\n      return <IconSpan size=\"xs\" />;\n    default:\n      return <IconTerminal size=\"xs\" />;\n  }\n}\n\nexport default Icon;\n","import styled from '@emotion/styled';\n\nimport Tooltip from 'sentry/components/tooltip';\nimport SvgIcon from 'sentry/icons/svgIcon';\n\nimport Icon from './icon';\n\ntype Props = Required<Pick<React.ComponentProps<typeof SvgIcon>, 'color'>> &\n  React.ComponentProps<typeof Icon> & {\n    description?: string;\n    error?: boolean;\n  };\n\nfunction Type({type, color, description, error}: Props) {\n  return (\n    <Wrapper error={error}>\n      <Tooltip\n        title={description}\n        disabled={!description}\n        skipWrapper\n        disableForVisualTest\n      >\n        <IconWrapper color={color}>\n          <Icon type={type} />\n        </IconWrapper>\n      </Tooltip>\n    </Wrapper>\n  );\n}\n\nexport default Type;\n\nconst Wrapper = styled('div')<Pick<Props, 'error'>>`\n  display: flex;\n  justify-content: center;\n  position: relative;\n  :before {\n    content: '';\n    display: block;\n    width: 1px;\n    top: 0;\n    bottom: 0;\n    left: 50%;\n    transform: translate(-50%);\n    position: absolute;\n    background: ${p => (p.error ? p.theme.red300 : p.theme.innerBorder)};\n  }\n`;\n\nconst IconWrapper = styled('div')<Pick<Props, 'color'>>`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 22px;\n  height: 22px;\n  border-radius: 50%;\n  color: ${p => p.theme.white};\n  background: ${p => p.theme[p.color] ?? p.color};\n  box-shadow: ${p => p.theme.dropShadowLightest};\n  position: relative;\n`;\n","import {t} from 'sentry/locale';\nimport {\n  BreadcrumbLevelType,\n  BreadcrumbType,\n  Crumb,\n  RawCrumb,\n} from 'sentry/types/breadcrumbs';\nimport {EntryType, Event} from 'sentry/types/event';\nimport {defined} from 'sentry/utils';\n\nexport function convertCrumbType(breadcrumb: RawCrumb): RawCrumb {\n  if (breadcrumb.type === BreadcrumbType.EXCEPTION) {\n    return {\n      ...breadcrumb,\n      type: BreadcrumbType.ERROR,\n    };\n  }\n  // special case for 'ui.' and `sentry.` category breadcrumbs\n  // TODO: find a better way to customize UI around non-schema data\n  if (breadcrumb.type === BreadcrumbType.DEFAULT && defined(breadcrumb?.category)) {\n    const [category, subcategory] = breadcrumb.category.split('.');\n    if (category === 'ui') {\n      return {\n        ...breadcrumb,\n        type: BreadcrumbType.UI,\n      };\n    }\n\n    if (category === 'console') {\n      return {\n        ...breadcrumb,\n        type: BreadcrumbType.DEBUG,\n      };\n    }\n\n    if (category === 'navigation') {\n      return {\n        ...breadcrumb,\n        type: BreadcrumbType.NAVIGATION,\n      };\n    }\n\n    if (\n      category === 'sentry' &&\n      (subcategory === 'transaction' || subcategory === 'event')\n    ) {\n      return {\n        ...breadcrumb,\n        type: BreadcrumbType.TRANSACTION,\n      };\n    }\n  }\n\n  if (!Object.values(BreadcrumbType).includes(breadcrumb.type)) {\n    return {\n      ...breadcrumb,\n      type: BreadcrumbType.DEFAULT,\n    };\n  }\n\n  return breadcrumb;\n}\n\nfunction getCrumbDescriptionAndColor(\n  type: BreadcrumbType\n): Pick<Crumb, 'color' | 'description'> {\n  switch (type) {\n    case BreadcrumbType.USER:\n    case BreadcrumbType.UI:\n      return {\n        color: 'purple300',\n        description: t('User Action'),\n      };\n\n    case BreadcrumbType.NAVIGATION:\n      return {\n        color: 'green300',\n        description: t('Navigation'),\n      };\n\n    case BreadcrumbType.DEBUG:\n      return {\n        color: 'purple300',\n        description: t('Debug'),\n      };\n\n    case BreadcrumbType.INFO:\n      return {\n        color: 'blue300',\n        description: t('Info'),\n      };\n\n    case BreadcrumbType.ERROR:\n      return {\n        color: 'red300',\n        description: t('Error'),\n      };\n\n    case BreadcrumbType.HTTP:\n      return {\n        color: 'green300',\n        description: t('HTTP request'),\n      };\n\n    case BreadcrumbType.WARNING:\n      return {\n        color: 'yellow300',\n        description: t('Warning'),\n      };\n    case BreadcrumbType.QUERY:\n      return {\n        color: 'blue300',\n        description: t('Query'),\n      };\n    case BreadcrumbType.SYSTEM:\n      return {\n        color: 'pink300',\n        description: t('System'),\n      };\n    case BreadcrumbType.SESSION:\n      return {\n        color: 'pink300',\n        description: t('Session'),\n      };\n    case BreadcrumbType.TRANSACTION:\n      return {\n        color: 'pink300',\n        description: t('Transaction'),\n      };\n    default:\n      return {\n        color: 'gray300',\n        description: t('Default'),\n      };\n  }\n}\n\nexport function transformCrumbs(breadcrumbs: Array<RawCrumb>): Crumb[] {\n  return breadcrumbs.map((breadcrumb, index) => {\n    const convertedCrumbType = convertCrumbType(breadcrumb);\n    const {color, description} = getCrumbDescriptionAndColor(convertedCrumbType.type);\n    return {\n      ...convertedCrumbType,\n      id: index,\n      color,\n      description,\n      level: convertedCrumbType.level ?? BreadcrumbLevelType.UNDEFINED,\n    };\n  });\n}\n\nfunction moduleToCategory(module: string | null | undefined) {\n  if (!module) {\n    return undefined;\n  }\n  const match = module.match(/^.*\\/(.*?)(:\\d+)/);\n  if (!match) {\n    return module.split(/./)[0];\n  }\n  return match[1];\n}\n\nexport function getVirtualCrumb(event: Event): RawCrumb | undefined {\n  const exception = event.entries.find(entry => entry.type === EntryType.EXCEPTION);\n\n  if (!exception && !event.message) {\n    return undefined;\n  }\n\n  const timestamp = event.dateCreated;\n\n  if (exception) {\n    const {type, value, module: mdl} = exception.data.values[0];\n    return {\n      type: BreadcrumbType.ERROR,\n      level: BreadcrumbLevelType.ERROR,\n      category: moduleToCategory(mdl) || 'exception',\n      data: {\n        type,\n        value,\n      },\n      timestamp,\n    };\n  }\n\n  const levelTag = (event.tags || []).find(tag => tag.key === 'level');\n\n  return {\n    type: BreadcrumbType.INFO,\n    level: (levelTag?.value as BreadcrumbLevelType) || BreadcrumbLevelType.UNDEFINED,\n    category: 'message',\n    message: event.message,\n    timestamp,\n  };\n}\n","import {Fragment} from 'react';\nimport styled from '@emotion/styled';\n\nimport CheckboxFancy from 'sentry/components/checkboxFancy/checkboxFancy';\nimport DropdownButton from 'sentry/components/dropdownButton';\nimport DropdownControl from 'sentry/components/dropdownControl';\nimport {pickBarColor} from 'sentry/components/performance/waterfall/utils';\nimport {IconFilter} from 'sentry/icons';\nimport {t, tn} from 'sentry/locale';\nimport space from 'sentry/styles/space';\n\ntype DropdownButtonProps = React.ComponentProps<typeof DropdownButton>;\n\ntype NoFilter = {\n  type: 'no_filter';\n};\n\nexport type ActiveFilter = {\n  operationNames: Set<string>;\n  type: 'active_filter';\n};\n\nexport const noFilter: NoFilter = {\n  type: 'no_filter',\n};\n\nexport type ActiveOperationFilter = NoFilter | ActiveFilter;\n\ntype Props = {\n  operationNameCounts: Map<string, number>;\n  operationNameFilter: ActiveOperationFilter;\n  toggleAllOperationNameFilters: () => void;\n  toggleOperationNameFilter: (operationName: string) => void;\n};\n\nfunction Filter({\n  operationNameCounts,\n  operationNameFilter,\n  toggleOperationNameFilter,\n  toggleAllOperationNameFilters,\n}: Props) {\n  if (operationNameCounts.size === 0) {\n    return null;\n  }\n\n  const checkedQuantity =\n    operationNameFilter.type === 'no_filter'\n      ? 0\n      : operationNameFilter.operationNames.size;\n\n  const dropDownButtonProps: Pick<DropdownButtonProps, 'children' | 'priority'> & {\n    hasDarkBorderBottomColor: boolean;\n  } = {\n    children: (\n      <Fragment>\n        <IconFilter />\n        <FilterLabel>{t('Filter')}</FilterLabel>\n      </Fragment>\n    ),\n    priority: 'default',\n    hasDarkBorderBottomColor: false,\n  };\n\n  if (checkedQuantity > 0) {\n    dropDownButtonProps.children = (\n      <span>{tn('%s Active Filter', '%s Active Filters', checkedQuantity)}</span>\n    );\n    dropDownButtonProps.priority = 'primary';\n    dropDownButtonProps.hasDarkBorderBottomColor = true;\n  }\n\n  return (\n    <Wrapper data-test-id=\"op-filter-dropdown\">\n      <DropdownControl\n        menuWidth=\"240px\"\n        blendWithActor\n        button={({isOpen, getActorProps}) => (\n          <StyledDropdownButton\n            {...getActorProps()}\n            showChevron={false}\n            isOpen={isOpen}\n            hasDarkBorderBottomColor={dropDownButtonProps.hasDarkBorderBottomColor}\n            priority={dropDownButtonProps.priority as DropdownButtonProps['priority']}\n            data-test-id=\"filter-button\"\n          >\n            {dropDownButtonProps.children}\n          </StyledDropdownButton>\n        )}\n      >\n        <MenuContent\n          onClick={event => {\n            // propagated clicks will dismiss the menu; we stop this here\n            event.stopPropagation();\n          }}\n        >\n          <Header>\n            <span>{t('Operation')}</span>\n            <CheckboxFancy\n              isChecked={checkedQuantity > 0}\n              isIndeterminate={\n                checkedQuantity > 0 && checkedQuantity !== operationNameCounts.size\n              }\n              onClick={event => {\n                event.stopPropagation();\n                toggleAllOperationNameFilters();\n              }}\n            />\n          </Header>\n          <List>\n            {Array.from(operationNameCounts, ([operationName, operationCount]) => {\n              const isActive =\n                operationNameFilter.type === 'no_filter'\n                  ? false\n                  : operationNameFilter.operationNames.has(operationName);\n\n              return (\n                <ListItem key={operationName} isChecked={isActive}>\n                  <OperationDot backgroundColor={pickBarColor(operationName)} />\n                  <OperationName>{operationName}</OperationName>\n                  <OperationCount>{operationCount}</OperationCount>\n                  <CheckboxFancy\n                    isChecked={isActive}\n                    onClick={event => {\n                      event.stopPropagation();\n                      toggleOperationNameFilter(operationName);\n                    }}\n                  />\n                </ListItem>\n              );\n            })}\n          </List>\n        </MenuContent>\n      </DropdownControl>\n    </Wrapper>\n  );\n}\n\nconst FilterLabel = styled('span')`\n  margin-left: ${space(1)};\n`;\n\nconst Wrapper = styled('div')`\n  position: relative;\n  display: flex;\n\n  margin-right: ${space(1)};\n`;\n\nconst StyledDropdownButton = styled(DropdownButton)<{hasDarkBorderBottomColor?: boolean}>`\n  white-space: nowrap;\n  max-width: 200px;\n\n  &:hover,\n  &:active {\n    ${p =>\n      !p.isOpen &&\n      p.hasDarkBorderBottomColor &&\n      `\n          border-bottom-color: ${p.theme.button.primary.border};\n        `}\n  }\n\n  ${p =>\n    !p.isOpen &&\n    p.hasDarkBorderBottomColor &&\n    `\n      border-bottom-color: ${p.theme.button.primary.border};\n    `}\n`;\n\nconst MenuContent = styled('div')`\n  max-height: 250px;\n  overflow-y: auto;\n  border-top: 1px solid ${p => p.theme.gray200};\n`;\n\nconst Header = styled('div')`\n  display: grid;\n  grid-template-columns: auto min-content;\n  grid-column-gap: ${space(1)};\n  align-items: center;\n\n  margin: 0;\n  background-color: ${p => p.theme.backgroundSecondary};\n  color: ${p => p.theme.gray300};\n  font-weight: normal;\n  font-size: ${p => p.theme.fontSizeMedium};\n  padding: ${space(1)} ${space(2)};\n  border-bottom: 1px solid ${p => p.theme.border};\n`;\n\nconst List = styled('ul')`\n  list-style: none;\n  margin: 0;\n  padding: 0;\n`;\n\nconst ListItem = styled('li')<{isChecked?: boolean}>`\n  display: grid;\n  grid-template-columns: max-content 1fr max-content max-content;\n  grid-column-gap: ${space(1)};\n  align-items: center;\n  padding: ${space(1)} ${space(2)};\n  border-bottom: 1px solid ${p => p.theme.border};\n  :hover {\n    background-color: ${p => p.theme.backgroundSecondary};\n  }\n  ${CheckboxFancy} {\n    opacity: ${p => (p.isChecked ? 1 : 0.3)};\n  }\n\n  &:hover ${CheckboxFancy} {\n    opacity: 1;\n  }\n\n  &:hover span {\n    color: ${p => p.theme.blue300};\n    text-decoration: underline;\n  }\n`;\n\nconst OperationDot = styled('div')<{backgroundColor: string}>`\n  content: '';\n  display: block;\n  width: 8px;\n  min-width: 8px;\n  height: 8px;\n  margin-right: ${space(1)};\n  border-radius: 100%;\n\n  background-color: ${p => p.backgroundColor};\n`;\n\nconst OperationName = styled('div')`\n  font-size: ${p => p.theme.fontSizeMedium};\n  ${p => p.theme.overflowEllipsis};\n`;\n\nconst OperationCount = styled('div')`\n  font-size: ${p => p.theme.fontSizeMedium};\n`;\n\nexport function toggleFilter(\n  previousState: ActiveOperationFilter,\n  operationName: string\n): ActiveOperationFilter {\n  if (previousState.type === 'no_filter') {\n    return {\n      type: 'active_filter',\n      operationNames: new Set([operationName]),\n    };\n  }\n\n  // invariant: previousState.type === 'active_filter'\n  // invariant: previousState.operationNames.size >= 1\n\n  const {operationNames} = previousState;\n\n  if (operationNames.has(operationName)) {\n    operationNames.delete(operationName);\n  } else {\n    operationNames.add(operationName);\n  }\n\n  if (operationNames.size > 0) {\n    return {\n      type: 'active_filter',\n      operationNames,\n    };\n  }\n\n  return {\n    type: 'no_filter',\n  };\n}\n\nexport function toggleAllFilters(\n  previousState: ActiveOperationFilter,\n  operationNames: string[]\n): ActiveOperationFilter {\n  if (previousState.type === 'no_filter') {\n    return {\n      type: 'active_filter',\n      operationNames: new Set(operationNames),\n    };\n  }\n\n  // invariant: previousState.type === 'active_filter'\n\n  if (previousState.operationNames.size === operationNames.length) {\n    // all filters were selected, so the next state should un-select all filters\n    return {\n      type: 'no_filter',\n    };\n  }\n\n  // not all filters were selected, so the next state is to select all the remaining filters\n  return {\n    type: 'active_filter',\n    operationNames: new Set(operationNames),\n  };\n}\n\nexport default Filter;\n","import {Component} from 'react';\n\nimport {clamp, rectOfContent} from 'sentry/components/performance/waterfall/utils';\nimport {PerformanceInteraction} from 'sentry/utils/performanceForSentry';\nimport {setBodyUserSelect, UserSelectValues} from 'sentry/utils/userselect';\n\n// we establish the minimum window size so that the window size of 0% is not possible\nconst MINIMUM_WINDOW_SIZE = 0.5 / 100; // 0.5% window size\n\nenum ViewHandleType {\n  Left,\n  Right,\n}\n\nexport type DragManagerChildrenProps = {\n  // handles\n\n  isDragging: boolean;\n\n  // between 0 to 1\n  // window selection\n  isWindowSelectionDragging: boolean;\n  leftHandlePosition: number;\n\n  // left-side handle\n  onLeftHandleDragStart: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;\n  // between 0 to 1\n  // right-side handle\n  onRightHandleDragStart: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;\n\n  onWindowSelectionDragStart: (\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\n  ) => void;\n  rightHandlePosition: number;\n  // between 0 to 1\n  viewWindowEnd: number;\n  // window sizes\n  viewWindowStart: number;\n  // between 0 (0%) and 1 (100%)\n  windowSelectionCurrent: number;\n\n  windowSelectionInitial: number;\n  // between 0 (0%) and 1 (100%)\n  windowSelectionSize: number; // between 0 to 1\n};\n\ntype DragManagerProps = {\n  children: (props: DragManagerChildrenProps) => JSX.Element;\n\n  // this is the DOM element where the drag events occur. it's also the reference point\n  // for calculating the relative mouse x coordinate.\n  interactiveLayerRef: React.RefObject<HTMLDivElement>;\n};\n\ntype DragManagerState = {\n  currentDraggingHandle: ViewHandleType | undefined;\n  // draggable handles\n  isDragging: boolean;\n  // window selection\n  isWindowSelectionDragging: boolean;\n  leftHandlePosition: number;\n\n  rightHandlePosition: number;\n  viewWindowEnd: number;\n  // window sizes\n  viewWindowStart: number;\n  windowSelectionCurrent: number;\n\n  windowSelectionInitial: number;\n  windowSelectionSize: number;\n};\n\nclass DragManager extends Component<DragManagerProps, DragManagerState> {\n  state: DragManagerState = {\n    // draggable handles\n\n    isDragging: false,\n    currentDraggingHandle: void 0,\n    leftHandlePosition: 0, // positioned on the left-most side at 0%\n    rightHandlePosition: 1, // positioned on the right-most side at 100%\n\n    // window selection\n\n    isWindowSelectionDragging: false,\n    windowSelectionInitial: 0, // between 0 (0%) and 1 (100%)\n    windowSelectionCurrent: 0, // between 0 (0%) and 1 (100%)\n    windowSelectionSize: 0,\n\n    // window sizes\n\n    viewWindowStart: 0,\n    viewWindowEnd: 1,\n  };\n\n  componentWillUnmount() {\n    this.cleanUpListeners();\n  }\n\n  previousUserSelect: UserSelectValues | null = null;\n\n  hasInteractiveLayer = (): boolean => !!this.props.interactiveLayerRef.current;\n\n  onDragStart =\n    (viewHandle: ViewHandleType) =>\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      const isDragging = this.state.isDragging || this.state.isWindowSelectionDragging;\n\n      if (isDragging || event.type !== 'mousedown' || !this.hasInteractiveLayer()) {\n        return;\n      }\n\n      PerformanceInteraction.startInteraction('SpanTreeHandleDrag');\n\n      // prevent the user from selecting things outside the minimap when dragging\n      // the mouse cursor outside the minimap\n\n      this.previousUserSelect = setBodyUserSelect({\n        userSelect: 'none',\n        MozUserSelect: 'none',\n        msUserSelect: 'none',\n        webkitUserSelect: 'none',\n      });\n\n      // attach event listeners so that the mouse cursor can drag outside of the\n      // minimap\n      window.addEventListener('mousemove', this.onDragMove);\n      window.addEventListener('mouseup', this.onDragEnd);\n\n      // indicate drag has begun\n\n      this.setState({\n        isDragging: true,\n        isWindowSelectionDragging: false,\n        currentDraggingHandle: viewHandle,\n      });\n    };\n\n  onLeftHandleDragStart = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    this.onDragStart(ViewHandleType.Left)(event);\n  };\n\n  onRightHandleDragStart = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    this.onDragStart(ViewHandleType.Right)(event);\n  };\n\n  onDragMove = (event: MouseEvent) => {\n    if (\n      !this.state.isDragging ||\n      event.type !== 'mousemove' ||\n      !this.hasInteractiveLayer()\n    ) {\n      return;\n    }\n\n    const rect = rectOfContent(this.props.interactiveLayerRef.current!);\n\n    // mouse x-coordinate relative to the interactive layer's left side\n    const rawMouseX = (event.pageX - rect.x) / rect.width;\n\n    switch (this.state.currentDraggingHandle) {\n      case ViewHandleType.Left: {\n        const min = 0;\n        const max = this.state.rightHandlePosition - MINIMUM_WINDOW_SIZE;\n\n        this.setState({\n          // clamp rawMouseX to be within [0, rightHandlePosition - MINIMUM_WINDOW_SIZE]\n          leftHandlePosition: clamp(rawMouseX, min, max),\n        });\n        break;\n      }\n      case ViewHandleType.Right: {\n        const min = this.state.leftHandlePosition + MINIMUM_WINDOW_SIZE;\n        const max = 1;\n\n        this.setState({\n          // clamp rawMouseX to be within [leftHandlePosition + MINIMUM_WINDOW_SIZE, 1]\n          rightHandlePosition: clamp(rawMouseX, min, max),\n        });\n        break;\n      }\n      default: {\n        throw Error('this.state.currentDraggingHandle is undefined');\n      }\n    }\n  };\n\n  onDragEnd = (event: MouseEvent) => {\n    if (\n      !this.state.isDragging ||\n      event.type !== 'mouseup' ||\n      !this.hasInteractiveLayer()\n    ) {\n      return;\n    }\n\n    PerformanceInteraction.finishInteraction();\n\n    // remove listeners that were attached in onDragStart\n\n    this.cleanUpListeners();\n\n    // restore body styles\n\n    if (this.previousUserSelect) {\n      setBodyUserSelect(this.previousUserSelect);\n      this.previousUserSelect = null;\n    }\n\n    // indicate drag has ended\n\n    switch (this.state.currentDraggingHandle) {\n      case ViewHandleType.Left: {\n        this.setState(state => ({\n          isDragging: false,\n          currentDraggingHandle: void 0,\n\n          // commit leftHandlePosition to be viewWindowStart\n          viewWindowStart: state.leftHandlePosition,\n        }));\n        return;\n      }\n      case ViewHandleType.Right: {\n        this.setState(state => ({\n          isDragging: false,\n          currentDraggingHandle: void 0,\n\n          // commit rightHandlePosition to be viewWindowEnd\n          viewWindowEnd: state.rightHandlePosition,\n        }));\n        return;\n      }\n      default: {\n        throw Error('this.state.currentDraggingHandle is undefined');\n      }\n    }\n  };\n\n  onWindowSelectionDragStart = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    const isDragging = this.state.isDragging || this.state.isWindowSelectionDragging;\n\n    if (isDragging || event.type !== 'mousedown' || !this.hasInteractiveLayer()) {\n      return;\n    }\n\n    PerformanceInteraction.startInteraction('SpanTreeWindowDrag');\n\n    // prevent the user from selecting things outside the minimap when dragging\n    // the mouse cursor outside the minimap\n\n    this.previousUserSelect = setBodyUserSelect({\n      userSelect: 'none',\n      MozUserSelect: 'none',\n      msUserSelect: 'none',\n      webkitUserSelect: 'none',\n    });\n\n    // attach event listeners so that the mouse cursor can drag outside of the\n    // minimap\n    window.addEventListener('mousemove', this.onWindowSelectionDragMove);\n    window.addEventListener('mouseup', this.onWindowSelectionDragEnd);\n\n    // indicate drag has begun\n\n    const rect = rectOfContent(this.props.interactiveLayerRef.current!);\n\n    // mouse x-coordinate relative to the interactive layer's left side\n    const rawMouseX = (event.pageX - rect.x) / rect.width;\n\n    this.setState({\n      isDragging: false,\n      isWindowSelectionDragging: true,\n      windowSelectionInitial: rawMouseX, // between 0 (0%) and 1 (100%)\n      windowSelectionCurrent: rawMouseX, // between 0 (0%) and 1 (100%)\n    });\n  };\n\n  onWindowSelectionDragMove = (event: MouseEvent) => {\n    if (\n      !this.state.isWindowSelectionDragging ||\n      event.type !== 'mousemove' ||\n      !this.hasInteractiveLayer()\n    ) {\n      return;\n    }\n\n    const rect = rectOfContent(this.props.interactiveLayerRef.current!);\n\n    // mouse x-coordinate relative to the interactive layer's left side\n    const rawMouseX = (event.pageX - rect.x) / rect.width;\n\n    const min = 0;\n    const max = 1;\n\n    // clamp rawMouseX to be within [0, 1]\n    const windowSelectionCurrent = clamp(rawMouseX, min, max);\n\n    const windowSelectionSize = clamp(\n      Math.abs(this.state.windowSelectionInitial - windowSelectionCurrent),\n      min,\n      max\n    );\n\n    this.setState({\n      windowSelectionCurrent,\n      windowSelectionSize,\n    });\n  };\n\n  onWindowSelectionDragEnd = (event: MouseEvent) => {\n    if (\n      !this.state.isWindowSelectionDragging ||\n      event.type !== 'mouseup' ||\n      !this.hasInteractiveLayer()\n    ) {\n      return;\n    }\n\n    PerformanceInteraction.finishInteraction();\n\n    // remove listeners that were attached in onWindowSelectionDragStart\n\n    this.cleanUpListeners();\n\n    // restore body styles\n\n    if (this.previousUserSelect) {\n      setBodyUserSelect(this.previousUserSelect);\n      this.previousUserSelect = null;\n    }\n\n    // indicate drag has ended\n\n    this.setState(state => {\n      let viewWindowStart = Math.min(\n        state.windowSelectionInitial,\n        state.windowSelectionCurrent\n      );\n      let viewWindowEnd = Math.max(\n        state.windowSelectionInitial,\n        state.windowSelectionCurrent\n      );\n\n      // enforce minimum window size\n      if (viewWindowEnd - viewWindowStart < MINIMUM_WINDOW_SIZE) {\n        viewWindowEnd = viewWindowStart + MINIMUM_WINDOW_SIZE;\n\n        if (viewWindowEnd > 1) {\n          viewWindowEnd = 1;\n          viewWindowStart = 1 - MINIMUM_WINDOW_SIZE;\n        }\n      }\n\n      return {\n        isWindowSelectionDragging: false,\n        windowSelectionInitial: 0,\n        windowSelectionCurrent: 0,\n        windowSelectionSize: 0,\n\n        leftHandlePosition: viewWindowStart,\n        rightHandlePosition: viewWindowEnd,\n\n        viewWindowStart,\n        viewWindowEnd,\n      };\n    });\n  };\n\n  cleanUpListeners = () => {\n    if (this.state.isDragging) {\n      window.removeEventListener('mousemove', this.onDragMove);\n      window.removeEventListener('mouseup', this.onDragEnd);\n    }\n\n    if (this.state.isWindowSelectionDragging) {\n      window.removeEventListener('mousemove', this.onWindowSelectionDragMove);\n      window.removeEventListener('mouseup', this.onWindowSelectionDragEnd);\n    }\n  };\n\n  render() {\n    const childrenProps = {\n      isDragging: this.state.isDragging,\n\n      // left handle\n\n      onLeftHandleDragStart: this.onLeftHandleDragStart,\n      leftHandlePosition: this.state.leftHandlePosition,\n\n      // right handle\n\n      onRightHandleDragStart: this.onRightHandleDragStart,\n      rightHandlePosition: this.state.rightHandlePosition,\n\n      // window selection\n\n      isWindowSelectionDragging: this.state.isWindowSelectionDragging,\n      windowSelectionInitial: this.state.windowSelectionInitial,\n      windowSelectionCurrent: this.state.windowSelectionCurrent,\n      windowSelectionSize: this.state.windowSelectionSize,\n      onWindowSelectionDragStart: this.onWindowSelectionDragStart,\n\n      // window sizes\n\n      viewWindowStart: this.state.viewWindowStart,\n      viewWindowEnd: this.state.viewWindowEnd,\n    };\n\n    return this.props.children(childrenProps);\n  }\n}\n\nexport default DragManager;\n","import styled from '@emotion/styled';\n\nimport {toPercent} from 'sentry/components/performance/waterfall/utils';\n\nimport * as CursorGuideHandler from './cursorGuideHandler';\n\nfunction SpanBarCursorGuide() {\n  return (\n    <CursorGuideHandler.Consumer>\n      {({\n        showCursorGuide,\n        traceViewMouseLeft,\n      }: {\n        showCursorGuide: boolean;\n        traceViewMouseLeft: number | undefined;\n      }) => {\n        if (!showCursorGuide || !traceViewMouseLeft) {\n          return null;\n        }\n\n        return (\n          <CursorGuide\n            style={{\n              left: toPercent(traceViewMouseLeft),\n            }}\n          />\n        );\n      }}\n    </CursorGuideHandler.Consumer>\n  );\n}\n\nconst CursorGuide = styled('div')`\n  position: absolute;\n  top: 0;\n  width: 1px;\n  background-color: ${p => p.theme.red300};\n  transform: translateX(-50%);\n  height: 100%;\n`;\n\nexport default SpanBarCursorGuide;\n","import styled from '@emotion/styled';\n\nimport {ROW_HEIGHT} from 'sentry/components/performance/waterfall/constants';\n\nexport const MeasurementMarker = styled('div')<{failedThreshold: boolean}>`\n  position: absolute;\n  top: 0;\n  height: ${ROW_HEIGHT}px;\n  user-select: none;\n  width: 1px;\n  background: repeating-linear-gradient(\n      to bottom,\n      transparent 0 4px,\n      ${p => (p.failedThreshold ? p.theme.red300 : p.theme.textColor)} 4px 8px\n    )\n    80%/2px 100% no-repeat;\n  z-index: ${p => p.theme.zIndex.traceView.dividerLine};\n  color: ${p => p.theme.textColor};\n`;\n","import 'intersection-observer'; // this is a polyfill\n\nimport {Component, createRef, Fragment} from 'react';\nimport styled from '@emotion/styled';\n\nimport Count from 'sentry/components/count';\nimport {ROW_HEIGHT} from 'sentry/components/performance/waterfall/constants';\nimport {MessageRow} from 'sentry/components/performance/waterfall/messageRow';\nimport {\n  Row,\n  RowCell,\n  RowCellContainer,\n} from 'sentry/components/performance/waterfall/row';\nimport {DurationPill, RowRectangle} from 'sentry/components/performance/waterfall/rowBar';\nimport {\n  DividerContainer,\n  DividerLine,\n  DividerLineGhostContainer,\n  EmbeddedTransactionBadge,\n  ErrorBadge,\n} from 'sentry/components/performance/waterfall/rowDivider';\nimport {\n  RowTitle,\n  RowTitleContainer,\n  RowTitleContent,\n} from 'sentry/components/performance/waterfall/rowTitle';\nimport {\n  ConnectorBar,\n  TOGGLE_BORDER_BOX,\n  TreeConnector,\n  TreeToggle,\n  TreeToggleContainer,\n  TreeToggleIcon,\n} from 'sentry/components/performance/waterfall/treeConnector';\nimport {\n  getDurationDisplay,\n  getHumanDuration,\n  toPercent,\n} from 'sentry/components/performance/waterfall/utils';\nimport Tooltip from 'sentry/components/tooltip';\nimport {IconWarning} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\nimport {Organization} from 'sentry/types';\nimport {EventTransaction} from 'sentry/types/event';\nimport {defined} from 'sentry/utils';\nimport {trackAnalyticsEvent} from 'sentry/utils/analytics';\nimport {generateEventSlug} from 'sentry/utils/discover/urls';\nimport * as QuickTraceContext from 'sentry/utils/performance/quickTrace/quickTraceContext';\nimport {QuickTraceContextChildrenProps} from 'sentry/utils/performance/quickTrace/quickTraceContext';\nimport {QuickTraceEvent, TraceError} from 'sentry/utils/performance/quickTrace/types';\nimport {isTraceFull} from 'sentry/utils/performance/quickTrace/utils';\n\nimport * as AnchorLinkManager from './anchorLinkManager';\nimport {\n  MINIMAP_CONTAINER_HEIGHT,\n  MINIMAP_SPAN_BAR_HEIGHT,\n  NUM_OF_SPANS_FIT_IN_MINI_MAP,\n} from './constants';\nimport * as DividerHandlerManager from './dividerHandlerManager';\nimport SpanBarCursorGuide from './spanBarCursorGuide';\nimport SpanDetail from './spanDetail';\nimport {MeasurementMarker} from './styles';\nimport {\n  FetchEmbeddedChildrenState,\n  GroupType,\n  ParsedTraceType,\n  ProcessedSpanType,\n  SpanType,\n  TreeDepthType,\n} from './types';\nimport {\n  durationlessBrowserOps,\n  getMeasurementBounds,\n  getMeasurements,\n  getSpanID,\n  getSpanOperation,\n  isEventFromBrowserJavaScriptSDK,\n  isGapSpan,\n  isOrphanSpan,\n  isOrphanTreeDepth,\n  SpanBoundsType,\n  SpanGeneratedBoundsType,\n  spanTargetHash,\n  SpanViewBoundsType,\n  unwrapTreeDepth,\n} from './utils';\n\n// TODO: maybe use babel-plugin-preval\n// for (let i = 0; i <= 1.0; i += 0.01) {\n//   INTERSECTION_THRESHOLDS.push(i);\n// }\nconst INTERSECTION_THRESHOLDS: Array<number> = [\n  0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.11, 0.12, 0.13, 0.14,\n  0.15, 0.16, 0.17, 0.18, 0.19, 0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29,\n  0.3, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4, 0.41, 0.42, 0.43, 0.44,\n  0.45, 0.46, 0.47, 0.48, 0.49, 0.5, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59,\n  0.6, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69, 0.7, 0.71, 0.72, 0.73, 0.74,\n  0.75, 0.76, 0.77, 0.78, 0.79, 0.8, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89,\n  0.9, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0,\n];\n\nexport const MARGIN_LEFT = 0;\n\ntype SpanBarProps = {\n  continuingTreeDepths: Array<TreeDepthType>;\n  event: Readonly<EventTransaction>;\n  fetchEmbeddedChildrenState: FetchEmbeddedChildrenState;\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType;\n  generateContentSpanBarRef: () => (instance: HTMLDivElement | null) => void;\n  isEmbeddedTransactionTimeAdjusted: boolean;\n  markSpanInView: (spanId: string, treeDepth: number) => void;\n  markSpanOutOfView: (spanId: string) => void;\n  numOfSpanChildren: number;\n  numOfSpans: number;\n  onWheel: (deltaX: number) => void;\n  organization: Organization;\n  showEmbeddedChildren: boolean;\n  showSpanTree: boolean;\n  span: Readonly<ProcessedSpanType>;\n  spanNumber: number;\n  storeSpanBar: (spanBar: SpanBar) => void;\n  toggleEmbeddedChildren:\n    | ((props: {eventSlug: string; orgSlug: string}) => void)\n    | undefined;\n  toggleSpanGroup: (() => void) | undefined;\n  toggleSpanTree: () => void;\n  trace: Readonly<ParsedTraceType>;\n  treeDepth: number;\n  groupOccurrence?: number;\n  groupType?: GroupType;\n  isLast?: boolean;\n  isRoot?: boolean;\n  spanBarColor?: string;\n  spanBarHatch?: boolean;\n  toggleSiblingSpanGroup?: ((span: SpanType, occurrence: number) => void) | undefined;\n};\n\ntype SpanBarState = {\n  showDetail: boolean;\n};\n\nclass SpanBar extends Component<SpanBarProps, SpanBarState> {\n  state: SpanBarState = {\n    showDetail: false,\n  };\n\n  componentDidMount() {\n    this._mounted = true;\n    if (this.spanRowDOMRef.current) {\n      this.props.storeSpanBar(this);\n      this.connectObservers();\n    }\n\n    if (this.spanTitleRef.current) {\n      this.spanTitleRef.current.addEventListener('wheel', this.handleWheel, {\n        passive: false,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this._mounted = false;\n    this.disconnectObservers();\n\n    if (this.spanTitleRef.current) {\n      this.spanTitleRef.current.removeEventListener('wheel', this.handleWheel);\n    }\n\n    const {span} = this.props;\n    if ('type' in span) {\n      return;\n    }\n\n    this.props.markSpanOutOfView(span.span_id);\n  }\n\n  spanRowDOMRef = createRef<HTMLDivElement>();\n  spanTitleRef = createRef<HTMLDivElement>();\n  intersectionObserver?: IntersectionObserver = void 0;\n  zoomLevel: number = 1; // assume initial zoomLevel is 100%\n  _mounted: boolean = false;\n\n  handleWheel = (event: WheelEvent) => {\n    // https://stackoverflow.com/q/57358640\n    // https://github.com/facebook/react/issues/14856\n    if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (Math.abs(event.deltaY) === Math.abs(event.deltaX)) {\n      return;\n    }\n\n    const {onWheel} = this.props;\n    onWheel(event.deltaX);\n  };\n\n  toggleDisplayDetail = () => {\n    this.setState(state => ({\n      showDetail: !state.showDetail,\n    }));\n  };\n\n  scrollIntoView = () => {\n    const element = this.spanRowDOMRef.current;\n    if (!element) {\n      return;\n    }\n    const boundingRect = element.getBoundingClientRect();\n    // The extra 1 pixel is necessary so that the span is recognized as in view by the IntersectionObserver\n    const offset = boundingRect.top + window.scrollY - MINIMAP_CONTAINER_HEIGHT - 1;\n    this.setState({showDetail: true}, () => window.scrollTo(0, offset));\n  };\n\n  renderDetail({\n    isVisible,\n    transactions,\n    errors,\n  }: {\n    errors: TraceError[] | null;\n    isVisible: boolean;\n    transactions: QuickTraceEvent[] | null;\n  }) {\n    const {span, organization, isRoot, trace, event} = this.props;\n\n    return (\n      <AnchorLinkManager.Consumer>\n        {({registerScrollFn, scrollToHash}) => {\n          if (!isGapSpan(span)) {\n            registerScrollFn(spanTargetHash(span.span_id), this.scrollIntoView, false);\n          }\n\n          if (!this.state.showDetail || !isVisible) {\n            return null;\n          }\n\n          return (\n            <SpanDetail\n              span={span}\n              organization={organization}\n              event={event}\n              isRoot={!!isRoot}\n              trace={trace}\n              childTransactions={transactions}\n              relatedErrors={errors}\n              scrollToHash={scrollToHash}\n            />\n          );\n        }}\n      </AnchorLinkManager.Consumer>\n    );\n  }\n\n  getBounds(): SpanViewBoundsType {\n    const {event, span, generateBounds} = this.props;\n\n    const bounds = generateBounds({\n      startTimestamp: span.start_timestamp,\n      endTimestamp: span.timestamp,\n    });\n\n    const shouldHideSpanWarnings = isEventFromBrowserJavaScriptSDK(event);\n\n    switch (bounds.type) {\n      case 'TRACE_TIMESTAMPS_EQUAL': {\n        return {\n          warning: t('Trace times are equal'),\n          left: void 0,\n          width: void 0,\n          isSpanVisibleInView: bounds.isSpanVisibleInView,\n        };\n      }\n      case 'INVALID_VIEW_WINDOW': {\n        return {\n          warning: t('Invalid view window'),\n          left: void 0,\n          width: void 0,\n          isSpanVisibleInView: bounds.isSpanVisibleInView,\n        };\n      }\n      case 'TIMESTAMPS_EQUAL': {\n        const warning =\n          shouldHideSpanWarnings &&\n          'op' in span &&\n          span.op &&\n          durationlessBrowserOps.includes(span.op)\n            ? void 0\n            : t('Equal start and end times');\n        return {\n          warning,\n          left: bounds.start,\n          width: 0.00001,\n          isSpanVisibleInView: bounds.isSpanVisibleInView,\n        };\n      }\n      case 'TIMESTAMPS_REVERSED': {\n        return {\n          warning: t('Reversed start and end times'),\n          left: bounds.start,\n          width: bounds.end - bounds.start,\n          isSpanVisibleInView: bounds.isSpanVisibleInView,\n        };\n      }\n      case 'TIMESTAMPS_STABLE': {\n        return {\n          warning: void 0,\n          left: bounds.start,\n          width: bounds.end - bounds.start,\n          isSpanVisibleInView: bounds.isSpanVisibleInView,\n        };\n      }\n      default: {\n        const _exhaustiveCheck: never = bounds;\n        return _exhaustiveCheck;\n      }\n    }\n  }\n\n  renderMeasurements() {\n    const {event, generateBounds} = this.props;\n\n    if (this.state.showDetail) {\n      return null;\n    }\n\n    const measurements = getMeasurements(event, generateBounds);\n\n    return (\n      <Fragment>\n        {Array.from(measurements.values()).map(verticalMark => {\n          const mark = Object.values(verticalMark.marks)[0];\n          const {timestamp} = mark;\n          const bounds = getMeasurementBounds(timestamp, generateBounds);\n\n          const shouldDisplay = defined(bounds.left) && defined(bounds.width);\n\n          if (!shouldDisplay || !bounds.isSpanVisibleInView) {\n            return null;\n          }\n\n          return (\n            <MeasurementMarker\n              key={String(timestamp)}\n              style={{\n                left: `clamp(0%, ${toPercent(bounds.left || 0)}, calc(100% - 1px))`,\n              }}\n              failedThreshold={verticalMark.failedThreshold}\n            />\n          );\n        })}\n      </Fragment>\n    );\n  }\n\n  renderSpanTreeConnector({hasToggler}: {hasToggler: boolean}) {\n    const {\n      isLast,\n      isRoot,\n      treeDepth: spanTreeDepth,\n      continuingTreeDepths,\n      span,\n      showSpanTree,\n    } = this.props;\n\n    const spanID = getSpanID(span);\n\n    if (isRoot) {\n      if (hasToggler) {\n        return (\n          <ConnectorBar\n            style={{right: '15px', height: '10px', bottom: '-5px', top: 'auto'}}\n            key={`${spanID}-last`}\n            orphanBranch={false}\n          />\n        );\n      }\n\n      return null;\n    }\n\n    const connectorBars: Array<React.ReactNode> = continuingTreeDepths.map(treeDepth => {\n      const depth: number = unwrapTreeDepth(treeDepth);\n\n      if (depth === 0) {\n        // do not render a connector bar at depth 0,\n        // if we did render a connector bar, this bar would be placed at depth -1\n        // which does not exist.\n        return null;\n      }\n      const left = ((spanTreeDepth - depth) * (TOGGLE_BORDER_BOX / 2) + 2) * -1;\n\n      return (\n        <ConnectorBar\n          style={{left}}\n          key={`${spanID}-${depth}`}\n          orphanBranch={isOrphanTreeDepth(treeDepth)}\n        />\n      );\n    });\n\n    if (hasToggler && showSpanTree) {\n      // if there is a toggle button, we add a connector bar to create an attachment\n      // between the toggle button and any connector bars below the toggle button\n      connectorBars.push(\n        <ConnectorBar\n          style={{\n            right: '15px',\n            height: `${ROW_HEIGHT / 2}px`,\n            bottom: isLast ? `-${ROW_HEIGHT / 2 + 2}px` : '0',\n            top: 'auto',\n          }}\n          key={`${spanID}-last-bottom`}\n          orphanBranch={false}\n        />\n      );\n    }\n\n    return (\n      <TreeConnector\n        isLast={isLast}\n        hasToggler={hasToggler}\n        orphanBranch={isOrphanSpan(span)}\n      >\n        {connectorBars}\n      </TreeConnector>\n    );\n  }\n\n  renderSpanTreeToggler({left, errored}: {errored: boolean; left: number}) {\n    const {numOfSpanChildren, isRoot, showSpanTree} = this.props;\n\n    const chevron = <TreeToggleIcon direction={showSpanTree ? 'up' : 'down'} />;\n\n    if (numOfSpanChildren <= 0) {\n      return (\n        <TreeToggleContainer style={{left: `${left}px`}}>\n          {this.renderSpanTreeConnector({hasToggler: false})}\n        </TreeToggleContainer>\n      );\n    }\n\n    const chevronElement = !isRoot ? <div>{chevron}</div> : null;\n\n    return (\n      <TreeToggleContainer style={{left: `${left}px`}} hasToggler>\n        {this.renderSpanTreeConnector({hasToggler: true})}\n        <TreeToggle\n          disabled={!!isRoot}\n          isExpanded={showSpanTree}\n          errored={errored}\n          onClick={event => {\n            event.stopPropagation();\n\n            if (isRoot) {\n              return;\n            }\n\n            this.props.toggleSpanTree();\n          }}\n        >\n          <Count value={numOfSpanChildren} />\n          {chevronElement}\n        </TreeToggle>\n      </TreeToggleContainer>\n    );\n  }\n\n  renderTitle(errors: TraceError[] | null) {\n    const {generateContentSpanBarRef} = this.props;\n    const {\n      span,\n      treeDepth,\n      groupOccurrence,\n      toggleSpanGroup,\n      toggleSiblingSpanGroup,\n      groupType,\n    } = this.props;\n\n    let titleFragments: React.ReactNode[] = [];\n\n    if (\n      typeof toggleSpanGroup === 'function' ||\n      typeof toggleSiblingSpanGroup === 'function'\n    ) {\n      titleFragments.push(\n        <Regroup\n          onClick={event => {\n            event.stopPropagation();\n            event.preventDefault();\n            if (groupType === GroupType.SIBLINGS && 'op' in span) {\n              toggleSiblingSpanGroup?.(span, groupOccurrence ?? 0);\n            } else {\n              toggleSpanGroup && toggleSpanGroup();\n            }\n          }}\n        >\n          <a\n            href=\"#regroup\"\n            onClick={event => {\n              event.preventDefault();\n            }}\n          >\n            {t('Regroup')}\n          </a>\n        </Regroup>\n      );\n    }\n\n    const spanOperationName = getSpanOperation(span);\n    if (spanOperationName) {\n      titleFragments.push(spanOperationName);\n    }\n\n    titleFragments = titleFragments.flatMap(current => [current, ' \\u2014 ']);\n\n    const description = span?.description ?? getSpanID(span);\n\n    const left = treeDepth * (TOGGLE_BORDER_BOX / 2) + MARGIN_LEFT;\n    const errored = Boolean(errors && errors.length > 0);\n\n    return (\n      <RowTitleContainer\n        data-debug-id=\"SpanBarTitleContainer\"\n        ref={generateContentSpanBarRef()}\n      >\n        {this.renderSpanTreeToggler({left, errored})}\n        <RowTitle\n          style={{\n            left: `${left}px`,\n            width: '100%',\n          }}\n        >\n          <RowTitleContent errored={errored}>\n            <strong>{titleFragments}</strong>\n            {description}\n          </RowTitleContent>\n        </RowTitle>\n      </RowTitleContainer>\n    );\n  }\n\n  connectObservers() {\n    if (!this.spanRowDOMRef.current) {\n      return;\n    }\n\n    this.disconnectObservers();\n\n    /**\n\n    We track intersections events between the span bar's DOM element\n    and the viewport's (root) intersection area. the intersection area is sized to\n    exclude the minimap. See below.\n\n    By default, the intersection observer's root intersection is the viewport.\n    We adjust the margins of this root intersection area to exclude the minimap's\n    height. The minimap's height is always fixed.\n\n      VIEWPORT (ancestor element used for the intersection events)\n    +--+-------------------------+--+\n    |  |                         |  |\n    |  |       MINIMAP           |  |\n    |  |                         |  |\n    |  +-------------------------+  |  ^\n    |  |                         |  |  |\n    |  |       SPANS             |  |  | ROOT\n    |  |                         |  |  | INTERSECTION\n    |  |                         |  |  | OBSERVER\n    |  |                         |  |  | HEIGHT\n    |  |                         |  |  |\n    |  |                         |  |  |\n    |  |                         |  |  |\n    |  +-------------------------+  |  |\n    |                               |  |\n    +-------------------------------+  v\n\n     */\n\n    this.intersectionObserver = new IntersectionObserver(\n      entries =>\n        entries.forEach(entry => {\n          if (!this._mounted) {\n            return;\n          }\n\n          const shouldMoveMinimap = this.props.numOfSpans > NUM_OF_SPANS_FIT_IN_MINI_MAP;\n\n          if (!shouldMoveMinimap) {\n            return;\n          }\n          const spanNumber = this.props.spanNumber;\n\n          const minimapSlider = document.getElementById('minimap-background-slider');\n\n          if (!minimapSlider) {\n            return;\n          }\n\n          // NOTE: THIS IS HACKY.\n          //\n          // IntersectionObserver.rootMargin is un-affected by the browser's zoom level.\n          // The margins of the intersection area needs to be adjusted.\n          // Thus, IntersectionObserverEntry.rootBounds may not be what we expect.\n          //\n          // We address this below.\n          //\n          // Note that this function was called whenever an intersection event occurred wrt\n          // the thresholds.\n          //\n          if (entry.rootBounds) {\n            // After we create the IntersectionObserver instance with rootMargin set as:\n            // -${MINIMAP_CONTAINER_HEIGHT * this.zoomLevel}px 0px 0px 0px\n            //\n            // we can introspect the rootBounds to infer the zoomlevel.\n            //\n            // we always expect entry.rootBounds.top to equal MINIMAP_CONTAINER_HEIGHT\n\n            const actualRootTop = Math.ceil(entry.rootBounds.top);\n\n            if (actualRootTop !== MINIMAP_CONTAINER_HEIGHT && actualRootTop > 0) {\n              // we revert the actualRootTop value by the current zoomLevel factor\n              const normalizedActualTop = actualRootTop / this.zoomLevel;\n\n              const zoomLevel = MINIMAP_CONTAINER_HEIGHT / normalizedActualTop;\n              this.zoomLevel = zoomLevel;\n\n              // we reconnect the observers; the callback functions may be invoked\n              this.connectObservers();\n\n              // NOTE: since we cannot guarantee that the callback function is invoked on\n              //       the newly connected observers, we continue running this function.\n            }\n          }\n\n          // root refers to the root intersection rectangle used for the IntersectionObserver\n          const rectRelativeToRoot = entry.boundingClientRect as DOMRect;\n\n          const bottomYCoord = rectRelativeToRoot.y + rectRelativeToRoot.height;\n\n          // refers to if the rect is out of view from the viewport\n          const isOutOfViewAbove = rectRelativeToRoot.y < 0 && bottomYCoord < 0;\n\n          if (isOutOfViewAbove) {\n            return;\n          }\n\n          const relativeToMinimap = {\n            top: rectRelativeToRoot.y - MINIMAP_CONTAINER_HEIGHT,\n            bottom: bottomYCoord - MINIMAP_CONTAINER_HEIGHT,\n          };\n\n          const rectBelowMinimap =\n            relativeToMinimap.top > 0 && relativeToMinimap.bottom > 0;\n\n          if (rectBelowMinimap) {\n            const {span, treeDepth, organization} = this.props;\n            if ('type' in span) {\n              return;\n            }\n\n            // TODO: Remove this check when this feature is GA'd\n            if (organization.features.includes('performance-span-tree-autoscroll')) {\n              // If isIntersecting is false, this means the span is out of view below the viewport\n              if (!entry.isIntersecting) {\n                this.props.markSpanOutOfView(span.span_id);\n              } else {\n                this.props.markSpanInView(span.span_id, treeDepth);\n              }\n            }\n\n            // if the first span is below the minimap, we scroll the minimap\n            // to the top. this addresses spurious scrolling to the top of the page\n            if (spanNumber <= 1) {\n              minimapSlider.style.top = '0px';\n              return;\n            }\n            return;\n          }\n\n          const inAndAboveMinimap = relativeToMinimap.bottom <= 0;\n\n          if (inAndAboveMinimap) {\n            const {span, organization} = this.props;\n            if ('type' in span) {\n              return;\n            }\n\n            // TODO: Remove this check when this feature is GA'd\n            if (organization.features.includes('performance-span-tree-autoscroll')) {\n              this.props.markSpanOutOfView(span.span_id);\n            }\n\n            return;\n          }\n\n          // invariant: spanNumber >= 1\n\n          const numberOfMovedSpans = spanNumber - 1;\n          const totalHeightOfHiddenSpans = numberOfMovedSpans * MINIMAP_SPAN_BAR_HEIGHT;\n          const currentSpanHiddenRatio = 1 - entry.intersectionRatio;\n\n          const panYPixels =\n            totalHeightOfHiddenSpans + currentSpanHiddenRatio * MINIMAP_SPAN_BAR_HEIGHT;\n\n          // invariant: this.props.numOfSpans - spanNumberToStopMoving + 1 = NUM_OF_SPANS_FIT_IN_MINI_MAP\n\n          const spanNumberToStopMoving =\n            this.props.numOfSpans + 1 - NUM_OF_SPANS_FIT_IN_MINI_MAP;\n\n          if (spanNumber > spanNumberToStopMoving) {\n            // if the last span bar appears on the minimap, we do not want the minimap\n            // to keep panning upwards\n            minimapSlider.style.top = `-${\n              spanNumberToStopMoving * MINIMAP_SPAN_BAR_HEIGHT\n            }px`;\n            return;\n          }\n\n          minimapSlider.style.top = `-${panYPixels}px`;\n        }),\n      {\n        threshold: INTERSECTION_THRESHOLDS,\n        rootMargin: `-${MINIMAP_CONTAINER_HEIGHT * this.zoomLevel}px 0px 0px 0px`,\n      }\n    );\n\n    this.intersectionObserver.observe(this.spanRowDOMRef.current);\n  }\n\n  disconnectObservers() {\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n    }\n  }\n\n  renderDivider(\n    dividerHandlerChildrenProps: DividerHandlerManager.DividerHandlerManagerChildrenProps\n  ) {\n    if (this.state.showDetail) {\n      // Mock component to preserve layout spacing\n      return (\n        <DividerLine\n          showDetail\n          style={{\n            position: 'absolute',\n          }}\n        />\n      );\n    }\n\n    const {addDividerLineRef} = dividerHandlerChildrenProps;\n\n    return (\n      <DividerLine\n        ref={addDividerLineRef()}\n        style={{\n          position: 'absolute',\n        }}\n        onMouseEnter={() => {\n          dividerHandlerChildrenProps.setHover(true);\n        }}\n        onMouseLeave={() => {\n          dividerHandlerChildrenProps.setHover(false);\n        }}\n        onMouseOver={() => {\n          dividerHandlerChildrenProps.setHover(true);\n        }}\n        onMouseDown={dividerHandlerChildrenProps.onDragStart}\n        onClick={event => {\n          // we prevent the propagation of the clicks from this component to prevent\n          // the span detail from being opened.\n          event.stopPropagation();\n        }}\n      />\n    );\n  }\n\n  getRelatedErrors(quickTrace: QuickTraceContextChildrenProps): TraceError[] | null {\n    if (!quickTrace) {\n      return null;\n    }\n\n    const {span} = this.props;\n    const {currentEvent} = quickTrace;\n\n    if (isGapSpan(span) || !currentEvent || !isTraceFull(currentEvent)) {\n      return null;\n    }\n\n    return currentEvent.errors.filter(error => error.span === span.span_id);\n  }\n\n  getChildTransactions(\n    quickTrace: QuickTraceContextChildrenProps\n  ): QuickTraceEvent[] | null {\n    if (!quickTrace) {\n      return null;\n    }\n\n    const {span} = this.props;\n    const {trace} = quickTrace;\n\n    if (isGapSpan(span) || !trace) {\n      return null;\n    }\n\n    return trace.filter(({parent_span_id}) => parent_span_id === span.span_id);\n  }\n\n  renderErrorBadge(errors: TraceError[] | null): React.ReactNode {\n    return errors?.length ? <ErrorBadge /> : null;\n  }\n\n  renderEmbeddedTransactionsBadge(\n    transactions: QuickTraceEvent[] | null\n  ): React.ReactNode {\n    const {toggleEmbeddedChildren, organization, showEmbeddedChildren} = this.props;\n\n    if (!organization.features.includes('unified-span-view')) {\n      return null;\n    }\n\n    if (transactions && transactions.length === 1) {\n      const transaction = transactions[0];\n      return (\n        <Tooltip\n          title={\n            <span>\n              {showEmbeddedChildren\n                ? t('This span is showing a direct child. Remove transaction to hide')\n                : t('This span has a direct child. Add transaction to view')}\n            </span>\n          }\n          position=\"top\"\n          containerDisplayMode=\"block\"\n        >\n          <EmbeddedTransactionBadge\n            expanded={showEmbeddedChildren}\n            onClick={() => {\n              if (toggleEmbeddedChildren) {\n                if (showEmbeddedChildren) {\n                  trackAnalyticsEvent({\n                    eventKey: 'span_view.embedded_child.hide',\n                    eventName: 'Span View: Hide Embedded Transaction',\n                    organization_id: parseInt(organization.id, 10),\n                  });\n                } else {\n                  trackAnalyticsEvent({\n                    eventKey: 'span_view.embedded_child.show',\n                    eventName: 'Span View: Show Embedded Transaction',\n                    organization_id: parseInt(organization.id, 10),\n                  });\n                }\n\n                toggleEmbeddedChildren({\n                  orgSlug: organization.slug,\n                  eventSlug: generateEventSlug({\n                    id: transaction.event_id,\n                    project: transaction.project_slug,\n                  }),\n                });\n              }\n            }}\n          />\n        </Tooltip>\n      );\n    }\n    return null;\n  }\n\n  renderWarningText() {\n    let warningText = this.getBounds().warning;\n\n    if (this.props.isEmbeddedTransactionTimeAdjusted) {\n      const embeddedWarningText = t(\n        'All child span timestamps have been adjusted to account for mismatched client and server clocks.'\n      );\n\n      warningText = warningText\n        ? `${warningText}. ${embeddedWarningText}`\n        : embeddedWarningText;\n    }\n\n    if (!warningText) {\n      return null;\n    }\n\n    return (\n      <Tooltip containerDisplayMode=\"flex\" title={warningText}>\n        <StyledIconWarning size=\"xs\" />\n      </Tooltip>\n    );\n  }\n\n  renderHeader({\n    dividerHandlerChildrenProps,\n    errors,\n    transactions,\n  }: {\n    dividerHandlerChildrenProps: DividerHandlerManager.DividerHandlerManagerChildrenProps;\n    errors: TraceError[] | null;\n    transactions: QuickTraceEvent[] | null;\n  }) {\n    const {span, spanBarColor, spanBarHatch, spanNumber} = this.props;\n    const startTimestamp: number = span.start_timestamp;\n    const endTimestamp: number = span.timestamp;\n    const duration = Math.abs(endTimestamp - startTimestamp);\n    const durationString = getHumanDuration(duration);\n    const bounds = this.getBounds();\n    const {dividerPosition, addGhostDividerLineRef} = dividerHandlerChildrenProps;\n    const displaySpanBar = defined(bounds.left) && defined(bounds.width);\n    const durationDisplay = getDurationDisplay(bounds);\n\n    return (\n      <RowCellContainer showDetail={this.state.showDetail}>\n        <RowCell\n          data-type=\"span-row-cell\"\n          showDetail={this.state.showDetail}\n          style={{\n            width: `calc(${toPercent(dividerPosition)} - 0.5px)`,\n            paddingTop: 0,\n          }}\n          onClick={() => {\n            this.toggleDisplayDetail();\n          }}\n          ref={this.spanTitleRef}\n        >\n          {this.renderTitle(errors)}\n        </RowCell>\n        <DividerContainer>\n          {this.renderDivider(dividerHandlerChildrenProps)}\n          {this.renderErrorBadge(errors)}\n          {this.renderEmbeddedTransactionsBadge(transactions)}\n        </DividerContainer>\n        <RowCell\n          data-type=\"span-row-cell\"\n          showDetail={this.state.showDetail}\n          showStriping={spanNumber % 2 !== 0}\n          style={{\n            width: `calc(${toPercent(1 - dividerPosition)} - 0.5px)`,\n          }}\n          onClick={() => {\n            this.toggleDisplayDetail();\n          }}\n        >\n          {displaySpanBar && (\n            <RowRectangle\n              spanBarHatch={!!spanBarHatch}\n              style={{\n                backgroundColor: spanBarColor,\n                left: `min(${toPercent(bounds.left || 0)}, calc(100% - 1px))`,\n                width: toPercent(bounds.width || 0),\n              }}\n            >\n              <DurationPill\n                durationDisplay={durationDisplay}\n                showDetail={this.state.showDetail}\n                spanBarHatch={!!spanBarHatch}\n              >\n                {durationString}\n                {this.renderWarningText()}\n              </DurationPill>\n            </RowRectangle>\n          )}\n          {this.renderMeasurements()}\n          <SpanBarCursorGuide />\n        </RowCell>\n        {!this.state.showDetail && (\n          <DividerLineGhostContainer\n            style={{\n              width: `calc(${toPercent(dividerPosition)} + 0.5px)`,\n              display: 'none',\n            }}\n          >\n            <DividerLine\n              ref={addGhostDividerLineRef()}\n              style={{\n                right: 0,\n              }}\n              className=\"hovering\"\n              onClick={event => {\n                // the ghost divider line should not be interactive.\n                // we prevent the propagation of the clicks from this component to prevent\n                // the span detail from being opened.\n                event.stopPropagation();\n              }}\n            />\n          </DividerLineGhostContainer>\n        )}\n      </RowCellContainer>\n    );\n  }\n\n  renderEmbeddedChildrenState() {\n    const {fetchEmbeddedChildrenState} = this.props;\n\n    switch (fetchEmbeddedChildrenState) {\n      case 'loading_embedded_transactions': {\n        return (\n          <MessageRow>\n            <span>{t('Loading embedded transaction')}</span>\n          </MessageRow>\n        );\n      }\n      case 'error_fetching_embedded_transactions': {\n        return (\n          <MessageRow>\n            <span>{t('Error loading embedded transaction')}</span>\n          </MessageRow>\n        );\n      }\n      default:\n        return null;\n    }\n  }\n\n  render() {\n    const {spanNumber} = this.props;\n    const bounds = this.getBounds();\n    const {isSpanVisibleInView} = bounds;\n\n    return (\n      <Fragment>\n        <Row\n          ref={this.spanRowDOMRef}\n          visible={isSpanVisibleInView}\n          showBorder={this.state.showDetail}\n          data-test-id={`span-row-${spanNumber}`}\n        >\n          <QuickTraceContext.Consumer>\n            {quickTrace => {\n              const errors = this.getRelatedErrors(quickTrace);\n              const transactions = this.getChildTransactions(quickTrace);\n              return (\n                <Fragment>\n                  <DividerHandlerManager.Consumer>\n                    {(\n                      dividerHandlerChildrenProps: DividerHandlerManager.DividerHandlerManagerChildrenProps\n                    ) =>\n                      this.renderHeader({\n                        dividerHandlerChildrenProps,\n                        errors,\n                        transactions,\n                      })\n                    }\n                  </DividerHandlerManager.Consumer>\n\n                  {this.renderDetail({\n                    isVisible: isSpanVisibleInView,\n                    transactions,\n                    errors,\n                  })}\n                </Fragment>\n              );\n            }}\n          </QuickTraceContext.Consumer>\n        </Row>\n        {this.renderEmbeddedChildrenState()}\n      </Fragment>\n    );\n  }\n}\n\nconst StyledIconWarning = styled(IconWarning)`\n  margin-left: ${space(0.25)};\n  margin-bottom: ${space(0.25)};\n`;\n\nconst Regroup = styled('span')``;\n\nexport default SpanBar;\n","import {Fragment, LegacyRef, useEffect, useRef} from 'react';\n\nimport Count from 'sentry/components/count';\nimport {\n  Row,\n  RowCell,\n  RowCellContainer,\n} from 'sentry/components/performance/waterfall/row';\nimport {\n  DividerContainer,\n  DividerLine,\n  DividerLineGhostContainer,\n} from 'sentry/components/performance/waterfall/rowDivider';\nimport {\n  RowTitle,\n  RowTitleContainer,\n  SpanGroupRowTitleContent,\n} from 'sentry/components/performance/waterfall/rowTitle';\nimport {\n  TOGGLE_BORDER_BOX,\n  TreeToggle,\n  TreeToggleContainer,\n} from 'sentry/components/performance/waterfall/treeConnector';\nimport {toPercent} from 'sentry/components/performance/waterfall/utils';\nimport {EventTransaction} from 'sentry/types/event';\nimport {defined} from 'sentry/utils';\n\nimport * as AnchorLinkManager from './anchorLinkManager';\nimport * as DividerHandlerManager from './dividerHandlerManager';\nimport SpanBarCursorGuide from './spanBarCursorGuide';\nimport {MeasurementMarker} from './styles';\nimport {EnhancedSpan, ProcessedSpanType} from './types';\nimport {\n  getMeasurementBounds,\n  getMeasurements,\n  SpanBoundsType,\n  SpanGeneratedBoundsType,\n  spanTargetHash,\n} from './utils';\n\nconst MARGIN_LEFT = 0;\n\ntype Props = {\n  event: Readonly<EventTransaction>;\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType;\n  generateContentSpanBarRef: () => (instance: HTMLDivElement | null) => void;\n  onWheel: (deltaX: number) => void;\n  renderGroupSpansTitle: () => React.ReactNode;\n  renderSpanRectangles: () => React.ReactNode;\n  renderSpanTreeConnector: () => React.ReactNode;\n  span: Readonly<ProcessedSpanType>;\n  spanGrouping: EnhancedSpan[];\n  spanNumber: number;\n  toggleSpanGroup: () => void;\n  treeDepth: number;\n};\n\nfunction renderGroupedSpansToggler(props: Props) {\n  const {treeDepth, spanGrouping, renderSpanTreeConnector, toggleSpanGroup} = props;\n\n  const left = treeDepth * (TOGGLE_BORDER_BOX / 2) + MARGIN_LEFT;\n\n  return (\n    <TreeToggleContainer style={{left: `${left}px`}} hasToggler>\n      {renderSpanTreeConnector()}\n      <TreeToggle\n        disabled={false}\n        isExpanded={false}\n        errored={false}\n        isSpanGroupToggler\n        onClick={event => {\n          event.stopPropagation();\n          toggleSpanGroup();\n        }}\n      >\n        <Count value={spanGrouping.length} />\n      </TreeToggle>\n    </TreeToggleContainer>\n  );\n}\n\nfunction renderDivider(\n  dividerHandlerChildrenProps: DividerHandlerManager.DividerHandlerManagerChildrenProps\n) {\n  const {addDividerLineRef} = dividerHandlerChildrenProps;\n\n  return (\n    <DividerLine\n      ref={addDividerLineRef()}\n      style={{\n        position: 'absolute',\n      }}\n      onMouseEnter={() => {\n        dividerHandlerChildrenProps.setHover(true);\n      }}\n      onMouseLeave={() => {\n        dividerHandlerChildrenProps.setHover(false);\n      }}\n      onMouseOver={() => {\n        dividerHandlerChildrenProps.setHover(true);\n      }}\n      onMouseDown={dividerHandlerChildrenProps.onDragStart}\n      onClick={event => {\n        // we prevent the propagation of the clicks from this component to prevent\n        // the span detail from being opened.\n        event.stopPropagation();\n      }}\n    />\n  );\n}\n\nfunction renderMeasurements(\n  event: Readonly<EventTransaction>,\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n) {\n  const measurements = getMeasurements(event, generateBounds);\n\n  return (\n    <Fragment>\n      {Array.from(measurements).map(([timestamp, verticalMark]) => {\n        const bounds = getMeasurementBounds(timestamp, generateBounds);\n\n        const shouldDisplay = defined(bounds.left) && defined(bounds.width);\n\n        if (!shouldDisplay || !bounds.isSpanVisibleInView) {\n          return null;\n        }\n\n        return (\n          <MeasurementMarker\n            key={String(timestamp)}\n            style={{\n              left: `clamp(0%, ${toPercent(bounds.left || 0)}, calc(100% - 1px))`,\n            }}\n            failedThreshold={verticalMark.failedThreshold}\n          />\n        );\n      })}\n    </Fragment>\n  );\n}\n\nexport function SpanGroupBar(props: Props) {\n  const spanTitleRef: LegacyRef<HTMLDivElement> | null = useRef(null);\n  const {onWheel} = props;\n\n  useEffect(() => {\n    const currentRef = spanTitleRef.current;\n    const handleWheel = (event: WheelEvent) => {\n      if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (Math.abs(event.deltaY) === Math.abs(event.deltaX)) {\n        return;\n      }\n\n      onWheel(event.deltaX);\n    };\n\n    if (currentRef) {\n      currentRef.addEventListener('wheel', handleWheel, {\n        passive: false,\n      });\n    }\n\n    return () => {\n      if (currentRef) {\n        currentRef.removeEventListener('wheel', handleWheel);\n      }\n    };\n  }, [onWheel]);\n\n  return (\n    <DividerHandlerManager.Consumer>\n      {(\n        dividerHandlerChildrenProps: DividerHandlerManager.DividerHandlerManagerChildrenProps\n      ) => {\n        const {\n          generateBounds,\n          toggleSpanGroup,\n          span,\n          treeDepth,\n          spanNumber,\n          event,\n          spanGrouping,\n        } = props;\n\n        const {isSpanVisibleInView: isSpanVisible} = generateBounds({\n          startTimestamp: span.start_timestamp,\n          endTimestamp: span.timestamp,\n        });\n\n        const {dividerPosition, addGhostDividerLineRef} = dividerHandlerChildrenProps;\n        const {generateContentSpanBarRef} = props;\n        const left = treeDepth * (TOGGLE_BORDER_BOX / 2) + MARGIN_LEFT;\n\n        return (\n          <AnchorLinkManager.Consumer>\n            {({registerScrollFn}) => {\n              spanGrouping.forEach(spanObj => {\n                registerScrollFn(\n                  spanTargetHash(spanObj.span.span_id),\n                  toggleSpanGroup,\n                  true\n                );\n              });\n              return (\n                <Row\n                  visible={isSpanVisible}\n                  showBorder={false}\n                  data-test-id={`span-row-${spanNumber}`}\n                >\n                  <RowCellContainer>\n                    <RowCell\n                      data-type=\"span-row-cell\"\n                      style={{\n                        width: `calc(${toPercent(dividerPosition)} - 0.5px)`,\n                        paddingTop: 0,\n                      }}\n                      onClick={() => props.toggleSpanGroup()}\n                      ref={spanTitleRef}\n                    >\n                      <RowTitleContainer ref={generateContentSpanBarRef()}>\n                        {renderGroupedSpansToggler(props)}\n                        <RowTitle\n                          style={{\n                            left: `${left}px`,\n                            width: '100%',\n                          }}\n                        >\n                          <SpanGroupRowTitleContent>\n                            {props.renderGroupSpansTitle()}\n                          </SpanGroupRowTitleContent>\n                        </RowTitle>\n                      </RowTitleContainer>\n                    </RowCell>\n                    <DividerContainer>\n                      {renderDivider(dividerHandlerChildrenProps)}\n                    </DividerContainer>\n                    <RowCell\n                      data-type=\"span-row-cell\"\n                      showStriping={spanNumber % 2 !== 0}\n                      style={{\n                        width: `calc(${toPercent(1 - dividerPosition)} - 0.5px)`,\n                      }}\n                      onClick={() => props.toggleSpanGroup()}\n                    >\n                      {props.renderSpanRectangles()}\n                      {renderMeasurements(event, generateBounds)}\n                      <SpanBarCursorGuide />\n                    </RowCell>\n                    <DividerLineGhostContainer\n                      style={{\n                        width: `calc(${toPercent(dividerPosition)} + 0.5px)`,\n                        display: 'none',\n                      }}\n                    >\n                      <DividerLine\n                        ref={addGhostDividerLineRef()}\n                        style={{\n                          right: 0,\n                        }}\n                        className=\"hovering\"\n                        onClick={e => {\n                          // the ghost divider line should not be interactive.\n                          // we prevent the propagation of the clicks from this component to prevent\n                          // the span detail from being opened.\n                          e.stopPropagation();\n                        }}\n                      />\n                    </DividerLineGhostContainer>\n                  </RowCellContainer>\n                </Row>\n              );\n            }}\n          </AnchorLinkManager.Consumer>\n        );\n      }}\n    </DividerHandlerManager.Consumer>\n  );\n}\n","import countBy from 'lodash/countBy';\n\nimport {ROW_HEIGHT} from 'sentry/components/performance/waterfall/constants';\nimport {DurationPill, RowRectangle} from 'sentry/components/performance/waterfall/rowBar';\nimport {\n  ConnectorBar,\n  TOGGLE_BORDER_BOX,\n  TreeConnector,\n} from 'sentry/components/performance/waterfall/treeConnector';\nimport {\n  getDurationDisplay,\n  getHumanDuration,\n  toPercent,\n} from 'sentry/components/performance/waterfall/utils';\nimport {t} from 'sentry/locale';\nimport {EventTransaction} from 'sentry/types/event';\nimport theme from 'sentry/utils/theme';\n\nimport {SpanGroupBar} from './spanGroupBar';\nimport {EnhancedSpan, ProcessedSpanType, TreeDepthType} from './types';\nimport {\n  getSpanGroupBounds,\n  getSpanGroupTimestamps,\n  getSpanOperation,\n  isOrphanSpan,\n  isOrphanTreeDepth,\n  SpanBoundsType,\n  SpanGeneratedBoundsType,\n  unwrapTreeDepth,\n} from './utils';\n\ntype Props = {\n  continuingTreeDepths: Array<TreeDepthType>;\n  event: Readonly<EventTransaction>;\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType;\n  generateContentSpanBarRef: () => (instance: HTMLDivElement | null) => void;\n  onWheel: (deltaX: number) => void;\n  span: Readonly<ProcessedSpanType>;\n  spanGrouping: EnhancedSpan[];\n  spanNumber: number;\n  toggleSpanGroup: () => void;\n  treeDepth: number;\n};\n\nexport function SpanDescendantGroupBar(props: Props) {\n  const {\n    continuingTreeDepths,\n    event,\n    generateBounds,\n    span,\n    spanGrouping,\n    spanNumber,\n    toggleSpanGroup,\n    onWheel,\n    generateContentSpanBarRef,\n  } = props;\n\n  function renderGroupSpansTitle() {\n    if (spanGrouping.length === 0) {\n      return '';\n    }\n\n    const operationCounts = countBy(spanGrouping, enhancedSpan =>\n      getSpanOperation(enhancedSpan.span)\n    );\n\n    const hasOthers = Object.keys(operationCounts).length > 1;\n\n    const [mostFrequentOperationName] = Object.entries(operationCounts).reduce(\n      (acc, [operationNameKey, count]) => {\n        if (count > acc[1]) {\n          return [operationNameKey, count];\n        }\n        return acc;\n      }\n    );\n\n    return (\n      <strong>{`${t('Autogrouped ')}\\u2014 ${mostFrequentOperationName}${\n        hasOthers ? t(' and more') : ''\n      }`}</strong>\n    );\n  }\n\n  function renderSpanTreeConnector() {\n    const {treeDepth: spanTreeDepth} = props;\n\n    const connectorBars: Array<React.ReactNode> = continuingTreeDepths.map(treeDepth => {\n      const depth: number = unwrapTreeDepth(treeDepth);\n\n      if (depth === 0) {\n        // do not render a connector bar at depth 0,\n        // if we did render a connector bar, this bar would be placed at depth -1\n        // which does not exist.\n        return null;\n      }\n      const left = ((spanTreeDepth - depth) * (TOGGLE_BORDER_BOX / 2) + 2) * -1;\n\n      return (\n        <ConnectorBar\n          style={{left}}\n          key={`span-group-${depth}`}\n          orphanBranch={isOrphanTreeDepth(treeDepth)}\n        />\n      );\n    });\n\n    connectorBars.push(\n      <ConnectorBar\n        style={{\n          right: '15px',\n          height: `${ROW_HEIGHT / 2}px`,\n          bottom: `-${ROW_HEIGHT / 2 + 1}px`,\n          top: 'auto',\n        }}\n        key=\"collapsed-span-group-row-bottom\"\n        orphanBranch={false}\n      />\n    );\n\n    return (\n      <TreeConnector isLast hasToggler orphanBranch={isOrphanSpan(span)}>\n        {connectorBars}\n      </TreeConnector>\n    );\n  }\n\n  function renderSpanRectangles() {\n    const bounds = getSpanGroupBounds(spanGrouping, generateBounds);\n    const durationDisplay = getDurationDisplay(bounds);\n    const {startTimestamp, endTimestamp} = getSpanGroupTimestamps(spanGrouping);\n    const duration = Math.abs(endTimestamp - startTimestamp);\n    const durationString = getHumanDuration(duration);\n\n    return (\n      <RowRectangle\n        spanBarHatch={false}\n        style={{\n          backgroundColor: theme.blue300,\n          left: `min(${toPercent(bounds.left || 0)}, calc(100% - 1px))`,\n          width: toPercent(bounds.width || 0),\n        }}\n      >\n        <DurationPill\n          durationDisplay={durationDisplay}\n          showDetail={false}\n          spanBarHatch={false}\n        >\n          {durationString}\n        </DurationPill>\n      </RowRectangle>\n    );\n  }\n\n  return (\n    <SpanGroupBar\n      data-test-id=\"span-descendant-group-bar\"\n      event={event}\n      span={span}\n      spanGrouping={spanGrouping}\n      treeDepth={props.treeDepth}\n      spanNumber={spanNumber}\n      generateBounds={generateBounds}\n      toggleSpanGroup={toggleSpanGroup}\n      renderSpanTreeConnector={renderSpanTreeConnector}\n      renderGroupSpansTitle={renderGroupSpansTitle}\n      renderSpanRectangles={renderSpanRectangles}\n      onWheel={onWheel}\n      generateContentSpanBarRef={generateContentSpanBarRef}\n    />\n  );\n}\n","import {RowRectangle} from 'sentry/components/performance/waterfall/rowBar';\nimport {toPercent} from 'sentry/components/performance/waterfall/utils';\nimport theme from 'sentry/utils/theme';\n\nimport {EnhancedSpan} from './types';\nimport {SpanViewBoundsType} from './utils';\n\nexport default function SpanRectangle({\n  bounds,\n}: {\n  bounds: SpanViewBoundsType;\n  spanGrouping: EnhancedSpan[];\n}) {\n  return (\n    <RowRectangle\n      spanBarHatch={false}\n      style={{\n        backgroundColor: theme.blue300,\n        left: `min(${toPercent(bounds.left || 0)}, calc(100% - 1px))`,\n        width: toPercent(bounds.width || 0),\n      }}\n    />\n  );\n}\n","import {DurationPill, RowRectangle} from 'sentry/components/performance/waterfall/rowBar';\nimport {\n  getDurationDisplay,\n  getHumanDuration,\n  toPercent,\n} from 'sentry/components/performance/waterfall/utils';\n\nimport {EnhancedSpan} from './types';\nimport {getSpanGroupTimestamps, SpanViewBoundsType} from './utils';\n\nexport function SpanRectangleOverlay({\n  bounds,\n  spanGrouping,\n}: {\n  bounds: SpanViewBoundsType;\n  spanGrouping: EnhancedSpan[];\n}) {\n  const {startTimestamp, endTimestamp} = getSpanGroupTimestamps(spanGrouping);\n  const duration = Math.abs(endTimestamp - startTimestamp);\n  const durationDisplay = getDurationDisplay(bounds);\n  const durationString = getHumanDuration(duration);\n\n  return (\n    <RowRectangle\n      spanBarHatch={false}\n      style={{\n        left: `min(${toPercent(bounds.left || 0)}, calc(100% - 1px))`,\n        width: toPercent(bounds.width || 0),\n      }}\n    >\n      <DurationPill\n        durationDisplay={durationDisplay}\n        showDetail={false}\n        spanBarHatch={false}\n      >\n        {durationString}\n      </DurationPill>\n    </RowRectangle>\n  );\n}\n","import {Fragment} from 'react';\n\nimport {\n  ConnectorBar,\n  TOGGLE_BORDER_BOX,\n  TreeConnector,\n} from 'sentry/components/performance/waterfall/treeConnector';\nimport {t} from 'sentry/locale';\nimport {EventTransaction} from 'sentry/types/event';\n\nimport {SpanGroupBar} from './spanGroupBar';\nimport SpanRectangle from './spanRectangle';\nimport {SpanRectangleOverlay} from './spanRectangleOverlay';\nimport {EnhancedSpan, ProcessedSpanType, SpanType, TreeDepthType} from './types';\nimport {\n  getSpanGroupBounds,\n  isOrphanSpan,\n  isOrphanTreeDepth,\n  SpanBoundsType,\n  SpanGeneratedBoundsType,\n  unwrapTreeDepth,\n} from './utils';\n\ntype Props = {\n  continuingTreeDepths: Array<TreeDepthType>;\n  event: Readonly<EventTransaction>;\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType;\n  generateContentSpanBarRef: () => (instance: HTMLDivElement | null) => void;\n  isLastSibling: boolean;\n  occurrence: number;\n  onWheel: (deltaX: number) => void;\n  span: Readonly<ProcessedSpanType>;\n  spanGrouping: EnhancedSpan[];\n  spanNumber: number;\n  toggleSiblingSpanGroup: (span: SpanType, occurrence: number) => void;\n  treeDepth: number;\n};\n\nexport default function SpanSiblingGroupBar(props: Props) {\n  const {\n    continuingTreeDepths,\n    event,\n    generateBounds,\n    isLastSibling,\n    span,\n    spanGrouping,\n    spanNumber,\n    occurrence,\n    toggleSiblingSpanGroup,\n    onWheel,\n    generateContentSpanBarRef,\n  } = props;\n\n  function renderGroupSpansTitle(): React.ReactNode {\n    if (spanGrouping.length === 0) {\n      return '';\n    }\n\n    const operation = spanGrouping[0].span.op;\n    const description = spanGrouping[0].span.description;\n\n    if (!description || !operation) {\n      if (description) {\n        return <strong>{`${t('Autogrouped')} \\u2014 ${description}`}</strong>;\n      }\n\n      if (operation) {\n        return <strong>{`${t('Autogrouped')} \\u2014 ${operation}`}</strong>;\n      }\n\n      return <strong>{`${t('Autogrouped')} \\u2014 ${t('siblings')}`}</strong>;\n    }\n\n    return (\n      <Fragment>\n        <strong>{`${t('Autogrouped')} \\u2014 ${operation} \\u2014 `}</strong>\n        {description}\n      </Fragment>\n    );\n  }\n\n  function renderSpanTreeConnector() {\n    const {treeDepth: spanTreeDepth} = props;\n\n    const connectorBars: Array<React.ReactNode> = continuingTreeDepths.map(treeDepth => {\n      const depth: number = unwrapTreeDepth(treeDepth);\n\n      if (depth === 0) {\n        // do not render a connector bar at depth 0,\n        // if we did render a connector bar, this bar would be placed at depth -1\n        // which does not exist.\n        return null;\n      }\n      const left = ((spanTreeDepth - depth) * (TOGGLE_BORDER_BOX / 2) + 2) * -1;\n\n      return (\n        <ConnectorBar\n          style={{left}}\n          key={`span-group-${depth}`}\n          orphanBranch={isOrphanTreeDepth(treeDepth)}\n        />\n      );\n    });\n\n    return (\n      <TreeConnector isLast={isLastSibling} hasToggler orphanBranch={isOrphanSpan(span)}>\n        {connectorBars}\n      </TreeConnector>\n    );\n  }\n\n  function renderSpanRectangles() {\n    return (\n      <Fragment>\n        {spanGrouping.map((_, index) => (\n          <SpanRectangle\n            key={index}\n            spanGrouping={spanGrouping}\n            bounds={getSpanGroupBounds([spanGrouping[index]], generateBounds)}\n          />\n        ))}\n        <SpanRectangleOverlay\n          spanGrouping={spanGrouping}\n          bounds={getSpanGroupBounds(spanGrouping, generateBounds)}\n        />\n      </Fragment>\n    );\n  }\n\n  return (\n    <SpanGroupBar\n      event={event}\n      span={span}\n      spanGrouping={spanGrouping}\n      treeDepth={props.treeDepth}\n      spanNumber={spanNumber}\n      generateBounds={generateBounds}\n      toggleSpanGroup={() => toggleSiblingSpanGroup?.(spanGrouping[0].span, occurrence)}\n      renderSpanTreeConnector={renderSpanTreeConnector}\n      renderGroupSpansTitle={renderGroupSpansTitle}\n      renderSpanRectangles={renderSpanRectangles}\n      onWheel={onWheel}\n      generateContentSpanBarRef={generateContentSpanBarRef}\n    />\n  );\n}\n","import {Component} from 'react';\nimport styled from '@emotion/styled';\nimport isEqual from 'lodash/isEqual';\n\nimport {MessageRow} from 'sentry/components/performance/waterfall/messageRow';\nimport {pickBarColor} from 'sentry/components/performance/waterfall/utils';\nimport {t, tct} from 'sentry/locale';\nimport {Organization} from 'sentry/types';\n\nimport {DragManagerChildrenProps} from './dragManager';\nimport {ScrollbarManagerChildrenProps, withScrollbarManager} from './scrollbarManager';\nimport SpanBar from './spanBar';\nimport {SpanDescendantGroupBar} from './spanDescendantGroupBar';\nimport SpanSiblingGroupBar from './spanSiblingGroupBar';\nimport {\n  EnhancedProcessedSpanType,\n  EnhancedSpan,\n  FilterSpans,\n  GroupType,\n  ParsedTraceType,\n  SpanType,\n} from './types';\nimport {getSpanID, getSpanOperation, setSpansOnTransaction} from './utils';\nimport WaterfallModel from './waterfallModel';\n\ntype PropType = ScrollbarManagerChildrenProps & {\n  dragProps: DragManagerChildrenProps;\n  filterSpans: FilterSpans | undefined;\n  organization: Organization;\n  spans: EnhancedProcessedSpanType[];\n  traceViewRef: React.RefObject<HTMLDivElement>;\n  waterfallModel: WaterfallModel;\n};\n\nclass SpanTree extends Component<PropType> {\n  componentDidMount() {\n    setSpansOnTransaction(this.props.spans.length);\n  }\n\n  shouldComponentUpdate(nextProps: PropType) {\n    if (\n      this.props.dragProps.isDragging !== nextProps.dragProps.isDragging ||\n      this.props.dragProps.isWindowSelectionDragging !==\n        nextProps.dragProps.isWindowSelectionDragging\n    ) {\n      return true;\n    }\n\n    if (\n      nextProps.dragProps.isDragging ||\n      nextProps.dragProps.isWindowSelectionDragging ||\n      isEqual(this.props.spans, nextProps.spans)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  componentDidUpdate(prevProps: PropType) {\n    if (\n      !isEqual(prevProps.filterSpans, this.props.filterSpans) ||\n      !isEqual(prevProps.spans, this.props.spans)\n    ) {\n      // Update horizontal scroll states after a search has been performed or if\n      // if the spans has changed\n      this.props.updateScrollState();\n    }\n  }\n\n  generateInfoMessage(input: {\n    isCurrentSpanFilteredOut: boolean;\n    isCurrentSpanHidden: boolean;\n    numOfFilteredSpansAbove: number;\n    numOfSpansOutOfViewAbove: number;\n  }): React.ReactNode {\n    const {\n      isCurrentSpanHidden,\n      numOfSpansOutOfViewAbove,\n      isCurrentSpanFilteredOut,\n      numOfFilteredSpansAbove,\n    } = input;\n\n    const messages: React.ReactNode[] = [];\n\n    const showHiddenSpansMessage = !isCurrentSpanHidden && numOfSpansOutOfViewAbove > 0;\n\n    if (showHiddenSpansMessage) {\n      messages.push(\n        <span key=\"spans-out-of-view\">\n          <strong>{numOfSpansOutOfViewAbove}</strong> {t('spans out of view')}\n        </span>\n      );\n    }\n\n    const showFilteredSpansMessage =\n      !isCurrentSpanFilteredOut && numOfFilteredSpansAbove > 0;\n\n    if (showFilteredSpansMessage) {\n      if (!isCurrentSpanHidden) {\n        if (numOfFilteredSpansAbove === 1) {\n          messages.push(\n            <span key=\"spans-filtered\">\n              {tct('[numOfSpans] hidden span', {\n                numOfSpans: <strong>{numOfFilteredSpansAbove}</strong>,\n              })}\n            </span>\n          );\n        } else {\n          messages.push(\n            <span key=\"spans-filtered\">\n              {tct('[numOfSpans] hidden spans', {\n                numOfSpans: <strong>{numOfFilteredSpansAbove}</strong>,\n              })}\n            </span>\n          );\n        }\n      }\n    }\n\n    if (messages.length <= 0) {\n      return null;\n    }\n\n    return <MessageRow>{messages}</MessageRow>;\n  }\n\n  generateLimitExceededMessage() {\n    const {waterfallModel} = this.props;\n    const {parsedTrace} = waterfallModel;\n\n    if (hasAllSpans(parsedTrace)) {\n      return null;\n    }\n\n    return (\n      <MessageRow>\n        {t(\n          'The next spans are unavailable. You may have exceeded the span limit or need to address missing instrumentation.'\n        )}\n      </MessageRow>\n    );\n  }\n\n  toggleSpanTree = (spanID: string) => () => {\n    this.props.waterfallModel.toggleSpanSubTree(spanID);\n    // Update horizontal scroll states after this subtree was either hidden or\n    // revealed.\n    this.props.updateScrollState();\n  };\n\n  render() {\n    const {\n      waterfallModel,\n      spans,\n      organization,\n      dragProps,\n      onWheel,\n      generateContentSpanBarRef,\n      markSpanOutOfView,\n      markSpanInView,\n      storeSpanBar,\n    } = this.props;\n    const generateBounds = waterfallModel.generateBounds({\n      viewStart: dragProps.viewWindowStart,\n      viewEnd: dragProps.viewWindowEnd,\n    });\n\n    type AccType = {\n      numOfFilteredSpansAbove: number;\n      numOfSpansOutOfViewAbove: number;\n      spanNumber: number;\n      spanTree: React.ReactNode[];\n    };\n\n    const numOfSpans = spans.reduce((sum: number, payload: EnhancedProcessedSpanType) => {\n      switch (payload.type) {\n        case 'root_span':\n        case 'span':\n        case 'span_group_chain': {\n          return sum + 1;\n        }\n\n        default: {\n          return sum;\n        }\n      }\n    }, 0);\n\n    const {spanTree, numOfSpansOutOfViewAbove, numOfFilteredSpansAbove} = spans.reduce(\n      (acc: AccType, payload: EnhancedProcessedSpanType) => {\n        const {type} = payload;\n\n        switch (payload.type) {\n          case 'filtered_out': {\n            acc.numOfFilteredSpansAbove += 1;\n            return acc;\n          }\n          case 'out_of_view': {\n            acc.numOfSpansOutOfViewAbove += 1;\n            return acc;\n          }\n          default: {\n            break;\n          }\n        }\n\n        const previousSpanNotDisplayed =\n          acc.numOfFilteredSpansAbove > 0 || acc.numOfSpansOutOfViewAbove > 0;\n\n        if (previousSpanNotDisplayed) {\n          const infoMessage = this.generateInfoMessage({\n            isCurrentSpanHidden: false,\n            numOfSpansOutOfViewAbove: acc.numOfSpansOutOfViewAbove,\n            isCurrentSpanFilteredOut: false,\n            numOfFilteredSpansAbove: acc.numOfFilteredSpansAbove,\n          });\n          acc.spanTree.push(infoMessage);\n        }\n\n        const spanNumber = acc.spanNumber;\n        const {span, treeDepth, continuingTreeDepths} = payload;\n\n        if (payload.type === 'span_group_chain') {\n          acc.spanTree.push(\n            <SpanDescendantGroupBar\n              key={`${spanNumber}-span-group`}\n              event={waterfallModel.event}\n              span={span}\n              generateBounds={generateBounds}\n              treeDepth={treeDepth}\n              continuingTreeDepths={continuingTreeDepths}\n              spanNumber={spanNumber}\n              spanGrouping={payload.spanNestedGrouping as EnhancedSpan[]}\n              toggleSpanGroup={payload.toggleNestedSpanGroup as () => void}\n              onWheel={onWheel}\n              generateContentSpanBarRef={generateContentSpanBarRef}\n            />\n          );\n          acc.spanNumber = spanNumber + 1;\n          return acc;\n        }\n\n        if (payload.type === 'span_group_siblings') {\n          acc.spanTree.push(\n            <SpanSiblingGroupBar\n              key={`${spanNumber}-span-sibling`}\n              event={waterfallModel.event}\n              span={span}\n              generateBounds={generateBounds}\n              treeDepth={treeDepth}\n              continuingTreeDepths={continuingTreeDepths}\n              spanNumber={spanNumber}\n              spanGrouping={payload.spanSiblingGrouping as EnhancedSpan[]}\n              toggleSiblingSpanGroup={payload.toggleSiblingSpanGroup}\n              isLastSibling={payload.isLastSibling ?? false}\n              occurrence={payload.occurrence}\n              onWheel={onWheel}\n              generateContentSpanBarRef={generateContentSpanBarRef}\n            />\n          );\n          acc.spanNumber = spanNumber + 1;\n          return acc;\n        }\n\n        const key = getSpanID(span, `span-${spanNumber}`);\n        const isLast = payload.isLastSibling;\n        const isRoot = type === 'root_span';\n        const spanBarColor: string = pickBarColor(getSpanOperation(span));\n        const numOfSpanChildren = payload.numOfSpanChildren;\n\n        acc.numOfFilteredSpansAbove = 0;\n        acc.numOfSpansOutOfViewAbove = 0;\n\n        let toggleSpanGroup: (() => void) | undefined = undefined;\n        if (payload.type === 'span') {\n          toggleSpanGroup = payload.toggleNestedSpanGroup;\n        }\n\n        let toggleSiblingSpanGroup:\n          | ((span: SpanType, occurrence: number) => void)\n          | undefined = undefined;\n        if (payload.type === 'span' && payload.isFirstSiblingOfGroup) {\n          toggleSiblingSpanGroup = payload.toggleSiblingSpanGroup;\n        }\n\n        let groupType;\n        if (toggleSpanGroup) {\n          groupType = GroupType.DESCENDANTS;\n        } else if (toggleSiblingSpanGroup) {\n          groupType = GroupType.SIBLINGS;\n        }\n\n        acc.spanTree.push(\n          <SpanBar\n            key={key}\n            organization={organization}\n            event={waterfallModel.event}\n            spanBarColor={spanBarColor}\n            spanBarHatch={type === 'gap'}\n            span={span}\n            showSpanTree={!waterfallModel.hiddenSpanSubTrees.has(getSpanID(span))}\n            numOfSpanChildren={numOfSpanChildren}\n            trace={waterfallModel.parsedTrace}\n            generateBounds={generateBounds}\n            toggleSpanTree={this.toggleSpanTree(getSpanID(span))}\n            treeDepth={treeDepth}\n            continuingTreeDepths={continuingTreeDepths}\n            spanNumber={spanNumber}\n            isLast={isLast}\n            isRoot={isRoot}\n            showEmbeddedChildren={payload.showEmbeddedChildren}\n            toggleEmbeddedChildren={payload.toggleEmbeddedChildren}\n            toggleSiblingSpanGroup={toggleSiblingSpanGroup}\n            fetchEmbeddedChildrenState={payload.fetchEmbeddedChildrenState}\n            toggleSpanGroup={toggleSpanGroup}\n            numOfSpans={numOfSpans}\n            groupType={groupType}\n            groupOccurrence={payload.groupOccurrence}\n            isEmbeddedTransactionTimeAdjusted={payload.isEmbeddedTransactionTimeAdjusted}\n            onWheel={onWheel}\n            generateContentSpanBarRef={generateContentSpanBarRef}\n            markSpanOutOfView={markSpanOutOfView}\n            markSpanInView={markSpanInView}\n            storeSpanBar={storeSpanBar}\n          />\n        );\n\n        acc.spanNumber = spanNumber + 1;\n        return acc;\n      },\n      {\n        numOfSpansOutOfViewAbove: 0,\n        numOfFilteredSpansAbove: 0,\n        spanTree: [],\n        spanNumber: 1, // 1-based indexing\n      }\n    );\n\n    const infoMessage = this.generateInfoMessage({\n      isCurrentSpanHidden: false,\n      numOfSpansOutOfViewAbove,\n      isCurrentSpanFilteredOut: false,\n      numOfFilteredSpansAbove,\n    });\n\n    return (\n      <TraceViewContainer ref={this.props.traceViewRef}>\n        {spanTree}\n        {infoMessage}\n        {this.generateLimitExceededMessage()}\n      </TraceViewContainer>\n    );\n  }\n}\n\nconst TraceViewContainer = styled('div')`\n  overflow-x: hidden;\n  border-bottom-left-radius: 3px;\n  border-bottom-right-radius: 3px;\n`;\n\n/**\n * Checks if a trace contains all of its spans.\n *\n * The heuristic used here favors false negatives over false positives.\n * This is because showing a warning that the trace is not showing all\n * spans when it has them all is more misleading than not showing a\n * warning when it is missing some spans.\n *\n * A simple heuristic to determine when there are unrecorded spans\n *\n * 1. We assume if there are less than 999 spans, then we have all\n *    the spans for a transaction. 999 was chosen because most SDKs\n *    have a default limit of 1000 spans per transaction, but the\n *    python SDK is 999 for historic reasons.\n *\n * 2. We assume that if there are unrecorded spans, they should be\n *    at least 100ms in duration.\n *\n * While not perfect, this simple heuristic is unlikely to report\n * false positives.\n */\nfunction hasAllSpans(trace: ParsedTraceType): boolean {\n  const {traceEndTimestamp, spans} = trace;\n  if (spans.length < 999) {\n    return true;\n  }\n\n  const lastSpan = spans.reduce((latest, span) =>\n    latest.timestamp > span.timestamp ? latest : span\n  );\n  const missingDuration = traceEndTimestamp - lastSpan.timestamp;\n\n  return missingDuration < 0.1;\n}\n\nexport default withScrollbarManager(SpanTree);\n","import {createRef, PureComponent} from 'react';\nimport {Observer} from 'mobx-react';\n\nimport EmptyStateWarning from 'sentry/components/emptyStateWarning';\nimport {t} from 'sentry/locale';\nimport {Organization} from 'sentry/types';\nimport {CustomerProfiler} from 'sentry/utils/performanceForSentry';\n\nimport * as CursorGuideHandler from './cursorGuideHandler';\nimport * as DividerHandlerManager from './dividerHandlerManager';\nimport DragManager, {DragManagerChildrenProps} from './dragManager';\nimport TraceViewHeader from './header';\nimport * as ScrollbarManager from './scrollbarManager';\nimport SpanTree from './spanTree';\nimport {getTraceContext} from './utils';\nimport WaterfallModel from './waterfallModel';\n\ntype Props = {\n  organization: Organization;\n  waterfallModel: WaterfallModel;\n};\n\nclass TraceView extends PureComponent<Props> {\n  traceViewRef = createRef<HTMLDivElement>();\n  virtualScrollBarContainerRef = createRef<HTMLDivElement>();\n  minimapInteractiveRef = createRef<HTMLDivElement>();\n\n  renderHeader = (dragProps: DragManagerChildrenProps) => (\n    <Observer>\n      {() => {\n        const {waterfallModel} = this.props;\n\n        return (\n          <TraceViewHeader\n            organization={this.props.organization}\n            minimapInteractiveRef={this.minimapInteractiveRef}\n            dragProps={dragProps}\n            trace={waterfallModel.parsedTrace}\n            event={waterfallModel.event}\n            virtualScrollBarContainerRef={this.virtualScrollBarContainerRef}\n            operationNameFilters={waterfallModel.operationNameFilters}\n            rootSpan={waterfallModel.rootSpan.span}\n            spans={waterfallModel.getWaterfall({\n              viewStart: 0,\n              viewEnd: 1,\n            })}\n            generateBounds={waterfallModel.generateBounds({\n              viewStart: 0,\n              viewEnd: 1,\n            })}\n          />\n        );\n      }}\n    </Observer>\n  );\n\n  render() {\n    const {organization, waterfallModel} = this.props;\n\n    if (!getTraceContext(waterfallModel.event)) {\n      return (\n        <EmptyStateWarning>\n          <p>{t('There is no trace for this transaction')}</p>\n        </EmptyStateWarning>\n      );\n    }\n\n    return (\n      <DragManager interactiveLayerRef={this.minimapInteractiveRef}>\n        {(dragProps: DragManagerChildrenProps) => (\n          <Observer>\n            {() => {\n              const parsedTrace = waterfallModel.parsedTrace;\n              return (\n                <CursorGuideHandler.Provider\n                  interactiveLayerRef={this.minimapInteractiveRef}\n                  dragProps={dragProps}\n                  trace={parsedTrace}\n                >\n                  <DividerHandlerManager.Provider interactiveLayerRef={this.traceViewRef}>\n                    <DividerHandlerManager.Consumer>\n                      {dividerHandlerChildrenProps => {\n                        return (\n                          <ScrollbarManager.Provider\n                            dividerPosition={dividerHandlerChildrenProps.dividerPosition}\n                            interactiveLayerRef={this.virtualScrollBarContainerRef}\n                            dragProps={dragProps}\n                          >\n                            {this.renderHeader(dragProps)}\n                            <Observer>\n                              {() => {\n                                return (\n                                  <CustomerProfiler id=\"SpanTree\">\n                                    <SpanTree\n                                      traceViewRef={this.traceViewRef}\n                                      dragProps={dragProps}\n                                      organization={organization}\n                                      waterfallModel={waterfallModel}\n                                      filterSpans={waterfallModel.filterSpans}\n                                      spans={waterfallModel.getWaterfall({\n                                        viewStart: dragProps.viewWindowStart,\n                                        viewEnd: dragProps.viewWindowEnd,\n                                      })}\n                                    />\n                                  </CustomerProfiler>\n                                );\n                              }}\n                            </Observer>\n                          </ScrollbarManager.Provider>\n                        );\n                      }}\n                    </DividerHandlerManager.Consumer>\n                  </DividerHandlerManager.Provider>\n                </CursorGuideHandler.Provider>\n              );\n            }}\n          </Observer>\n        )}\n      </DragManager>\n    );\n  }\n}\n\nexport default TraceView;\n","import {action, computed, makeObservable, observable} from 'mobx';\n\nimport {Client} from 'sentry/api';\nimport {t} from 'sentry/locale';\nimport {EventTransaction} from 'sentry/types/event';\n\nimport {ActiveOperationFilter} from './filter';\nimport {\n  DescendantGroup,\n  EnhancedProcessedSpanType,\n  EnhancedSpan,\n  FetchEmbeddedChildrenState,\n  FilterSpans,\n  OrphanTreeDepth,\n  RawSpanType,\n  SpanChildrenLookupType,\n  SpanType,\n  TraceBound,\n  TreeDepthType,\n} from './types';\nimport {\n  generateRootSpan,\n  getSiblingGroupKey,\n  getSpanID,\n  getSpanOperation,\n  isEventFromBrowserJavaScriptSDK,\n  isOrphanSpan,\n  parseTrace,\n  SpanBoundsType,\n  SpanGeneratedBoundsType,\n} from './utils';\n\nexport const MIN_SIBLING_GROUP_SIZE = 5;\n\nclass SpanTreeModel {\n  api: Client;\n\n  // readonly state\n  span: Readonly<SpanType>;\n  children: Array<SpanTreeModel> = [];\n  isRoot: boolean;\n\n  // readable/writable state\n  fetchEmbeddedChildrenState: FetchEmbeddedChildrenState = 'idle';\n  showEmbeddedChildren: boolean = false;\n  embeddedChildren: Array<SpanTreeModel> = [];\n  isEmbeddedTransactionTimeAdjusted: boolean = false;\n  // This controls if a chain of nested spans that are the only sibling to be visually grouped together or not.\n  // On initial render, they're visually grouped together.\n  isNestedSpanGroupExpanded: boolean = false;\n  // Entries in this set will follow the format 'op.description'.\n  // An entry in this set indicates that all siblings with the op and description should be left ungrouped\n  expandedSiblingGroups: Set<string> = new Set();\n\n  constructor(\n    parentSpan: SpanType,\n    childSpans: SpanChildrenLookupType,\n    api: Client,\n    isRoot: boolean = false\n  ) {\n    this.api = api;\n    this.span = parentSpan;\n    this.isRoot = isRoot;\n\n    const spanID = getSpanID(parentSpan);\n    const spanChildren: Array<RawSpanType> = childSpans?.[spanID] ?? [];\n\n    // Mark descendents as being rendered. This is to address potential recursion issues due to malformed data.\n    // For example if a span has a span_id that's identical to its parent_span_id.\n    childSpans = {\n      ...childSpans,\n    };\n    delete childSpans[spanID];\n\n    this.children = spanChildren.map(span => {\n      return new SpanTreeModel(span, childSpans, api);\n    });\n\n    makeObservable(this, {\n      operationNameCounts: computed.struct,\n      showEmbeddedChildren: observable,\n      embeddedChildren: observable,\n      fetchEmbeddedChildrenState: observable,\n      toggleEmbeddedChildren: action,\n      fetchEmbeddedTransactions: action,\n      isNestedSpanGroupExpanded: observable,\n      toggleNestedSpanGroup: action,\n      expandedSiblingGroups: observable,\n      toggleSiblingSpanGroup: action,\n      isEmbeddedTransactionTimeAdjusted: observable,\n    });\n  }\n\n  get operationNameCounts(): Map<string, number> {\n    const result = new Map<string, number>();\n\n    const operationName = this.span.op;\n\n    if (typeof operationName === 'string' && operationName.length > 0) {\n      result.set(operationName, 1);\n    }\n\n    for (const directChild of this.children) {\n      const operationNameCounts = directChild.operationNameCounts;\n      for (const [key, count] of operationNameCounts) {\n        result.set(key, (result.get(key) ?? 0) + count);\n      }\n    }\n\n    // sort alphabetically using case insensitive comparison\n    return new Map(\n      [...result].sort((a, b) =>\n        String(a[0]).localeCompare(b[0], undefined, {sensitivity: 'base'})\n      )\n    );\n  }\n\n  isSpanFilteredOut = (\n    props: {\n      filterSpans: FilterSpans | undefined;\n      operationNameFilters: ActiveOperationFilter;\n    },\n    spanModel: SpanTreeModel\n  ): boolean => {\n    const {operationNameFilters, filterSpans} = props;\n\n    if (operationNameFilters.type === 'active_filter') {\n      const operationName = getSpanOperation(spanModel.span);\n\n      if (\n        typeof operationName === 'string' &&\n        !operationNameFilters.operationNames.has(operationName)\n      ) {\n        return true;\n      }\n    }\n\n    if (!filterSpans) {\n      return false;\n    }\n\n    return !filterSpans.spanIDs.has(getSpanID(spanModel.span));\n  };\n\n  generateSpanGap(\n    event: Readonly<EventTransaction>,\n    previousSiblingEndTimestamp: number | undefined,\n    treeDepth: number,\n    continuingTreeDepths: Array<TreeDepthType>\n  ): EnhancedProcessedSpanType | undefined {\n    // hide gap spans (i.e. \"missing instrumentation\" spans) for browser js transactions,\n    // since they're not useful to indicate\n    const shouldIncludeGap = !isEventFromBrowserJavaScriptSDK(event);\n\n    const isValidGap =\n      shouldIncludeGap &&\n      typeof previousSiblingEndTimestamp === 'number' &&\n      previousSiblingEndTimestamp < this.span.start_timestamp &&\n      // gap is at least 100 ms\n      this.span.start_timestamp - previousSiblingEndTimestamp >= 0.1;\n    if (!isValidGap) {\n      return undefined;\n    }\n\n    const gapSpan: EnhancedProcessedSpanType = {\n      type: 'gap',\n      span: {\n        type: 'gap',\n        start_timestamp: previousSiblingEndTimestamp || this.span.start_timestamp,\n        timestamp: this.span.start_timestamp, // this is essentially end_timestamp\n        description: t('Missing instrumentation'),\n        isOrphan: isOrphanSpan(this.span),\n      },\n      numOfSpanChildren: 0,\n      treeDepth,\n      isLastSibling: false,\n      continuingTreeDepths,\n      fetchEmbeddedChildrenState: 'idle',\n      showEmbeddedChildren: false,\n      toggleEmbeddedChildren: undefined,\n      isEmbeddedTransactionTimeAdjusted: this.isEmbeddedTransactionTimeAdjusted,\n    };\n    return gapSpan;\n  }\n\n  getSpansList = (props: {\n    addTraceBounds: (bounds: TraceBound) => void;\n    continuingTreeDepths: Array<TreeDepthType>;\n    event: Readonly<EventTransaction>;\n    filterSpans: FilterSpans | undefined;\n    generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType;\n    hiddenSpanSubTrees: Set<String>;\n    isLastSibling: boolean;\n    isNestedSpanGroupExpanded: boolean;\n    isOnlySibling: boolean;\n    operationNameFilters: ActiveOperationFilter;\n    previousSiblingEndTimestamp: number | undefined;\n    removeTraceBounds: (eventSlug: string) => void;\n    spanAncestors: Set<String>;\n    spanNestedGrouping: EnhancedSpan[] | undefined;\n    toggleNestedSpanGroup: (() => void) | undefined;\n    treeDepth: number;\n  }): EnhancedProcessedSpanType[] => {\n    const {\n      operationNameFilters,\n      generateBounds,\n      isLastSibling,\n      hiddenSpanSubTrees,\n      // The set of ancestor span IDs whose sub-tree that the span belongs to\n      spanAncestors,\n      filterSpans,\n      previousSiblingEndTimestamp,\n      event,\n      isOnlySibling,\n      spanNestedGrouping,\n      toggleNestedSpanGroup,\n      isNestedSpanGroupExpanded,\n      addTraceBounds,\n      removeTraceBounds,\n    } = props;\n    let {treeDepth, continuingTreeDepths} = props;\n\n    const parentSpanID = getSpanID(this.span);\n    const nextSpanAncestors = new Set(spanAncestors);\n    nextSpanAncestors.add(parentSpanID);\n\n    const descendantsSource = this.showEmbeddedChildren\n      ? [...this.embeddedChildren, ...this.children]\n      : this.children;\n\n    const isNotLastSpanOfGroup =\n      isOnlySibling && !this.isRoot && descendantsSource.length === 1;\n    const shouldGroup = isNotLastSpanOfGroup;\n    const hideSpanTree = hiddenSpanSubTrees.has(parentSpanID);\n    const isLastSpanOfGroup =\n      isOnlySibling && !this.isRoot && (descendantsSource.length !== 1 || hideSpanTree);\n    const isFirstSpanOfGroup =\n      shouldGroup &&\n      (spanNestedGrouping === undefined ||\n        (Array.isArray(spanNestedGrouping) && spanNestedGrouping.length === 0));\n\n    if (\n      isLastSpanOfGroup &&\n      Array.isArray(spanNestedGrouping) &&\n      spanNestedGrouping.length >= 1 &&\n      !isNestedSpanGroupExpanded\n    ) {\n      // We always want to indent the last span of the span group chain\n      treeDepth = treeDepth + 1;\n\n      // For a collapsed span group chain to be useful, we prefer span groupings\n      // that are two or more spans.\n      // Since there is no concept of \"backtracking\" when constructing the span tree,\n      // we will need to reconstruct the tree depth information. This is only neccessary\n      // when the span group chain is hidden/collapsed.\n      if (spanNestedGrouping.length === 1) {\n        const treeDepthEntry = isOrphanSpan(spanNestedGrouping[0].span)\n          ? ({type: 'orphan', depth: spanNestedGrouping[0].treeDepth} as OrphanTreeDepth)\n          : spanNestedGrouping[0].treeDepth;\n\n        if (!spanNestedGrouping[0].isLastSibling) {\n          continuingTreeDepths = [...continuingTreeDepths, treeDepthEntry];\n        }\n      }\n    }\n\n    // Criteria for propagating information about the span group to the last span of the span group chain\n    const spanGroupingCriteria =\n      isLastSpanOfGroup &&\n      Array.isArray(spanNestedGrouping) &&\n      spanNestedGrouping.length > 1;\n\n    const wrappedSpan: EnhancedSpan = {\n      type: this.isRoot ? 'root_span' : 'span',\n      span: this.span,\n      numOfSpanChildren: descendantsSource.length,\n      treeDepth,\n      isLastSibling,\n      continuingTreeDepths,\n      fetchEmbeddedChildrenState: this.fetchEmbeddedChildrenState,\n      showEmbeddedChildren: this.showEmbeddedChildren,\n      toggleEmbeddedChildren: this.toggleEmbeddedChildren({\n        addTraceBounds,\n        removeTraceBounds,\n      }),\n      toggleNestedSpanGroup:\n        spanGroupingCriteria && toggleNestedSpanGroup && !isNestedSpanGroupExpanded\n          ? toggleNestedSpanGroup\n          : isFirstSpanOfGroup && this.isNestedSpanGroupExpanded && !hideSpanTree\n          ? this.toggleNestedSpanGroup\n          : undefined,\n      toggleSiblingSpanGroup: undefined,\n      isEmbeddedTransactionTimeAdjusted: this.isEmbeddedTransactionTimeAdjusted,\n    };\n\n    if (wrappedSpan.type === 'root_span') {\n      // @ts-expect-error\n      delete wrappedSpan.toggleNestedSpanGroup;\n    }\n\n    const treeDepthEntry = isOrphanSpan(this.span)\n      ? ({type: 'orphan', depth: treeDepth} as OrphanTreeDepth)\n      : treeDepth;\n\n    const shouldHideSpanOfGroup =\n      shouldGroup &&\n      !isLastSpanOfGroup &&\n      ((toggleNestedSpanGroup === undefined && !this.isNestedSpanGroupExpanded) ||\n        (toggleNestedSpanGroup !== undefined && !isNestedSpanGroupExpanded));\n\n    const descendantContinuingTreeDepths =\n      isLastSibling || shouldHideSpanOfGroup\n        ? continuingTreeDepths\n        : [...continuingTreeDepths, treeDepthEntry];\n\n    for (const hiddenSpanSubTree of hiddenSpanSubTrees) {\n      if (spanAncestors.has(hiddenSpanSubTree)) {\n        // If this span is hidden, then all the descendants are hidden as well\n        return [];\n      }\n    }\n\n    const groupedDescendants: DescendantGroup[] = [];\n    // Used to number sibling groups in case there are multiple groups with the same op and description\n    const siblingGroupOccurrenceMap = {};\n\n    const addGroupToMap = (prevSpanModel: SpanTreeModel, group: SpanTreeModel[]) => {\n      if (!group.length) {\n        return;\n      }\n\n      const groupKey = `${prevSpanModel.span.op}.${prevSpanModel.span.description}`;\n\n      if (!siblingGroupOccurrenceMap[groupKey]) {\n        siblingGroupOccurrenceMap[groupKey] = 1;\n      } else {\n        siblingGroupOccurrenceMap[groupKey] += 1;\n      }\n\n      groupedDescendants.push({\n        group,\n        occurrence: siblingGroupOccurrenceMap[groupKey],\n      });\n    };\n\n    if (descendantsSource?.length >= MIN_SIBLING_GROUP_SIZE) {\n      let prevSpanModel = descendantsSource[0];\n      let currentGroup = [prevSpanModel];\n\n      for (let i = 1; i < descendantsSource.length; i++) {\n        const currSpanModel = descendantsSource[i];\n\n        // We want to group siblings only if they share the same op and description, and if they have no children\n        if (\n          prevSpanModel.span.op === currSpanModel.span.op &&\n          prevSpanModel.span.description === currSpanModel.span.description &&\n          currSpanModel.children.length === 0\n        ) {\n          currentGroup.push(currSpanModel);\n        } else {\n          addGroupToMap(prevSpanModel, currentGroup);\n\n          if (currSpanModel.children.length) {\n            currentGroup = [currSpanModel];\n            groupedDescendants.push({group: currentGroup});\n            currentGroup = [];\n          } else {\n            currentGroup = [currSpanModel];\n          }\n        }\n\n        prevSpanModel = currSpanModel;\n      }\n\n      addGroupToMap(prevSpanModel, currentGroup);\n    } else if (descendantsSource.length >= 1) {\n      groupedDescendants.push({group: descendantsSource});\n    }\n\n    const descendants = (hideSpanTree ? [] : groupedDescendants).reduce(\n      (\n        acc: {\n          descendants: EnhancedProcessedSpanType[];\n          previousSiblingEndTimestamp: number | undefined;\n        },\n        {group, occurrence},\n        groupIndex\n      ) => {\n        // Groups less than 5 indicate that the spans should be left ungrouped\n        if (group.length < MIN_SIBLING_GROUP_SIZE) {\n          group.forEach((spanModel, index) => {\n            acc.descendants.push(\n              ...spanModel.getSpansList({\n                operationNameFilters,\n                generateBounds,\n                treeDepth: shouldHideSpanOfGroup ? treeDepth : treeDepth + 1,\n                isLastSibling:\n                  groupIndex === groupedDescendants.length - 1 &&\n                  index === group.length - 1,\n                continuingTreeDepths: descendantContinuingTreeDepths,\n                hiddenSpanSubTrees,\n                spanAncestors: new Set(nextSpanAncestors),\n                filterSpans,\n                previousSiblingEndTimestamp: acc.previousSiblingEndTimestamp,\n                event,\n                isOnlySibling: descendantsSource.length === 1,\n                spanNestedGrouping: shouldGroup\n                  ? [...(spanNestedGrouping ?? []), wrappedSpan]\n                  : undefined,\n                toggleNestedSpanGroup: isNotLastSpanOfGroup\n                  ? toggleNestedSpanGroup === undefined\n                    ? this.toggleNestedSpanGroup\n                    : toggleNestedSpanGroup\n                  : undefined,\n                isNestedSpanGroupExpanded: isNotLastSpanOfGroup\n                  ? toggleNestedSpanGroup === undefined\n                    ? this.isNestedSpanGroupExpanded\n                    : isNestedSpanGroupExpanded\n                  : false,\n                addTraceBounds,\n                removeTraceBounds,\n              })\n            );\n\n            acc.previousSiblingEndTimestamp = spanModel.span.timestamp;\n          });\n\n          return acc;\n        }\n\n        // NOTE: I am making the assumption here that grouped sibling spans will not have children.\n        // By making this assumption, I can immediately wrap the grouped spans here without having\n        // to recursively traverse them.\n\n        // This may not be the case, and needs to be looked into later\n\n        const key = getSiblingGroupKey(group[0].span, occurrence);\n        if (this.expandedSiblingGroups.has(key)) {\n          // This check is needed here, since it is possible that a user could be filtering for a specific span ID.\n          // In this case, we must add only the specified span into the accumulator's descendants\n          group.forEach((spanModel, index) => {\n            if (this.isSpanFilteredOut(props, spanModel)) {\n              acc.descendants.push({\n                type: 'filtered_out',\n                span: spanModel.span,\n              });\n            } else {\n              const enhancedSibling: EnhancedSpan = {\n                type: 'span',\n                span: spanModel.span,\n                numOfSpanChildren: 0,\n                treeDepth: treeDepth + 1,\n                isLastSibling:\n                  index === group.length - 1 &&\n                  groupIndex === groupedDescendants.length - 1,\n                isFirstSiblingOfGroup: index === 0,\n                groupOccurrence: occurrence,\n                continuingTreeDepths: descendantContinuingTreeDepths,\n                fetchEmbeddedChildrenState: spanModel.fetchEmbeddedChildrenState,\n                showEmbeddedChildren: spanModel.showEmbeddedChildren,\n                toggleEmbeddedChildren: spanModel.toggleEmbeddedChildren({\n                  addTraceBounds,\n                  removeTraceBounds,\n                }),\n                toggleNestedSpanGroup: undefined,\n                toggleSiblingSpanGroup:\n                  index === 0 ? this.toggleSiblingSpanGroup : undefined,\n                isEmbeddedTransactionTimeAdjusted:\n                  spanModel.isEmbeddedTransactionTimeAdjusted,\n              };\n\n              acc.previousSiblingEndTimestamp = spanModel.span.timestamp;\n              acc.descendants.push(enhancedSibling);\n            }\n          });\n\n          return acc;\n        }\n\n        // Since we are not recursively traversing elements in this group, need to check\n        // if the spans are filtered or out of bounds here\n\n        if (this.isSpanFilteredOut(props, group[0])) {\n          group.forEach(spanModel =>\n            acc.descendants.push({\n              type: 'filtered_out',\n              span: spanModel.span,\n            })\n          );\n          return acc;\n        }\n\n        const bounds = generateBounds({\n          startTimestamp: group[0].span.start_timestamp,\n          endTimestamp: group[group.length - 1].span.timestamp,\n        });\n\n        if (!bounds.isSpanVisibleInView) {\n          group.forEach(spanModel =>\n            acc.descendants.push({\n              type: 'out_of_view',\n              span: spanModel.span,\n            })\n          );\n          return acc;\n        }\n\n        // Since the group is not expanded, return a singular grouped span bar\n        const wrappedSiblings: EnhancedSpan[] = group.map((spanModel, index) => {\n          const enhancedSibling: EnhancedSpan = {\n            type: 'span',\n            span: spanModel.span,\n            numOfSpanChildren: 0,\n            treeDepth: treeDepth + 1,\n            isLastSibling:\n              index === group.length - 1 && groupIndex === groupedDescendants.length - 1,\n            isFirstSiblingOfGroup: index === 0,\n            groupOccurrence: occurrence,\n            continuingTreeDepths: descendantContinuingTreeDepths,\n            fetchEmbeddedChildrenState: spanModel.fetchEmbeddedChildrenState,\n            showEmbeddedChildren: spanModel.showEmbeddedChildren,\n            toggleEmbeddedChildren: spanModel.toggleEmbeddedChildren({\n              addTraceBounds,\n              removeTraceBounds,\n            }),\n            toggleNestedSpanGroup: undefined,\n            toggleSiblingSpanGroup: index === 0 ? this.toggleSiblingSpanGroup : undefined,\n            isEmbeddedTransactionTimeAdjusted:\n              spanModel.isEmbeddedTransactionTimeAdjusted,\n          };\n\n          return enhancedSibling;\n        });\n\n        const groupedSiblingsSpan: EnhancedProcessedSpanType = {\n          type: 'span_group_siblings',\n          span: this.span,\n          treeDepth: treeDepth + 1,\n          continuingTreeDepths: descendantContinuingTreeDepths,\n          spanSiblingGrouping: wrappedSiblings,\n          isLastSibling: groupIndex === groupedDescendants.length - 1,\n          occurrence: occurrence ?? 0,\n          toggleSiblingSpanGroup: this.toggleSiblingSpanGroup,\n        };\n\n        acc.previousSiblingEndTimestamp =\n          wrappedSiblings[wrappedSiblings.length - 1].span.timestamp;\n\n        acc.descendants.push(groupedSiblingsSpan);\n        return acc;\n      },\n      {\n        descendants: [],\n        previousSiblingEndTimestamp: undefined,\n      }\n    ).descendants;\n\n    if (this.isSpanFilteredOut(props, this)) {\n      return [\n        {\n          type: 'filtered_out',\n          span: this.span,\n        },\n        ...descendants,\n      ];\n    }\n\n    const bounds = generateBounds({\n      startTimestamp: this.span.start_timestamp,\n      endTimestamp: this.span.timestamp,\n    });\n    const isCurrentSpanOutOfView = !bounds.isSpanVisibleInView;\n\n    if (isCurrentSpanOutOfView) {\n      return [\n        {\n          type: 'out_of_view',\n          span: this.span,\n        },\n        ...descendants,\n      ];\n    }\n\n    if (shouldHideSpanOfGroup) {\n      return [...descendants];\n    }\n\n    if (\n      isLastSpanOfGroup &&\n      Array.isArray(spanNestedGrouping) &&\n      spanNestedGrouping.length > 1 &&\n      !isNestedSpanGroupExpanded &&\n      wrappedSpan.type === 'span'\n    ) {\n      const spanGroupChain: EnhancedProcessedSpanType = {\n        type: 'span_group_chain',\n        span: this.span,\n        treeDepth: treeDepth - 1,\n        continuingTreeDepths,\n        spanNestedGrouping,\n        isNestedSpanGroupExpanded,\n        toggleNestedSpanGroup: wrappedSpan.toggleNestedSpanGroup,\n        toggleSiblingSpanGroup: undefined,\n      };\n\n      return [\n        spanGroupChain,\n        {...wrappedSpan, toggleNestedSpanGroup: undefined},\n        ...descendants,\n      ];\n    }\n\n    if (\n      isFirstSpanOfGroup &&\n      this.isNestedSpanGroupExpanded &&\n      !hideSpanTree &&\n      descendants.length <= 1 &&\n      wrappedSpan.type === 'span'\n    ) {\n      // If we know the descendants will be one span or less, we remove the \"regroup\" feature (therefore hide it)\n      // by setting toggleNestedSpanGroup to be undefined for the first span of the group chain.\n      wrappedSpan.toggleNestedSpanGroup = undefined;\n    }\n\n    // Do not autogroup groups that will only have two spans\n    if (\n      isLastSpanOfGroup &&\n      Array.isArray(spanNestedGrouping) &&\n      spanNestedGrouping.length === 1\n    ) {\n      if (!isNestedSpanGroupExpanded) {\n        const parentSpan = spanNestedGrouping[0].span;\n        const parentSpanBounds = generateBounds({\n          startTimestamp: parentSpan.start_timestamp,\n          endTimestamp: parentSpan.timestamp,\n        });\n        const isParentSpanOutOfView = !parentSpanBounds.isSpanVisibleInView;\n        if (!isParentSpanOutOfView) {\n          return [spanNestedGrouping[0], wrappedSpan, ...descendants];\n        }\n      }\n\n      return [wrappedSpan, ...descendants];\n    }\n\n    const gapSpan = this.generateSpanGap(\n      event,\n      previousSiblingEndTimestamp,\n      treeDepth,\n      continuingTreeDepths\n    );\n\n    if (gapSpan) {\n      return [gapSpan, wrappedSpan, ...descendants];\n    }\n\n    return [wrappedSpan, ...descendants];\n  };\n\n  toggleEmbeddedChildren =\n    ({\n      addTraceBounds,\n      removeTraceBounds,\n    }: {\n      addTraceBounds: (bounds: TraceBound) => void;\n      removeTraceBounds: (eventSlug: string) => void;\n    }) =>\n    (props: {eventSlug: string; orgSlug: string}) => {\n      this.showEmbeddedChildren = !this.showEmbeddedChildren;\n      this.fetchEmbeddedChildrenState = 'idle';\n\n      if (!this.showEmbeddedChildren) {\n        if (this.embeddedChildren.length > 0) {\n          this.embeddedChildren.forEach(child => {\n            removeTraceBounds(child.generateTraceBounds().spanId);\n          });\n        }\n      }\n\n      if (this.showEmbeddedChildren) {\n        if (this.embeddedChildren.length === 0) {\n          return this.fetchEmbeddedTransactions({...props, addTraceBounds});\n        }\n        this.embeddedChildren.forEach(child => {\n          addTraceBounds(child.generateTraceBounds());\n        });\n      }\n\n      return Promise.resolve(undefined);\n    };\n\n  fetchEmbeddedTransactions({\n    orgSlug,\n    eventSlug,\n    addTraceBounds,\n  }: {\n    addTraceBounds: (bounds: TraceBound) => void;\n    eventSlug: string;\n    orgSlug: string;\n  }) {\n    const url = `/organizations/${orgSlug}/events/${eventSlug}/`;\n\n    this.fetchEmbeddedChildrenState = 'loading_embedded_transactions';\n\n    return this.api\n      .requestPromise(url, {\n        method: 'GET',\n        query: {},\n      })\n      .then(\n        action('fetchEmbeddedTransactionsSuccess', (event: EventTransaction) => {\n          if (!event) {\n            return;\n          }\n\n          const parsedTrace = parseTrace(event);\n\n          // We need to adjust the timestamps for this embedded transaction only if it is not within the bounds of its parent span\n          if (\n            parsedTrace.traceStartTimestamp < this.span.start_timestamp ||\n            parsedTrace.traceEndTimestamp > this.span.timestamp\n          ) {\n            const startTimeDelta =\n              this.span.start_timestamp - parsedTrace.traceStartTimestamp;\n\n            parsedTrace.traceStartTimestamp += startTimeDelta;\n            parsedTrace.traceEndTimestamp += startTimeDelta;\n\n            parsedTrace.spans.forEach(span => {\n              span.start_timestamp += startTimeDelta;\n              span.timestamp += startTimeDelta;\n            });\n\n            this.isEmbeddedTransactionTimeAdjusted = true;\n          }\n\n          const rootSpan = generateRootSpan(parsedTrace);\n          const parsedRootSpan = new SpanTreeModel(\n            rootSpan,\n            parsedTrace.childSpans,\n            this.api,\n            false\n          );\n          this.embeddedChildren = [parsedRootSpan];\n          this.fetchEmbeddedChildrenState = 'idle';\n          addTraceBounds(parsedRootSpan.generateTraceBounds());\n        })\n      )\n      .catch(\n        action('fetchEmbeddedTransactionsError', () => {\n          this.embeddedChildren = [];\n          this.fetchEmbeddedChildrenState = 'error_fetching_embedded_transactions';\n        })\n      );\n  }\n\n  toggleNestedSpanGroup = () => {\n    this.isNestedSpanGroupExpanded = !this.isNestedSpanGroupExpanded;\n  };\n\n  toggleSiblingSpanGroup = (span: SpanType, occurrence?: number) => {\n    const key = getSiblingGroupKey(span, occurrence);\n\n    if (this.expandedSiblingGroups.has(key)) {\n      this.expandedSiblingGroups.delete(key);\n    } else {\n      this.expandedSiblingGroups.add(key);\n    }\n  };\n\n  generateTraceBounds = (): TraceBound => {\n    return {\n      spanId: this.span.span_id,\n      traceStartTimestamp: this.span.start_timestamp,\n      traceEndTimestamp: this.span.timestamp,\n    };\n  };\n}\n\nexport default SpanTreeModel;\n","import isEqual from 'lodash/isEqual';\nimport pick from 'lodash/pick';\nimport {action, computed, makeObservable, observable} from 'mobx';\n\nimport {Client} from 'sentry/api';\nimport {EventTransaction} from 'sentry/types/event';\nimport {createFuzzySearch, Fuse} from 'sentry/utils/fuzzySearch';\n\nimport {ActiveOperationFilter, noFilter, toggleAllFilters, toggleFilter} from './filter';\nimport SpanTreeModel from './spanTreeModel';\nimport {\n  FilterSpans,\n  IndexedFusedSpan,\n  ParsedTraceType,\n  RawSpanType,\n  TraceBound,\n} from './types';\nimport {boundsGenerator, generateRootSpan, getSpanID, parseTrace} from './utils';\n\nclass WaterfallModel {\n  api: Client = new Client();\n\n  // readonly state\n  event: Readonly<EventTransaction>;\n  rootSpan: SpanTreeModel;\n  parsedTrace: ParsedTraceType;\n  fuse: Fuse<IndexedFusedSpan> | undefined = undefined;\n\n  // readable/writable state\n  operationNameFilters: ActiveOperationFilter = noFilter;\n  filterSpans: FilterSpans | undefined = undefined;\n  searchQuery: string | undefined = undefined;\n  hiddenSpanSubTrees: Set<string>;\n  traceBounds: Array<TraceBound>;\n\n  constructor(event: Readonly<EventTransaction>) {\n    this.event = event;\n\n    this.parsedTrace = parseTrace(event);\n    const rootSpan = generateRootSpan(this.parsedTrace);\n    this.rootSpan = new SpanTreeModel(\n      rootSpan,\n      this.parsedTrace.childSpans,\n      this.api,\n      true\n    );\n\n    // Track the trace bounds of the current transaction and the trace bounds of\n    // any embedded transactions\n    this.traceBounds = [this.rootSpan.generateTraceBounds()];\n\n    this.indexSearch(this.parsedTrace, rootSpan);\n\n    // Set of span IDs whose sub-trees should be hidden. This is used for the\n    // span tree toggling product feature.\n    this.hiddenSpanSubTrees = new Set();\n\n    makeObservable(this, {\n      parsedTrace: observable,\n      rootSpan: observable,\n\n      // operation names filtering\n      operationNameFilters: observable,\n      toggleOperationNameFilter: action,\n      toggleAllOperationNameFilters: action,\n      operationNameCounts: computed.struct,\n\n      // span search\n      filterSpans: observable,\n      searchQuery: observable,\n      querySpanSearch: action,\n\n      // span sub-tree toggling\n      hiddenSpanSubTrees: observable,\n      toggleSpanSubTree: action,\n\n      // trace bounds\n      traceBounds: observable,\n      addTraceBounds: action,\n      removeTraceBounds: action,\n    });\n  }\n\n  isEvent(otherEvent: Readonly<EventTransaction>) {\n    return isEqual(this.event, otherEvent);\n  }\n\n  toggleOperationNameFilter = (operationName: string) => {\n    this.operationNameFilters = toggleFilter(this.operationNameFilters, operationName);\n  };\n\n  toggleAllOperationNameFilters = () => {\n    const operationNames = Array.from(this.operationNameCounts.keys());\n\n    this.operationNameFilters = toggleAllFilters(\n      this.operationNameFilters,\n      operationNames\n    );\n  };\n\n  get operationNameCounts(): Map<string, number> {\n    return this.rootSpan.operationNameCounts;\n  }\n\n  async indexSearch(parsedTrace: ParsedTraceType, rootSpan: RawSpanType) {\n    this.filterSpans = undefined;\n    this.searchQuery = undefined;\n\n    const {spans} = parsedTrace;\n\n    const transformed: IndexedFusedSpan[] = [rootSpan, ...spans].map(\n      (span): IndexedFusedSpan => {\n        const indexed: string[] = [];\n\n        // basic properties\n\n        const pickedSpan = pick(span, [\n          // TODO: do we want this?\n          // 'trace_id',\n          'span_id',\n          'start_timestamp',\n          'timestamp',\n          'op',\n          'description',\n        ]);\n\n        const basicValues: string[] = Object.values(pickedSpan)\n          .filter(value => !!value)\n          .map(value => String(value));\n\n        indexed.push(...basicValues);\n\n        // tags\n\n        let tagKeys: string[] = [];\n        let tagValues: string[] = [];\n        const tags: {[tag_name: string]: string} | undefined = span?.tags;\n\n        if (tags) {\n          tagKeys = Object.keys(tags);\n          tagValues = Object.values(tags);\n        }\n\n        const data: {[data_name: string]: any} | undefined = span?.data ?? {};\n\n        let dataKeys: string[] = [];\n        let dataValues: string[] = [];\n        if (data) {\n          dataKeys = Object.keys(data);\n          dataValues = Object.values(data).map(\n            value => JSON.stringify(value, null, 4) || ''\n          );\n        }\n\n        return {\n          span,\n          indexed,\n          tagKeys,\n          tagValues,\n          dataKeys,\n          dataValues,\n        };\n      }\n    );\n\n    this.fuse = await createFuzzySearch(transformed, {\n      keys: ['indexed', 'tagKeys', 'tagValues', 'dataKeys', 'dataValues'],\n      includeMatches: false,\n      threshold: 0.6,\n      location: 0,\n      distance: 100,\n      maxPatternLength: 32,\n    });\n  }\n\n  querySpanSearch(searchQuery: string | undefined) {\n    if (!searchQuery) {\n      // reset\n      if (this.filterSpans !== undefined) {\n        this.filterSpans = undefined;\n        this.searchQuery = undefined;\n      }\n      return;\n    }\n\n    if (!this.fuse) {\n      return;\n    }\n\n    const results = this.fuse.search(searchQuery);\n\n    const spanIDs: Set<string> = results.reduce((setOfSpanIDs: Set<string>, result) => {\n      const spanID = getSpanID(result.item.span);\n\n      if (spanID) {\n        setOfSpanIDs.add(spanID);\n      }\n\n      return setOfSpanIDs;\n    }, new Set<string>());\n\n    this.searchQuery = searchQuery;\n    this.filterSpans = {spanIDs, results};\n  }\n\n  toggleSpanSubTree = (spanID: string) => {\n    if (this.hiddenSpanSubTrees.has(spanID)) {\n      this.hiddenSpanSubTrees.delete(spanID);\n      return;\n    }\n\n    this.hiddenSpanSubTrees.add(spanID);\n  };\n\n  addTraceBounds = (traceBound: TraceBound) => {\n    this.traceBounds.push(traceBound);\n\n    this.parsedTrace = {\n      ...this.parsedTrace,\n      ...this.getTraceBounds(),\n    };\n  };\n\n  removeTraceBounds = (spanId: string) => {\n    this.traceBounds = this.traceBounds.filter(bound => bound.spanId !== spanId);\n\n    // traceBounds must always be non-empty\n    if (this.traceBounds.length === 0) {\n      this.traceBounds = [this.rootSpan.generateTraceBounds()];\n    }\n\n    this.parsedTrace = {\n      ...this.parsedTrace,\n      ...this.getTraceBounds(),\n    };\n  };\n\n  getTraceBounds = () => {\n    // traceBounds must always be non-empty\n    if (this.traceBounds.length === 0) {\n      this.traceBounds = [this.rootSpan.generateTraceBounds()];\n    }\n\n    return this.traceBounds.reduce(\n      (acc, bounds) => {\n        return {\n          traceStartTimestamp: Math.min(\n            acc.traceStartTimestamp,\n            bounds.traceStartTimestamp\n          ),\n          traceEndTimestamp: Math.max(acc.traceEndTimestamp, bounds.traceEndTimestamp),\n        };\n      },\n      {\n        traceStartTimestamp: this.traceBounds[0].traceStartTimestamp,\n        traceEndTimestamp: this.traceBounds[0].traceEndTimestamp,\n      }\n    );\n  };\n\n  generateBounds = ({\n    viewStart,\n    viewEnd,\n  }: {\n    // in [0, 1]\n    viewEnd: number;\n    viewStart: number; // in [0, 1]\n  }) => {\n    return boundsGenerator({\n      ...this.getTraceBounds(),\n      viewStart,\n      viewEnd,\n    });\n  };\n\n  getWaterfall = ({\n    viewStart,\n    viewEnd,\n  }: {\n    // in [0, 1]\n    viewEnd: number;\n    viewStart: number; // in [0, 1]\n  }) => {\n    const generateBounds = this.generateBounds({\n      viewStart,\n      viewEnd,\n    });\n\n    return this.rootSpan.getSpansList({\n      operationNameFilters: this.operationNameFilters,\n      generateBounds,\n      treeDepth: 0,\n      isLastSibling: true,\n      continuingTreeDepths: [],\n      hiddenSpanSubTrees: this.hiddenSpanSubTrees,\n      spanAncestors: new Set(),\n      filterSpans: this.filterSpans,\n      previousSiblingEndTimestamp: undefined,\n      event: this.event,\n      isOnlySibling: true,\n      spanNestedGrouping: undefined,\n      toggleNestedSpanGroup: undefined,\n      isNestedSpanGroupExpanded: false,\n      addTraceBounds: this.addTraceBounds,\n      removeTraceBounds: this.removeTraceBounds,\n    });\n  };\n}\n\nexport default WaterfallModel;\n","import {PureComponent} from 'react';\nimport {withRouter, WithRouterProps} from 'react-router';\nimport styled from '@emotion/styled';\nimport {Observer} from 'mobx-react';\n\nimport Alert from 'sentry/components/alert';\nimport GuideAnchor from 'sentry/components/assistant/guideAnchor';\nimport List from 'sentry/components/list';\nimport ListItem from 'sentry/components/list/listItem';\nimport {Panel} from 'sentry/components/panels';\nimport SearchBar from 'sentry/components/searchBar';\nimport {t, tct, tn} from 'sentry/locale';\nimport space from 'sentry/styles/space';\nimport {Organization} from 'sentry/types';\nimport {EventTransaction} from 'sentry/types/event';\nimport {objectIsEmpty} from 'sentry/utils';\nimport * as QuickTraceContext from 'sentry/utils/performance/quickTrace/quickTraceContext';\nimport {TraceError} from 'sentry/utils/performance/quickTrace/types';\nimport withOrganization from 'sentry/utils/withOrganization';\n\nimport * as AnchorLinkManager from './anchorLinkManager';\nimport Filter from './filter';\nimport TraceView from './traceView';\nimport {ParsedTraceType} from './types';\nimport {parseTrace, scrollToSpan} from './utils';\nimport WaterfallModel from './waterfallModel';\n\ntype Props = {\n  event: EventTransaction;\n  organization: Organization;\n} & WithRouterProps;\n\ntype State = {\n  parsedTrace: ParsedTraceType;\n  waterfallModel: WaterfallModel;\n};\n\nclass SpansInterface extends PureComponent<Props, State> {\n  state: State = {\n    parsedTrace: parseTrace(this.props.event),\n    waterfallModel: new WaterfallModel(this.props.event),\n  };\n\n  static getDerivedStateFromProps(props: Readonly<Props>, state: State): State {\n    if (state.waterfallModel.isEvent(props.event)) {\n      return state;\n    }\n\n    return {\n      ...state,\n      parsedTrace: parseTrace(props.event),\n      waterfallModel: new WaterfallModel(props.event),\n    };\n  }\n\n  handleSpanFilter = (searchQuery: string) => {\n    const {waterfallModel} = this.state;\n    waterfallModel.querySpanSearch(searchQuery);\n  };\n\n  renderTraceErrorsAlert({\n    isLoading,\n    errors,\n    parsedTrace,\n  }: {\n    errors: TraceError[] | undefined;\n    isLoading: boolean;\n    parsedTrace: ParsedTraceType;\n  }) {\n    if (isLoading) {\n      return null;\n    }\n\n    if (!errors || errors.length <= 0) {\n      return null;\n    }\n\n    // This is intentional as unbalanced string formatters in `tn()` are problematic\n    const label =\n      errors.length === 1\n        ? t('There is an error event associated with this transaction event.')\n        : tn(\n            `There are %s error events associated with this transaction event.`,\n            `There are %s error events associated with this transaction event.`,\n            errors.length\n          );\n\n    // mapping from span ids to the span op and the number of errors in that span\n    const errorsMap: {\n      [spanId: string]: {errorsCount: number; operation: string};\n    } = {};\n\n    errors.forEach(error => {\n      if (!errorsMap[error.span]) {\n        // first check of the error belongs to the root span\n        if (parsedTrace.rootSpanID === error.span) {\n          errorsMap[error.span] = {\n            operation: parsedTrace.op,\n            errorsCount: 0,\n          };\n        } else {\n          // since it does not belong to the root span, check if it belongs\n          // to one of the other spans in the transaction\n          const span = parsedTrace.spans.find(s => s.span_id === error.span);\n          if (!span?.op) {\n            return;\n          }\n\n          errorsMap[error.span] = {\n            operation: span.op,\n            errorsCount: 0,\n          };\n        }\n      }\n\n      errorsMap[error.span].errorsCount++;\n    });\n\n    return (\n      <AlertContainer>\n        <Alert type=\"error\" showIcon>\n          <ErrorLabel>{label}</ErrorLabel>\n          <AnchorLinkManager.Consumer>\n            {({scrollToHash}) => (\n              <List symbol=\"bullet\">\n                {Object.entries(errorsMap).map(([spanId, {operation, errorsCount}]) => (\n                  <ListItem key={spanId}>\n                    {tct('[errors] [link]', {\n                      errors: tn('%s error in ', '%s errors in ', errorsCount),\n                      link: (\n                        <ErrorLink\n                          onClick={scrollToSpan(\n                            spanId,\n                            scrollToHash,\n                            this.props.location\n                          )}\n                        >\n                          {operation}\n                        </ErrorLink>\n                      ),\n                    })}\n                  </ListItem>\n                ))}\n              </List>\n            )}\n          </AnchorLinkManager.Consumer>\n        </Alert>\n      </AlertContainer>\n    );\n  }\n\n  render() {\n    const {event, organization} = this.props;\n    const {parsedTrace, waterfallModel} = this.state;\n\n    return (\n      <Container hasErrors={!objectIsEmpty(event.errors)}>\n        <QuickTraceContext.Consumer>\n          {quickTrace => (\n            <AnchorLinkManager.Provider>\n              {this.renderTraceErrorsAlert({\n                isLoading: quickTrace?.isLoading || false,\n                errors: quickTrace?.currentEvent?.errors,\n                parsedTrace,\n              })}\n              <Observer>\n                {() => {\n                  return (\n                    <Search>\n                      <Filter\n                        operationNameCounts={waterfallModel.operationNameCounts}\n                        operationNameFilter={waterfallModel.operationNameFilters}\n                        toggleOperationNameFilter={\n                          waterfallModel.toggleOperationNameFilter\n                        }\n                        toggleAllOperationNameFilters={\n                          waterfallModel.toggleAllOperationNameFilters\n                        }\n                      />\n                      <StyledSearchBar\n                        defaultQuery=\"\"\n                        query={waterfallModel.searchQuery || ''}\n                        placeholder={t('Search for spans')}\n                        onSearch={this.handleSpanFilter}\n                      />\n                    </Search>\n                  );\n                }}\n              </Observer>\n              <Panel>\n                <Observer>\n                  {() => {\n                    return (\n                      <TraceView\n                        waterfallModel={waterfallModel}\n                        organization={organization}\n                      />\n                    );\n                  }}\n                </Observer>\n                <GuideAnchorWrapper>\n                  <GuideAnchor target=\"span_tree\" position=\"bottom\" />\n                </GuideAnchorWrapper>\n              </Panel>\n            </AnchorLinkManager.Provider>\n          )}\n        </QuickTraceContext.Consumer>\n      </Container>\n    );\n  }\n}\n\nconst GuideAnchorWrapper = styled('div')`\n  height: 0;\n  width: 0;\n  margin-left: 50%;\n`;\n\nconst Container = styled('div')<{hasErrors: boolean}>`\n  ${p =>\n    p.hasErrors &&\n    `\n  padding: ${space(2)} 0;\n\n  @media (min-width: ${p.theme.breakpoints.small}) {\n    padding: ${space(3)} 0 0 0;\n  }\n  `}\n`;\n\nconst ErrorLink = styled('a')`\n  color: ${p => p.theme.textColor};\n  :hover {\n    color: ${p => p.theme.textColor};\n  }\n`;\n\nconst Search = styled('div')`\n  display: flex;\n  width: 100%;\n  margin-bottom: ${space(1)};\n`;\n\nconst StyledSearchBar = styled(SearchBar)`\n  flex-grow: 1;\n`;\n\nconst AlertContainer = styled('div')`\n  margin-bottom: ${space(1)};\n`;\n\nconst ErrorLabel = styled('div')`\n  margin-bottom: ${space(1)};\n`;\n\nexport default withRouter(withOrganization(SpansInterface));\n","import type SvgIcon from 'sentry/icons/svgIcon';\nimport type {Color} from 'sentry/utils/theme';\n\nexport type IconProps = React.ComponentProps<typeof SvgIcon>;\n\nexport enum BreadcrumbLevelType {\n  FATAL = 'fatal',\n  ERROR = 'error',\n  WARNING = 'warning',\n  INFO = 'info',\n  DEBUG = 'debug',\n  UNDEFINED = 'undefined',\n}\n\nexport enum BreadcrumbType {\n  INFO = 'info',\n  DEBUG = 'debug',\n  MESSAGE = 'message',\n  QUERY = 'query',\n  UI = 'ui',\n  USER = 'user',\n  EXCEPTION = 'exception',\n  WARNING = 'warning',\n  ERROR = 'error',\n  DEFAULT = 'default',\n  HTTP = 'http',\n  NAVIGATION = 'navigation',\n  SYSTEM = 'system',\n  SESSION = 'session',\n  TRANSACTION = 'transaction',\n  INIT = 'init',\n}\n\ntype BreadcrumbTypeBase = {\n  level: BreadcrumbLevelType;\n  // it's recommended\n  category?: string | null;\n  event_id?: string | null;\n  message?: string;\n  timestamp?: string;\n};\n\nexport type BreadcrumbTypeSystem = {\n  action: string;\n  extras: Record<string, any>;\n  type: BreadcrumbType.SYSTEM;\n} & BreadcrumbTypeBase;\n\nexport type BreadcrumbTypeSession = {\n  action: string;\n  extras: Record<string, any>;\n  type: BreadcrumbType.SESSION;\n} & BreadcrumbTypeBase;\n\nexport type BreadcrumbTypeNavigation = {\n  type: BreadcrumbType.NAVIGATION;\n  data?: {\n    from?: string;\n    to?: string;\n  };\n} & BreadcrumbTypeBase;\n\nexport type BreadcrumbTypeHTTP = {\n  type: BreadcrumbType.HTTP;\n  data?: {\n    method?:\n      | 'POST'\n      | 'PUT'\n      | 'GET'\n      | 'HEAD'\n      | 'DELETE'\n      | 'CONNECT'\n      | 'OPTIONS'\n      | 'TRACE'\n      | 'PATCH';\n    reason?: string;\n    status_code?: number;\n    url?: string;\n  };\n} & BreadcrumbTypeBase;\n\nexport type BreadcrumbTypeDefault = {\n  type:\n    | BreadcrumbType.INFO\n    | BreadcrumbType.DEBUG\n    | BreadcrumbType.QUERY\n    | BreadcrumbType.UI\n    | BreadcrumbType.USER\n    | BreadcrumbType.EXCEPTION\n    | BreadcrumbType.WARNING\n    | BreadcrumbType.ERROR\n    | BreadcrumbType.DEFAULT\n    | BreadcrumbType.INIT\n    | BreadcrumbType.SESSION\n    | BreadcrumbType.SYSTEM\n    | BreadcrumbType.TRANSACTION;\n  data?: Record<string, any>;\n} & BreadcrumbTypeBase;\n\nexport type RawCrumb =\n  | BreadcrumbTypeNavigation\n  | BreadcrumbTypeHTTP\n  | BreadcrumbTypeDefault;\n\nexport type Crumb = RawCrumb & {\n  color: Color;\n  description: string;\n  id: number;\n};\n\nexport function isBreadcrumbTypeDefault(\n  breadcrumb: RawCrumb\n): breadcrumb is BreadcrumbTypeDefault {\n  return ![BreadcrumbType.HTTP, BreadcrumbType.NAVIGATION].includes(breadcrumb.type);\n}\n","import {createContext} from 'react';\n\nimport {QuickTraceQueryChildrenProps} from 'sentry/utils/performance/quickTrace/types';\n\nexport type QuickTraceContextChildrenProps = QuickTraceQueryChildrenProps | undefined;\n\nconst QuickTraceContext = createContext<QuickTraceContextChildrenProps>(undefined);\n\nexport const Provider = QuickTraceContext.Provider;\n\nexport const Consumer = QuickTraceContext.Consumer;\n"],"names":["type","BreadcrumbType","size","rotated","Type","color","description","error","Wrapper","title","disabled","skipWrapper","disableForVisualTest","IconWrapper","p","theme","red300","innerBorder","white","dropShadowLightest","transformCrumbs","breadcrumbs","map","breadcrumb","index","convertedCrumbType","defined","category","subcategory","split","Object","values","includes","convertCrumbType","t","getCrumbDescriptionAndColor","id","level","BreadcrumbLevelType","moduleToCategory","module","match","getVirtualCrumb","event","exception","entries","find","entry","EntryType","message","timestamp","dateCreated","value","mdl","data","levelTag","tags","tag","key","noFilter","Filter","operationNameCounts","operationNameFilter","toggleOperationNameFilter","toggleAllOperationNameFilters","checkedQuantity","operationNames","dropDownButtonProps","children","Fragment","FilterLabel","priority","hasDarkBorderBottomColor","tn","menuWidth","blendWithActor","button","isOpen","getActorProps","StyledDropdownButton","showChevron","MenuContent","onClick","stopPropagation","Header","isChecked","isIndeterminate","List","Array","from","operationName","operationCount","isActive","has","ListItem","OperationDot","backgroundColor","pickBarColor","OperationName","OperationCount","space","DropdownButton","primary","border","gray200","backgroundSecondary","gray300","fontSizeMedium","CheckboxFancy","blue300","overflowEllipsis","MINIMUM_WINDOW_SIZE","ViewHandleType","DragManager","Component","isDragging","currentDraggingHandle","leftHandlePosition","rightHandlePosition","isWindowSelectionDragging","windowSelectionInitial","windowSelectionCurrent","windowSelectionSize","viewWindowStart","viewWindowEnd","this","props","interactiveLayerRef","current","viewHandle","state","hasInteractiveLayer","PerformanceInteraction","previousUserSelect","setBodyUserSelect","userSelect","MozUserSelect","msUserSelect","webkitUserSelect","window","addEventListener","onDragMove","onDragEnd","setState","onDragStart","Left","Right","rect","rectOfContent","rawMouseX","pageX","x","width","min","max","clamp","Error","cleanUpListeners","onWindowSelectionDragMove","onWindowSelectionDragEnd","Math","abs","removeEventListener","componentWillUnmount","render","childrenProps","onLeftHandleDragStart","onRightHandleDragStart","onWindowSelectionDragStart","SpanBarCursorGuide","showCursorGuide","traceViewMouseLeft","CursorGuide","style","left","toPercent","MeasurementMarker","ROW_HEIGHT","failedThreshold","textColor","zIndex","traceView","dividerLine","INTERSECTION_THRESHOLDS","SpanBar","showDetail","createRef","deltaY","deltaX","preventDefault","onWheel","element","spanRowDOMRef","offset","getBoundingClientRect","top","scrollY","MINIMAP_CONTAINER_HEIGHT","scrollTo","componentDidMount","_mounted","storeSpanBar","connectObservers","spanTitleRef","handleWheel","passive","disconnectObservers","span","markSpanOutOfView","span_id","renderDetail","isVisible","transactions","errors","organization","isRoot","trace","registerScrollFn","scrollToHash","isGapSpan","spanTargetHash","scrollIntoView","childTransactions","relatedErrors","getBounds","generateBounds","bounds","startTimestamp","start_timestamp","endTimestamp","shouldHideSpanWarnings","isEventFromBrowserJavaScriptSDK","warning","isSpanVisibleInView","op","durationlessBrowserOps","start","end","renderMeasurements","measurements","getMeasurements","verticalMark","mark","marks","getMeasurementBounds","String","renderSpanTreeConnector","hasToggler","isLast","treeDepth","spanTreeDepth","continuingTreeDepths","showSpanTree","spanID","getSpanID","right","height","bottom","orphanBranch","connectorBars","depth","unwrapTreeDepth","TOGGLE_BORDER_BOX","isOrphanTreeDepth","push","isOrphanSpan","renderSpanTreeToggler","errored","numOfSpanChildren","chevron","direction","chevronElement","isExpanded","toggleSpanTree","renderTitle","generateContentSpanBarRef","groupOccurrence","toggleSpanGroup","toggleSiblingSpanGroup","groupType","titleFragments","Regroup","GroupType","href","spanOperationName","getSpanOperation","flatMap","Boolean","length","ref","intersectionObserver","IntersectionObserver","forEach","numOfSpans","NUM_OF_SPANS_FIT_IN_MINI_MAP","spanNumber","minimapSlider","document","getElementById","rootBounds","actualRootTop","ceil","normalizedActualTop","zoomLevel","rectRelativeToRoot","boundingClientRect","bottomYCoord","y","relativeToMinimap","features","isIntersecting","markSpanInView","panYPixels","MINIMAP_SPAN_BAR_HEIGHT","intersectionRatio","spanNumberToStopMoving","threshold","rootMargin","observe","disconnect","renderDivider","dividerHandlerChildrenProps","position","addDividerLineRef","onMouseEnter","setHover","onMouseLeave","onMouseOver","onMouseDown","getRelatedErrors","quickTrace","currentEvent","isTraceFull","filter","getChildTransactions","parent_span_id","renderErrorBadge","renderEmbeddedTransactionsBadge","toggleEmbeddedChildren","showEmbeddedChildren","transaction","containerDisplayMode","expanded","trackAnalyticsEvent","eventKey","eventName","organization_id","parseInt","orgSlug","slug","eventSlug","generateEventSlug","event_id","project","project_slug","renderWarningText","warningText","isEmbeddedTransactionTimeAdjusted","embeddedWarningText","StyledIconWarning","renderHeader","spanBarColor","spanBarHatch","duration","durationString","getHumanDuration","dividerPosition","addGhostDividerLineRef","displaySpanBar","durationDisplay","getDurationDisplay","paddingTop","toggleDisplayDetail","showStriping","display","className","renderEmbeddedChildrenState","fetchEmbeddedChildrenState","visible","showBorder","IconWarning","renderGroupedSpansToggler","spanGrouping","isSpanGroupToggler","SpanGroupBar","useRef","useEffect","currentRef","isSpanVisible","spanObj","renderGroupSpansTitle","renderSpanRectangles","e","SpanDescendantGroupBar","operationCounts","countBy","enhancedSpan","hasOthers","keys","mostFrequentOperationName","reduce","acc","operationNameKey","count","getSpanGroupBounds","getSpanGroupTimestamps","SpanRectangle","SpanRectangleOverlay","SpanSiblingGroupBar","isLastSibling","occurrence","operation","_","SpanTree","waterfallModel","toggleSpanSubTree","updateScrollState","setSpansOnTransaction","spans","shouldComponentUpdate","nextProps","dragProps","isEqual","componentDidUpdate","prevProps","filterSpans","generateInfoMessage","input","isCurrentSpanHidden","numOfSpansOutOfViewAbove","isCurrentSpanFilteredOut","numOfFilteredSpansAbove","messages","tct","generateLimitExceededMessage","parsedTrace","traceEndTimestamp","latest","hasAllSpans","viewStart","viewEnd","sum","payload","spanTree","infoMessage","spanNestedGrouping","toggleNestedSpanGroup","spanSiblingGrouping","isFirstSiblingOfGroup","hiddenSpanSubTrees","TraceViewContainer","traceViewRef","withScrollbarManager","TraceView","PureComponent","minimapInteractiveRef","virtualScrollBarContainerRef","operationNameFilters","rootSpan","getWaterfall","getTraceContext","SpanTreeModel","constructor","parentSpan","childSpans","api","Set","spanModel","spanIDs","spanAncestors","previousSiblingEndTimestamp","isOnlySibling","isNestedSpanGroupExpanded","addTraceBounds","removeTraceBounds","parentSpanID","nextSpanAncestors","add","descendantsSource","embeddedChildren","isNotLastSpanOfGroup","shouldGroup","hideSpanTree","isLastSpanOfGroup","isFirstSpanOfGroup","undefined","isArray","treeDepthEntry","spanGroupingCriteria","wrappedSpan","shouldHideSpanOfGroup","descendantContinuingTreeDepths","hiddenSpanSubTree","groupedDescendants","siblingGroupOccurrenceMap","addGroupToMap","prevSpanModel","group","groupKey","currentGroup","i","currSpanModel","descendants","groupIndex","getSpansList","getSiblingGroupKey","expandedSiblingGroups","isSpanFilteredOut","enhancedSibling","wrappedSiblings","groupedSiblingsSpan","gapSpan","generateSpanGap","child","generateTraceBounds","spanId","fetchEmbeddedTransactions","Promise","resolve","delete","traceStartTimestamp","spanChildren","makeObservable","computed","observable","action","result","Map","set","directChild","get","sort","a","b","localeCompare","sensitivity","isOrphan","url","requestPromise","method","query","then","parseTrace","startTimeDelta","generateRootSpan","parsedRootSpan","catch","Client","previousState","toggleFilter","toggleAllFilters","traceBound","traceBounds","getTraceBounds","bound","boundsGenerator","indexSearch","searchQuery","querySpanSearch","isEvent","otherEvent","transformed","indexed","pickedSpan","pick","basicValues","tagKeys","tagValues","dataKeys","dataValues","JSON","stringify","fuse","createFuzzySearch","includeMatches","location","distance","maxPatternLength","results","search","setOfSpanIDs","item","SpansInterface","WaterfallModel","renderTraceErrorsAlert","isLoading","label","errorsMap","rootSpanID","errorsCount","s","AlertContainer","showIcon","ErrorLabel","symbol","link","ErrorLink","scrollToSpan","Container","hasErrors","objectIsEmpty","Search","StyledSearchBar","defaultQuery","placeholder","onSearch","handleSpanFilter","GuideAnchorWrapper","target","breakpoints","small","SearchBar","withRouter","withOrganization","isBreadcrumbTypeDefault","HTTP","NAVIGATION","QuickTraceContext","createContext","Provider","Consumer"],"sourceRoot":""}