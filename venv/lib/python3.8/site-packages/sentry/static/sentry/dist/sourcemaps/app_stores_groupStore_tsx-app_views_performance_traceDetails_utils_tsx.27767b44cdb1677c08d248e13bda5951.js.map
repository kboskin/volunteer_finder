{"version":3,"file":"chunks/app_stores_groupStore_tsx-app_views_performance_traceDetails_utils_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/events/interfaces/spans/constants.tsx","webpack:///./app/components/events/interfaces/spans/utils.tsx","webpack:///./app/components/performance/waterfall/treeConnector.tsx","webpack:///./app/stores/groupStore.tsx","webpack:///./app/utils/performance/quickTrace/utils.tsx","webpack:///./app/utils/performance/vitals/constants.tsx","webpack:///./app/views/performance/traceDetails/utils.tsx"],"sourcesContent":["export const MINIMAP_HEIGHT = 120;\n\nexport const MINIMAP_SPAN_BAR_HEIGHT = 4;\n\nexport const NUM_OF_SPANS_FIT_IN_MINI_MAP = MINIMAP_HEIGHT / MINIMAP_SPAN_BAR_HEIGHT;\n\nexport const TIME_AXIS_HEIGHT = 20;\n\nconst SECONDARY_HEADER_HEIGHT = 20;\n\nexport const MINIMAP_CONTAINER_HEIGHT =\n  MINIMAP_HEIGHT + TIME_AXIS_HEIGHT + SECONDARY_HEADER_HEIGHT + 1;\n\nexport const VIEW_HANDLE_HEIGHT = 18;\n\nexport const MERGE_LABELS_THRESHOLD_PERCENT = 10;\n","import {browserHistory} from 'react-router';\nimport {Location} from 'history';\nimport isNumber from 'lodash/isNumber';\nimport isString from 'lodash/isString';\nimport set from 'lodash/set';\nimport moment from 'moment';\n\nimport {\n  TOGGLE_BORDER_BOX,\n  TOGGLE_BUTTON_MAX_WIDTH,\n} from 'sentry/components/performance/waterfall/treeConnector';\nimport {EntryType, EventTransaction} from 'sentry/types/event';\nimport {assert} from 'sentry/types/utils';\nimport {WEB_VITAL_DETAILS} from 'sentry/utils/performance/vitals/constants';\nimport {getPerformanceTransaction} from 'sentry/utils/performanceForSentry';\n\nimport {MERGE_LABELS_THRESHOLD_PERCENT} from './constants';\nimport {\n  EnhancedSpan,\n  GapSpanType,\n  OrphanSpanType,\n  OrphanTreeDepth,\n  ParsedTraceType,\n  ProcessedSpanType,\n  RawSpanType,\n  SpanEntry,\n  SpanType,\n  TraceContextType,\n  TreeDepthType,\n} from './types';\n\nexport const isValidSpanID = (maybeSpanID: any) =>\n  isString(maybeSpanID) && maybeSpanID.length > 0;\n\nexport const setSpansOnTransaction = (spanCount: number) => {\n  const transaction = getPerformanceTransaction();\n\n  if (!transaction || spanCount === 0) {\n    return;\n  }\n\n  const spanCountGroups = [10, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1001];\n  const spanGroup = spanCountGroups.find(g => spanCount <= g) || -1;\n\n  transaction.setTag('ui.spanCount', spanCount);\n  transaction.setTag('ui.spanCount.grouped', `<=${spanGroup}`);\n};\n\nexport type SpanBoundsType = {endTimestamp: number; startTimestamp: number};\nexport type SpanGeneratedBoundsType =\n  | {isSpanVisibleInView: boolean; type: 'TRACE_TIMESTAMPS_EQUAL'}\n  | {isSpanVisibleInView: boolean; type: 'INVALID_VIEW_WINDOW'}\n  | {\n      isSpanVisibleInView: boolean;\n      start: number;\n      type: 'TIMESTAMPS_EQUAL';\n      width: number;\n    }\n  | {\n      end: number;\n      isSpanVisibleInView: boolean;\n      start: number;\n      type: 'TIMESTAMPS_REVERSED';\n    }\n  | {\n      end: number;\n      isSpanVisibleInView: boolean;\n      start: number;\n      type: 'TIMESTAMPS_STABLE';\n    };\n\nexport type SpanViewBoundsType = {\n  isSpanVisibleInView: boolean;\n  left: undefined | number;\n  warning: undefined | string;\n  width: undefined | number;\n};\n\nconst normalizeTimestamps = (spanBounds: SpanBoundsType): SpanBoundsType => {\n  const {startTimestamp, endTimestamp} = spanBounds;\n\n  if (startTimestamp > endTimestamp) {\n    return {startTimestamp: endTimestamp, endTimestamp: startTimestamp};\n  }\n\n  return spanBounds;\n};\n\nexport enum TimestampStatus {\n  Stable,\n  Reversed,\n  Equal,\n}\n\nexport const parseSpanTimestamps = (spanBounds: SpanBoundsType): TimestampStatus => {\n  const startTimestamp: number = spanBounds.startTimestamp;\n  const endTimestamp: number = spanBounds.endTimestamp;\n\n  if (startTimestamp < endTimestamp) {\n    return TimestampStatus.Stable;\n  }\n\n  if (startTimestamp === endTimestamp) {\n    return TimestampStatus.Equal;\n  }\n\n  return TimestampStatus.Reversed;\n};\n\n// given the start and end trace timestamps, and the view window, we want to generate a function\n// that'll output the relative %'s for the width and placements relative to the left-hand side.\n//\n// The view window (viewStart and viewEnd) are percentage values (between 0% and 100%), they correspond to the window placement\n// between the start and end trace timestamps.\nexport const boundsGenerator = (bounds: {\n  // unix timestamp\n  traceEndTimestamp: number;\n  traceStartTimestamp: number;\n  // in [0, 1]\n  viewEnd: number;\n  // unix timestamp\n  viewStart: number; // in [0, 1]\n}) => {\n  const {viewStart, viewEnd} = bounds;\n\n  const {startTimestamp: traceStartTimestamp, endTimestamp: traceEndTimestamp} =\n    normalizeTimestamps({\n      startTimestamp: bounds.traceStartTimestamp,\n      endTimestamp: bounds.traceEndTimestamp,\n    });\n\n  // viewStart and viewEnd are percentage values (%) of the view window relative to the left\n  // side of the trace view minimap\n\n  // invariant: viewStart <= viewEnd\n\n  // duration of the entire trace in seconds\n  const traceDuration = traceEndTimestamp - traceStartTimestamp;\n\n  const viewStartTimestamp = traceStartTimestamp + viewStart * traceDuration;\n  const viewEndTimestamp = traceEndTimestamp - (1 - viewEnd) * traceDuration;\n  const viewDuration = viewEndTimestamp - viewStartTimestamp;\n\n  return (spanBounds: SpanBoundsType): SpanGeneratedBoundsType => {\n    // TODO: alberto.... refactor so this is impossible 😠\n    if (traceDuration <= 0) {\n      return {\n        type: 'TRACE_TIMESTAMPS_EQUAL',\n        isSpanVisibleInView: true,\n      };\n    }\n\n    if (viewDuration <= 0) {\n      return {\n        type: 'INVALID_VIEW_WINDOW',\n        isSpanVisibleInView: true,\n      };\n    }\n\n    const {startTimestamp, endTimestamp} = normalizeTimestamps(spanBounds);\n\n    const timestampStatus = parseSpanTimestamps(spanBounds);\n\n    const start = (startTimestamp - viewStartTimestamp) / viewDuration;\n    const end = (endTimestamp - viewStartTimestamp) / viewDuration;\n\n    const isSpanVisibleInView = end > 0 && start < 1;\n\n    switch (timestampStatus) {\n      case TimestampStatus.Equal: {\n        return {\n          type: 'TIMESTAMPS_EQUAL',\n          start,\n          width: 1,\n          // a span bar is visible even if they're at the extreme ends of the view selection.\n          // these edge cases are:\n          // start == end == 0, and\n          // start == end == 1\n          isSpanVisibleInView: end >= 0 && start <= 1,\n        };\n      }\n      case TimestampStatus.Reversed: {\n        return {\n          type: 'TIMESTAMPS_REVERSED',\n          start,\n          end,\n          isSpanVisibleInView,\n        };\n      }\n      case TimestampStatus.Stable: {\n        return {\n          type: 'TIMESTAMPS_STABLE',\n          start,\n          end,\n          isSpanVisibleInView,\n        };\n      }\n      default: {\n        const _exhaustiveCheck: never = timestampStatus;\n        return _exhaustiveCheck;\n      }\n    }\n  };\n};\n\nexport function generateRootSpan(trace: ParsedTraceType): RawSpanType {\n  const rootSpan: RawSpanType = {\n    trace_id: trace.traceID,\n    span_id: trace.rootSpanID,\n    parent_span_id: trace.parentSpanID,\n    start_timestamp: trace.traceStartTimestamp,\n    timestamp: trace.traceEndTimestamp,\n    op: trace.op,\n    description: trace.description,\n    data: {},\n    status: trace.rootSpanStatus,\n    hash: trace.hash,\n    exclusive_time: trace.exclusiveTime,\n  };\n\n  return rootSpan;\n}\n\n// start and end are assumed to be unix timestamps with fractional seconds\nexport function getTraceDateTimeRange(input: {end: number; start: number}): {\n  end: string;\n  start: string;\n} {\n  const start = moment\n    .unix(input.start)\n    .subtract(12, 'hours')\n    .utc()\n    .format('YYYY-MM-DDTHH:mm:ss.SSS');\n\n  const end = moment\n    .unix(input.end)\n    .add(12, 'hours')\n    .utc()\n    .format('YYYY-MM-DDTHH:mm:ss.SSS');\n\n  return {\n    start,\n    end,\n  };\n}\n\nexport function isGapSpan(span: ProcessedSpanType): span is GapSpanType {\n  if ('type' in span) {\n    return span.type === 'gap';\n  }\n\n  return false;\n}\n\nexport function isOrphanSpan(span: ProcessedSpanType): span is OrphanSpanType {\n  if ('type' in span) {\n    if (span.type === 'orphan') {\n      return true;\n    }\n\n    if (span.type === 'gap') {\n      return span.isOrphan;\n    }\n  }\n\n  return false;\n}\n\nexport function getSpanID(span: ProcessedSpanType, defaultSpanID: string = ''): string {\n  if (isGapSpan(span)) {\n    return defaultSpanID;\n  }\n\n  return span.span_id;\n}\n\nexport function getSpanOperation(span: ProcessedSpanType): string | undefined {\n  if (isGapSpan(span)) {\n    return undefined;\n  }\n\n  return span.op;\n}\n\nexport function getSpanTraceID(span: ProcessedSpanType): string {\n  if (isGapSpan(span)) {\n    return 'gap-span';\n  }\n\n  return span.trace_id;\n}\n\nexport function getSpanParentSpanID(span: ProcessedSpanType): string | undefined {\n  if (isGapSpan(span)) {\n    return 'gap-span';\n  }\n\n  return span.parent_span_id;\n}\n\nexport function getTraceContext(\n  event: Readonly<EventTransaction>\n): TraceContextType | undefined {\n  return event?.contexts?.trace;\n}\n\nexport function parseTrace(event: Readonly<EventTransaction>): ParsedTraceType {\n  const spanEntry = event.entries.find((entry: SpanEntry | any): entry is SpanEntry => {\n    return entry.type === EntryType.SPANS;\n  });\n\n  const spans: Array<RawSpanType> = spanEntry?.data ?? [];\n\n  const traceContext = getTraceContext(event);\n  const traceID = (traceContext && traceContext.trace_id) || '';\n  const rootSpanID = (traceContext && traceContext.span_id) || '';\n  const rootSpanOpName = (traceContext && traceContext.op) || 'transaction';\n  const description = traceContext && traceContext.description;\n  const parentSpanID = traceContext && traceContext.parent_span_id;\n  const rootSpanStatus = traceContext && traceContext.status;\n  const hash = traceContext && traceContext.hash;\n  const exclusiveTime = traceContext && traceContext.exclusive_time;\n\n  if (!spanEntry || spans.length <= 0) {\n    return {\n      op: rootSpanOpName,\n      childSpans: {},\n      traceStartTimestamp: event.startTimestamp,\n      traceEndTimestamp: event.endTimestamp,\n      traceID,\n      rootSpanID,\n      rootSpanStatus,\n      parentSpanID,\n      spans: [],\n      description,\n      hash,\n      exclusiveTime,\n    };\n  }\n\n  // any span may be a parent of another span\n  const potentialParents = new Set(\n    spans.map(span => {\n      return span.span_id;\n    })\n  );\n\n  // the root transaction span is a parent of all other spans\n  potentialParents.add(rootSpanID);\n\n  // we reduce spans to become an object mapping span ids to their children\n\n  const init: ParsedTraceType = {\n    op: rootSpanOpName,\n    childSpans: {},\n    traceStartTimestamp: event.startTimestamp,\n    traceEndTimestamp: event.endTimestamp,\n    traceID,\n    rootSpanID,\n    rootSpanStatus,\n    parentSpanID,\n    spans,\n    description,\n    hash,\n    exclusiveTime,\n  };\n\n  const reduced: ParsedTraceType = spans.reduce((acc, inputSpan) => {\n    let span: SpanType = inputSpan;\n\n    const parentSpanId = getSpanParentSpanID(span);\n\n    const hasParent = parentSpanId && potentialParents.has(parentSpanId);\n\n    if (!isValidSpanID(parentSpanId) || !hasParent) {\n      // this span is considered an orphan with respect to the spans within this transaction.\n      // although the span is an orphan, it's still a descendant of this transaction,\n      // so we set its parent span id to be the root transaction span's id\n      span.parent_span_id = rootSpanID;\n\n      span = {\n        type: 'orphan',\n        ...span,\n      } as OrphanSpanType;\n    }\n\n    assert(span.parent_span_id);\n\n    // get any span children whose parent_span_id is equal to span.parent_span_id,\n    // otherwise start with an empty array\n    const spanChildren: Array<SpanType> = acc.childSpans[span.parent_span_id] ?? [];\n\n    spanChildren.push(span);\n\n    set(acc.childSpans, span.parent_span_id, spanChildren);\n\n    // set trace start & end timestamps based on given span's start and end timestamps\n\n    if (!acc.traceStartTimestamp || span.start_timestamp < acc.traceStartTimestamp) {\n      acc.traceStartTimestamp = span.start_timestamp;\n    }\n\n    // establish trace end timestamp\n\n    const hasEndTimestamp = isNumber(span.timestamp);\n\n    if (!acc.traceEndTimestamp) {\n      if (hasEndTimestamp) {\n        acc.traceEndTimestamp = span.timestamp;\n        return acc;\n      }\n\n      acc.traceEndTimestamp = span.start_timestamp;\n      return acc;\n    }\n\n    if (hasEndTimestamp && span.timestamp! > acc.traceEndTimestamp) {\n      acc.traceEndTimestamp = span.timestamp;\n      return acc;\n    }\n\n    if (span.start_timestamp > acc.traceEndTimestamp) {\n      acc.traceEndTimestamp = span.start_timestamp;\n    }\n\n    return acc;\n  }, init);\n\n  // sort span children\n\n  Object.values(reduced.childSpans).forEach(spanChildren => {\n    spanChildren.sort(sortSpans);\n  });\n\n  return reduced;\n}\n\nfunction sortSpans(firstSpan: SpanType, secondSpan: SpanType) {\n  // orphan spans come after non-orphan spans.\n\n  if (isOrphanSpan(firstSpan) && !isOrphanSpan(secondSpan)) {\n    // sort secondSpan before firstSpan\n    return 1;\n  }\n\n  if (!isOrphanSpan(firstSpan) && isOrphanSpan(secondSpan)) {\n    // sort firstSpan before secondSpan\n    return -1;\n  }\n\n  // sort spans by their start timestamp in ascending order\n\n  if (firstSpan.start_timestamp < secondSpan.start_timestamp) {\n    // sort firstSpan before secondSpan\n    return -1;\n  }\n\n  if (firstSpan.start_timestamp === secondSpan.start_timestamp) {\n    return 0;\n  }\n\n  // sort secondSpan before firstSpan\n  return 1;\n}\n\nexport function isOrphanTreeDepth(\n  treeDepth: TreeDepthType\n): treeDepth is OrphanTreeDepth {\n  if (typeof treeDepth === 'number') {\n    return false;\n  }\n  return treeDepth?.type === 'orphan';\n}\n\nexport function unwrapTreeDepth(treeDepth: TreeDepthType): number {\n  if (isOrphanTreeDepth(treeDepth)) {\n    return treeDepth.depth;\n  }\n\n  return treeDepth;\n}\n\nexport function isEventFromBrowserJavaScriptSDK(event: EventTransaction): boolean {\n  const sdkName = event.sdk?.name;\n  if (!sdkName) {\n    return false;\n  }\n  // based on https://github.com/getsentry/sentry-javascript/blob/master/packages/browser/src/version.ts\n  return [\n    'sentry.javascript.browser',\n    'sentry.javascript.react',\n    'sentry.javascript.gatsby',\n    'sentry.javascript.ember',\n    'sentry.javascript.vue',\n    'sentry.javascript.angular',\n    'sentry.javascript.nextjs',\n    'sentry.javascript.electron',\n  ].includes(sdkName.toLowerCase());\n}\n\n// Durationless ops from: https://github.com/getsentry/sentry-javascript/blob/0defcdcc2dfe719343efc359d58c3f90743da2cd/packages/apm/src/integrations/tracing.ts#L629-L688\n// PerformanceMark: Duration is 0 as per https://developer.mozilla.org/en-US/docs/Web/API/PerformanceMark\n// PerformancePaintTiming: Duration is 0 as per https://developer.mozilla.org/en-US/docs/Web/API/PerformancePaintTiming\nexport const durationlessBrowserOps = ['mark', 'paint'];\n\ntype Measurements = {\n  [name: string]: {\n    timestamp: number;\n    value: number | undefined;\n  };\n};\n\ntype VerticalMark = {\n  failedThreshold: boolean;\n  marks: Measurements;\n};\n\nfunction hasFailedThreshold(marks: Measurements): boolean {\n  const names = Object.keys(marks);\n  const records = Object.values(WEB_VITAL_DETAILS).filter(vital =>\n    names.includes(vital.slug)\n  );\n\n  return records.some(record => {\n    const {value} = marks[record.slug];\n    if (typeof value === 'number' && typeof record.poorThreshold === 'number') {\n      return value >= record.poorThreshold;\n    }\n    return false;\n  });\n}\n\nexport function getMeasurements(\n  event: EventTransaction,\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n): Map<number, VerticalMark> {\n  if (!event.measurements) {\n    return new Map();\n  }\n\n  const measurements = Object.keys(event.measurements)\n    .filter(name => name.startsWith('mark.'))\n    .map(name => {\n      const slug = name.slice('mark.'.length);\n      const associatedMeasurement = event.measurements![slug];\n      return {\n        name,\n        timestamp: event.measurements![name].value,\n        value: associatedMeasurement ? associatedMeasurement.value : undefined,\n      };\n    });\n\n  const mergedMeasurements = new Map<number, VerticalMark>();\n\n  measurements.forEach(measurement => {\n    const name = measurement.name.slice('mark.'.length);\n    const value = measurement.value;\n\n    const bounds = generateBounds({\n      startTimestamp: measurement.timestamp,\n      endTimestamp: measurement.timestamp,\n    });\n\n    // This condition will never be hit, since we're using the same value for start and end in generateBounds\n    // I've put this condition here to prevent the TS linter from complaining\n    if (bounds.type !== 'TIMESTAMPS_EQUAL') {\n      return;\n    }\n\n    const roundedPos = Math.round(bounds.start * 100);\n\n    // Compare this position with the position of the other measurements, to determine if\n    // they are close enough to be bucketed together\n\n    for (const [otherPos] of mergedMeasurements) {\n      const positionDelta = Math.abs(otherPos - roundedPos);\n      if (positionDelta <= MERGE_LABELS_THRESHOLD_PERCENT) {\n        const verticalMark = mergedMeasurements.get(otherPos)!;\n\n        verticalMark.marks = {\n          ...verticalMark.marks,\n          [name]: {\n            value,\n            timestamp: measurement.timestamp,\n          },\n        };\n\n        if (!verticalMark.failedThreshold) {\n          verticalMark.failedThreshold = hasFailedThreshold(verticalMark.marks);\n        }\n\n        mergedMeasurements.set(otherPos, verticalMark);\n        return;\n      }\n    }\n\n    const marks = {\n      [name]: {value, timestamp: measurement.timestamp},\n    };\n\n    mergedMeasurements.set(roundedPos, {\n      marks,\n      failedThreshold: hasFailedThreshold(marks),\n    });\n  });\n  return mergedMeasurements;\n}\n\nexport function getMeasurementBounds(\n  timestamp: number,\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n): SpanViewBoundsType {\n  const bounds = generateBounds({\n    startTimestamp: timestamp,\n    endTimestamp: timestamp,\n  });\n\n  switch (bounds.type) {\n    case 'TRACE_TIMESTAMPS_EQUAL':\n    case 'INVALID_VIEW_WINDOW': {\n      return {\n        warning: undefined,\n        left: undefined,\n        width: undefined,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_EQUAL': {\n      return {\n        warning: undefined,\n        left: bounds.start,\n        width: 0.00001,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_REVERSED': {\n      return {\n        warning: undefined,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_STABLE': {\n      return {\n        warning: void 0,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = bounds;\n      return _exhaustiveCheck;\n    }\n  }\n}\n\nexport function scrollToSpan(\n  spanId: string,\n  scrollToHash: (hash: string) => void,\n  location: Location\n) {\n  return (e: React.MouseEvent<Element>) => {\n    // do not use the default anchor behaviour\n    // because it will be hidden behind the minimap\n    e.preventDefault();\n\n    const hash = spanTargetHash(spanId);\n\n    scrollToHash(hash);\n\n    // TODO(txiao): This is causing a rerender of the whole page,\n    // which can be slow.\n    //\n    // make sure to update the location\n    browserHistory.push({\n      ...location,\n      hash,\n    });\n  };\n}\n\nexport function spanTargetHash(spanId: string): string {\n  return `#span-${spanId}`;\n}\n\nexport function getSiblingGroupKey(span: SpanType, occurrence?: number): string {\n  if (occurrence !== undefined) {\n    return `${span.op}.${span.description}.${occurrence}`;\n  }\n\n  return `${span.op}.${span.description}`;\n}\n\nexport function getSpanGroupTimestamps(spanGroup: EnhancedSpan[]) {\n  return spanGroup.reduce(\n    (acc, spanGroupItem) => {\n      const {start_timestamp, timestamp} = spanGroupItem.span;\n\n      let newStartTimestamp = acc.startTimestamp;\n      let newEndTimestamp = acc.endTimestamp;\n\n      if (start_timestamp < newStartTimestamp) {\n        newStartTimestamp = start_timestamp;\n      }\n\n      if (newEndTimestamp < timestamp) {\n        newEndTimestamp = timestamp;\n      }\n\n      return {\n        startTimestamp: newStartTimestamp,\n        endTimestamp: newEndTimestamp,\n      };\n    },\n    {\n      startTimestamp: spanGroup[0].span.start_timestamp,\n      endTimestamp: spanGroup[0].span.timestamp,\n    }\n  );\n}\n\nexport function getSpanGroupBounds(\n  spanGroup: EnhancedSpan[],\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n): SpanViewBoundsType {\n  const {startTimestamp, endTimestamp} = getSpanGroupTimestamps(spanGroup);\n\n  const bounds = generateBounds({\n    startTimestamp,\n    endTimestamp,\n  });\n\n  switch (bounds.type) {\n    case 'TRACE_TIMESTAMPS_EQUAL':\n    case 'INVALID_VIEW_WINDOW': {\n      return {\n        warning: void 0,\n        left: void 0,\n        width: void 0,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_EQUAL': {\n      return {\n        warning: void 0,\n        left: bounds.start,\n        width: 0.00001,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_REVERSED':\n    case 'TIMESTAMPS_STABLE': {\n      return {\n        warning: void 0,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = bounds;\n      return _exhaustiveCheck;\n    }\n  }\n}\n\nexport class SpansInViewMap {\n  spanDepthsInView: Map<string, number>;\n  treeDepthSum: number;\n  length: number;\n  isRootSpanInView: boolean;\n\n  constructor() {\n    this.spanDepthsInView = new Map();\n    this.treeDepthSum = 0;\n    this.length = 0;\n    this.isRootSpanInView = true;\n  }\n\n  /**\n   *\n   * @param spanId\n   * @param treeDepth\n   * @returns false if the span is already stored, true otherwise\n   */\n  addSpan(spanId: string, treeDepth: number): boolean {\n    if (this.spanDepthsInView.has(spanId)) {\n      return false;\n    }\n\n    this.spanDepthsInView.set(spanId, treeDepth);\n    this.length += 1;\n    this.treeDepthSum += treeDepth;\n\n    if (treeDepth === 0) {\n      this.isRootSpanInView = true;\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param spanId\n   * @returns false if the span does not exist within the span, true otherwise\n   */\n  removeSpan(spanId: string): boolean {\n    if (!this.spanDepthsInView.has(spanId)) {\n      return false;\n    }\n\n    const treeDepth = this.spanDepthsInView.get(spanId);\n    this.spanDepthsInView.delete(spanId);\n    this.length -= 1;\n    this.treeDepthSum -= treeDepth!;\n\n    if (treeDepth === 0) {\n      this.isRootSpanInView = false;\n    }\n\n    return true;\n  }\n\n  has(spanId: string) {\n    return this.spanDepthsInView.has(spanId);\n  }\n\n  getScrollVal() {\n    if (this.isRootSpanInView) {\n      return 0;\n    }\n\n    const avgDepth = Math.round(this.treeDepthSum / this.length);\n    return avgDepth * (TOGGLE_BORDER_BOX / 2) - TOGGLE_BUTTON_MAX_WIDTH / 2;\n  }\n}\n","import styled from '@emotion/styled';\n\nimport {ROW_HEIGHT} from 'sentry/components/performance/waterfall/constants';\nimport {getToggleTheme} from 'sentry/components/performance/waterfall/utils';\nimport {IconChevron} from 'sentry/icons';\nimport space from 'sentry/styles/space';\n\nconst TOGGLE_BUTTON_MARGIN_RIGHT = 16;\nexport const TOGGLE_BUTTON_MAX_WIDTH = 30;\nexport const TOGGLE_BORDER_BOX = TOGGLE_BUTTON_MAX_WIDTH + TOGGLE_BUTTON_MARGIN_RIGHT;\nconst TREE_TOGGLE_CONTAINER_WIDTH = 40;\n\nexport const ConnectorBar = styled('div')<{orphanBranch: boolean}>`\n  height: 250%;\n\n  border-left: 2px ${p => (p.orphanBranch ? 'dashed' : 'solid')} ${p => p.theme.border};\n  position: absolute;\n  top: 0;\n`;\n\ntype TogglerTypes = {\n  hasToggler?: boolean;\n  isLast?: boolean;\n};\n\nexport const TreeConnector = styled('div')<TogglerTypes & {orphanBranch: boolean}>`\n  height: ${p => (p.isLast ? ROW_HEIGHT / 2 + 1 : ROW_HEIGHT)}px;\n  width: 100%;\n  border-left: ${p => `2px ${p.orphanBranch ? 'dashed' : 'solid'} ${p.theme.border};`};\n  position: absolute;\n  top: 0;\n\n  ${p =>\n    p.isLast\n      ? `\n      border-bottom: 2px ${p.orphanBranch ? 'dashed' : 'solid'} ${p.theme.border};\n      border-bottom-left-radius: ${p.theme.borderRadius};`\n      : `\n      &:before {\n        content: '';\n        height: 2px;\n        left: -2px;\n        border-bottom: 2px ${p.orphanBranch ? 'dashed' : 'solid'} ${p.theme.border};\n        width: calc(100% - 2px);\n        position: absolute;\n        bottom: calc(50% - 1px);\n      }`}\n\n  &:after {\n    content: '';\n    background-color: ${p => p.theme.border};\n    border-radius: 50%;\n    height: 6px;\n    width: 6px;\n    position: absolute;\n    right: 0;\n    top: ${ROW_HEIGHT / 2 - 3}px;\n  }\n`;\n\ntype SpanTreeTogglerAndDivProps = {\n  disabled: boolean;\n  errored: boolean;\n  isExpanded: boolean;\n  isSpanGroupToggler?: boolean;\n};\n\nexport const TreeToggle = styled('div')<SpanTreeTogglerAndDivProps>`\n  height: 16px;\n  white-space: nowrap;\n  min-width: 30px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 99px;\n  padding: 0px ${space(0.5)};\n  transition: all 0.15s ease-in-out;\n  font-size: 10px;\n  line-height: 0;\n  z-index: 1;\n  box-shadow: ${p => p.theme.dropShadowLightest};\n\n  ${p => getToggleTheme(p)}\n`;\n\nexport const TreeToggleContainer = styled('div')<TogglerTypes>`\n  position: relative;\n  height: ${ROW_HEIGHT}px;\n  width: ${TREE_TOGGLE_CONTAINER_WIDTH}px;\n  min-width: ${TREE_TOGGLE_CONTAINER_WIDTH}px;\n  margin-right: ${space(1)};\n  z-index: ${p => p.theme.zIndex.traceView.spanTreeToggler};\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n`;\n\nexport const TreeToggleIcon = styled(IconChevron)`\n  width: 7px;\n  margin-left: ${space(0.25)};\n`;\n","import isArray from 'lodash/isArray';\nimport isUndefined from 'lodash/isUndefined';\nimport {createStore, StoreDefinition} from 'reflux';\n\nimport GroupActions from 'sentry/actions/groupActions';\nimport {t} from 'sentry/locale';\nimport IndicatorStore from 'sentry/stores/indicatorStore';\nimport {\n  Activity,\n  BaseGroup,\n  Group,\n  GroupCollapseRelease,\n  GroupRelease,\n  GroupStats,\n} from 'sentry/types';\nimport {makeSafeRefluxStore} from 'sentry/utils/makeSafeRefluxStore';\n\nfunction showAlert(msg, type) {\n  IndicatorStore.addMessage(msg, type, {duration: 4000});\n}\n\n// TODO(ts) Type this any better.\ntype Change = [string, string, any];\n\nclass PendingChangeQueue {\n  changes: Change[] = [];\n\n  getForItem(itemId: string) {\n    return this.changes.filter((change: Change) => change[1] === itemId);\n  }\n\n  push(changeId: string, itemId: string, data: any) {\n    this.changes.push([changeId, itemId, data]);\n  }\n\n  remove(changeId: string, itemId?: string) {\n    this.changes = this.changes.filter(\n      change => change[0] !== changeId || change[1] !== itemId\n    );\n  }\n\n  forEach(...args: any[]) {\n    this.changes.forEach.apply(this.changes, args);\n  }\n}\n\ntype Item = BaseGroup | Group | GroupCollapseRelease;\n\ninterface InternalDefinition {\n  addActivity: (groupId: string, data: Activity, index?: number) => void;\n  indexOfActivity: (groupId: string, id: string) => number;\n  items: Item[];\n\n  pendingChanges: PendingChangeQueue;\n  removeActivity: (groupId: string, id: string) => number;\n  statuses: Record<string, Record<string, boolean>>;\n  updateActivity: (groupId: string, id: string, data: Partial<Activity>) => void;\n}\n\ninterface GroupStoreDefinition extends StoreDefinition, InternalDefinition {\n  add: (items: Item[]) => void;\n  addStatus: (id: string, status: string) => void;\n  clearStatus: (id: string, status: string) => void;\n  get: (id: string) => Item | undefined;\n  getAllItemIds: () => string[];\n  getAllItems: () => Item[];\n  hasStatus: (id: string, status: string) => boolean;\n  init: () => void;\n  loadInitialData: (items: Item[]) => void;\n  onAssignTo: (changeId: string, itemId: string, data: any) => void;\n  onAssignToError: (changeId: string, itemId: string, error: Error) => void;\n  onAssignToSuccess: (changeId: string, itemId: string, response: any) => void;\n  onDelete: (changeId: string, itemIds: string[]) => void;\n  onDeleteError: (changeId: string, itemIds: string[], error: Error) => void;\n  onDeleteSuccess: (changeId: string, itemIds: string[], response: any) => void;\n  onDiscard: (changeId: string, itemId: string) => void;\n  onDiscardError: (changeId: string, itemId: string, response: any) => void;\n  onDiscardSuccess: (changeId: string, itemId: string, response: any) => void;\n  onMerge: (changeId: string, itemIds: string[]) => void;\n  onMergeError: (changeId: string, itemIds: string[], response: any) => void;\n  onMergeSuccess: (changeId: string, itemIds: string[], response: any) => void;\n  onPopulateReleases: (itemId: string, releaseData: GroupRelease) => void;\n  onPopulateStats: (itemIds: string[], response: GroupStats[]) => void;\n  onUpdate: (changeId: string, itemIds: string[], data: any) => void;\n  onUpdateError: (\n    changeId: string,\n    itemIds: string[],\n    error: Error,\n    silent: boolean\n  ) => void;\n  onUpdateSuccess: (\n    changeId: string,\n    itemIds: string[],\n    response: Partial<Group>\n  ) => void;\n  remove: (itemIds: string[]) => void;\n  reset: () => void;\n}\n\nconst storeConfig: GroupStoreDefinition = {\n  listenables: [GroupActions],\n  pendingChanges: new PendingChangeQueue(),\n  items: [],\n  statuses: {},\n\n  init() {\n    this.reset();\n  },\n\n  reset() {\n    this.pendingChanges = new PendingChangeQueue();\n    this.items = [];\n    this.statuses = {};\n  },\n\n  // TODO(dcramer): this should actually come from an action of some sorts\n  loadInitialData(items) {\n    this.reset();\n\n    const itemIds = new Set<string>();\n    items.forEach(item => {\n      itemIds.add(item.id);\n      this.items.push(item);\n    });\n\n    this.trigger(itemIds);\n  },\n\n  add(items) {\n    if (!isArray(items)) {\n      items = [items];\n    }\n\n    const itemsById = {};\n    const itemIds = new Set<string>();\n    items.forEach(item => {\n      itemsById[item.id] = item;\n      itemIds.add(item.id);\n    });\n\n    // See if any existing items are updated by this new set of items\n    this.items.forEach((item, idx) => {\n      if (itemsById[item.id]) {\n        this.items[idx] = {\n          ...item,\n          ...itemsById[item.id],\n        };\n        delete itemsById[item.id];\n      }\n    });\n\n    // New items\n    for (const itemId in itemsById) {\n      this.items.push(itemsById[itemId]);\n    }\n\n    this.trigger(itemIds);\n  },\n\n  remove(itemIds) {\n    this.items = this.items.filter(item => !itemIds.includes(item.id));\n\n    this.trigger(new Set(itemIds));\n  },\n\n  addStatus(id, status) {\n    if (isUndefined(this.statuses[id])) {\n      this.statuses[id] = {};\n    }\n    this.statuses[id][status] = true;\n  },\n\n  clearStatus(id, status) {\n    if (isUndefined(this.statuses[id])) {\n      return;\n    }\n    this.statuses[id][status] = false;\n  },\n\n  hasStatus(id, status) {\n    if (isUndefined(this.statuses[id])) {\n      return false;\n    }\n    return this.statuses[id][status] || false;\n  },\n\n  indexOfActivity(group_id, id) {\n    const group = this.get(group_id);\n    if (!group) {\n      return -1;\n    }\n\n    for (let i = 0; i < group.activity.length; i++) {\n      if (group.activity[i].id === id) {\n        return i;\n      }\n    }\n    return -1;\n  },\n\n  addActivity(id, data, index = -1) {\n    const group = this.get(id);\n    if (!group) {\n      return;\n    }\n\n    // insert into beginning by default\n    if (index === -1) {\n      group.activity.unshift(data);\n    } else {\n      group.activity.splice(index, 0, data);\n    }\n    if (data.type === 'note') {\n      group.numComments++;\n    }\n\n    this.trigger(new Set([id]));\n  },\n\n  updateActivity(group_id, id, data) {\n    const group = this.get(group_id);\n    if (!group) {\n      return;\n    }\n\n    const index = this.indexOfActivity(group_id, id);\n    if (index === -1) {\n      return;\n    }\n\n    // Here, we want to merge the new `data` being passed in\n    // into the existing `data` object. This effectively\n    // allows passing in an object of only changes.\n    group.activity[index].data = Object.assign(group.activity[index].data, data);\n    this.trigger(new Set([group.id]));\n  },\n\n  removeActivity(group_id, id) {\n    const group = this.get(group_id);\n    if (!group) {\n      return -1;\n    }\n\n    const index = this.indexOfActivity(group.id, id);\n    if (index === -1) {\n      return -1;\n    }\n\n    const activity = group.activity.splice(index, 1);\n\n    if (activity[0].type === 'note') {\n      group.numComments--;\n    }\n\n    this.trigger(new Set([group.id]));\n    return index;\n  },\n\n  get(id) {\n    // TODO(ts) This needs to be constrained further. It was left as any\n    // because the PendingChanges signatures and this were not aligned.\n    const pendingForId: any[] = [];\n    this.pendingChanges.forEach(change => {\n      if (change.id === id) {\n        pendingForId.push(change);\n      }\n    });\n\n    for (let i = 0; i < this.items.length; i++) {\n      if (this.items[i].id === id) {\n        let rItem = this.items[i];\n        if (pendingForId.length) {\n          // copy the object so dirty state doesnt mutate original\n          rItem = {...rItem};\n\n          for (let c = 0; c < pendingForId.length; c++) {\n            rItem = {\n              ...rItem,\n              ...pendingForId[c].params,\n            };\n          }\n        }\n        return rItem;\n      }\n    }\n    return undefined;\n  },\n\n  getAllItemIds() {\n    return this.items.map(item => item.id);\n  },\n\n  getAllItems() {\n    // regroup pending changes by their itemID\n    const pendingById = {};\n    this.pendingChanges.forEach(change => {\n      if (isUndefined(pendingById[change.id])) {\n        pendingById[change.id] = [];\n      }\n      pendingById[change.id].push(change);\n    });\n\n    return this.items.map(item => {\n      let rItem = item;\n      if (!isUndefined(pendingById[item.id])) {\n        // copy the object so dirty state doesnt mutate original\n        rItem = {...rItem};\n        pendingById[item.id].forEach(change => {\n          rItem = {\n            ...rItem,\n            ...change.params,\n          };\n        });\n      }\n      return rItem;\n    });\n  },\n\n  onAssignTo(_changeId, itemId, _data) {\n    this.addStatus(itemId, 'assignTo');\n    this.trigger(new Set([itemId]));\n  },\n\n  // TODO(dcramer): This is not really the best place for this\n  onAssignToError(_changeId, itemId, _error) {\n    this.clearStatus(itemId, 'assignTo');\n    showAlert(t('Unable to change assignee. Please try again.'), 'error');\n  },\n\n  onAssignToSuccess(_changeId, itemId, response) {\n    const item = this.get(itemId);\n    if (!item) {\n      return;\n    }\n    item.assignedTo = response.assignedTo;\n    this.clearStatus(itemId, 'assignTo');\n    this.trigger(new Set([itemId]));\n  },\n\n  onDelete(_changeId, itemIds) {\n    itemIds = this._itemIdsOrAll(itemIds);\n    itemIds.forEach(itemId => {\n      this.addStatus(itemId, 'delete');\n    });\n    this.trigger(new Set(itemIds));\n  },\n\n  onDeleteError(_changeId, itemIds, _response) {\n    showAlert(t('Unable to delete events. Please try again.'), 'error');\n\n    if (!itemIds) {\n      return;\n    }\n\n    itemIds.forEach(itemId => {\n      this.clearStatus(itemId, 'delete');\n    });\n    this.trigger(new Set(itemIds));\n  },\n\n  onDeleteSuccess(_changeId, itemIds, _response) {\n    itemIds = this._itemIdsOrAll(itemIds);\n\n    if (itemIds.length > 1) {\n      showAlert(t(`Deleted ${itemIds.length} Issues`), 'success');\n    } else {\n      const shortId = itemIds.map(item => GroupStore.get(item)?.shortId).join('');\n      showAlert(t(`Deleted ${shortId}`), 'success');\n    }\n\n    const itemIdSet = new Set(itemIds);\n    itemIds.forEach(itemId => {\n      delete this.statuses[itemId];\n      this.clearStatus(itemId, 'delete');\n    });\n    this.items = this.items.filter(item => !itemIdSet.has(item.id));\n    this.trigger(new Set(itemIds));\n  },\n\n  onDiscard(_changeId, itemId) {\n    this.addStatus(itemId, 'discard');\n    this.trigger(new Set([itemId]));\n  },\n\n  onDiscardError(_changeId, itemId, _response) {\n    this.clearStatus(itemId, 'discard');\n    showAlert(t('Unable to discard event. Please try again.'), 'error');\n    this.trigger(new Set([itemId]));\n  },\n\n  onDiscardSuccess(_changeId, itemId, _response) {\n    delete this.statuses[itemId];\n    this.clearStatus(itemId, 'discard');\n    this.items = this.items.filter(item => item.id !== itemId);\n    showAlert(t('Similar events will be filtered and discarded.'), 'success');\n    this.trigger(new Set([itemId]));\n  },\n\n  onMerge(_changeId, itemIds) {\n    itemIds = this._itemIdsOrAll(itemIds);\n\n    itemIds.forEach(itemId => {\n      this.addStatus(itemId, 'merge');\n    });\n    // XXX(billy): Not sure if this is a bug or not but do we need to publish all itemIds?\n    // Seems like we only need to publish parent id\n    this.trigger(new Set(itemIds));\n  },\n\n  onMergeError(_changeId, itemIds, _response) {\n    itemIds = this._itemIdsOrAll(itemIds);\n\n    itemIds.forEach(itemId => {\n      this.clearStatus(itemId, 'merge');\n    });\n    showAlert(t('Unable to merge events. Please try again.'), 'error');\n    this.trigger(new Set(itemIds));\n  },\n\n  onMergeSuccess(_changeId, mergedIds, response) {\n    mergedIds = this._itemIdsOrAll(mergedIds); // everything on page\n\n    mergedIds.forEach(itemId => {\n      this.clearStatus(itemId, 'merge');\n    });\n\n    // Remove all but parent id (items were merged into this one)\n    const mergedIdSet = new Set(mergedIds);\n\n    // Looks like the `PUT /api/0/projects/:orgId/:projectId/issues/` endpoint\n    // actually returns a 204, so there is no `response` body\n    this.items = this.items.filter(\n      item =>\n        !mergedIdSet.has(item.id) ||\n        (response && response.merge && item.id === response.merge.parent)\n    );\n\n    showAlert(t(`Merged ${mergedIds.length} Issues`), 'success');\n    this.trigger(new Set(mergedIds));\n  },\n\n  /**\n   * If itemIds is undefined, returns all ids in the store\n   */\n  _itemIdsOrAll(itemIds) {\n    if (isUndefined(itemIds)) {\n      itemIds = this.items.map(item => item.id);\n    }\n    return itemIds;\n  },\n\n  onUpdate(changeId, itemIds, data) {\n    itemIds = this._itemIdsOrAll(itemIds);\n\n    itemIds.forEach(itemId => {\n      this.addStatus(itemId, 'update');\n      this.pendingChanges.push(changeId, itemId, data);\n    });\n    this.trigger(new Set(itemIds));\n  },\n\n  onUpdateError(changeId, itemIds, _error, failSilently) {\n    itemIds = this._itemIdsOrAll(itemIds);\n\n    this.pendingChanges.remove(changeId);\n    itemIds.forEach(itemId => {\n      this.clearStatus(itemId, 'update');\n    });\n    if (!failSilently) {\n      showAlert(t('Unable to update events. Please try again.'), 'error');\n    }\n    this.trigger(new Set(itemIds));\n  },\n\n  onUpdateSuccess(changeId, itemIds, response) {\n    itemIds = this._itemIdsOrAll(itemIds);\n\n    this.items.forEach((item, idx) => {\n      if (itemIds.indexOf(item.id) !== -1) {\n        this.items[idx] = {\n          ...item,\n          ...response,\n        };\n        this.clearStatus(item.id, 'update');\n      }\n    });\n    this.pendingChanges.remove(changeId);\n    this.trigger(new Set(itemIds));\n  },\n\n  onPopulateStats(itemIds: string[], response: GroupStats[]) {\n    // Organize stats by id\n    const groupStatsMap = response.reduce((map, stats) => {\n      map[stats.id] = stats;\n      return map;\n    }, {});\n\n    this.items.forEach((item, idx) => {\n      if (itemIds.includes(item.id)) {\n        this.items[idx] = {\n          ...item,\n          ...groupStatsMap[item.id],\n        };\n      }\n    });\n    this.trigger(new Set(this.items.map(item => item.id)));\n  },\n\n  onPopulateReleases(itemId: string, releaseData: GroupRelease) {\n    this.items.forEach((item, idx) => {\n      if (item.id === itemId) {\n        this.items[idx] = {\n          ...item,\n          ...releaseData,\n        };\n      }\n    });\n    this.trigger(new Set([itemId]));\n  },\n};\n\nconst GroupStore = createStore(makeSafeRefluxStore(storeConfig));\nexport default GroupStore;\n","import omit from 'lodash/omit';\nimport moment from 'moment-timezone';\n\nimport {getTraceDateTimeRange} from 'sentry/components/events/interfaces/spans/utils';\nimport {ALL_ACCESS_PROJECTS} from 'sentry/constants/pageFilters';\nimport {OrganizationSummary} from 'sentry/types';\nimport {Event, EventTransaction} from 'sentry/types/event';\nimport {trackAnalyticsEvent} from 'sentry/utils/analytics';\nimport EventView from 'sentry/utils/discover/eventView';\nimport {DiscoverQueryProps} from 'sentry/utils/discover/genericDiscoverQuery';\nimport {\n  QuickTrace,\n  QuickTraceEvent,\n  TraceFull,\n  TraceFullDetailed,\n  TraceLite,\n} from 'sentry/utils/performance/quickTrace/types';\n\nexport function isTransaction(event: Event): event is EventTransaction {\n  return event.type === 'transaction';\n}\n\n/**\n * An event can be an error or a transaction. We need to check whether the current\n * event id is in the list of errors as well\n */\nexport function isCurrentEvent(\n  event: TraceFull | QuickTraceEvent,\n  currentEvent: Event\n): boolean {\n  if (isTransaction(currentEvent)) {\n    return event.event_id === currentEvent.id;\n  }\n  return (\n    event.errors !== undefined && event.errors.some(e => e.event_id === currentEvent.id)\n  );\n}\n\ntype PathNode = {\n  event: TraceFull;\n  path: TraceLite;\n};\n\n/**\n * The `events-full` endpoint returns the full trace containing the specified event.\n * This means any sibling paths in the trace will also be returned.\n *\n * This method strips away these sibling paths leaving only the path from the root to\n * the specified event and all of its children/descendants.\n *\n * This method additionally flattens the trace into an array of the transactions in\n * the trace.\n */\nexport function flattenRelevantPaths(\n  currentEvent: Event,\n  traceFull: TraceFull\n): TraceLite {\n  const relevantPath: TraceLite = [];\n  const events: TraceFull[] = [];\n\n  /**\n   * First find a path from the root transaction to the current transaction via\n   * a breadth first search. This adds all transactions from the root to the\n   * current transaction (excluding the current transaction itself), to the\n   * relevant path.\n   */\n  const paths: PathNode[] = [{event: traceFull, path: []}];\n  while (paths.length) {\n    const current = paths.shift()!;\n    if (isCurrentEvent(current.event, currentEvent)) {\n      for (const node of current.path) {\n        relevantPath.push(node);\n      }\n      events.push(current.event);\n    } else {\n      const path = [...current.path, simplifyEvent(current.event)];\n      for (const child of current.event.children) {\n        paths.push({event: child, path});\n      }\n    }\n  }\n\n  if (!events.length) {\n    throw new Error('No relevant path exists!');\n  }\n\n  /**\n   * Traverse all transactions from current transaction onwards and add\n   * them all to the relevant path.\n   */\n  while (events.length) {\n    const current = events.shift()!;\n    for (const child of current.children) {\n      events.push(child);\n    }\n    relevantPath.push(simplifyEvent(current));\n  }\n\n  return relevantPath;\n}\n\nfunction simplifyEvent(event: TraceFull): QuickTraceEvent {\n  return omit(event, ['children']);\n}\n\ntype ParsedQuickTrace = {\n  /**\n   * `[]` represents the lack of ancestors in a full trace navigator\n   * `null` represents the uncertainty of ancestors in a lite trace navigator\n   */\n  ancestors: QuickTraceEvent[] | null;\n  /**\n   * `[]` represents the lack of children in a full/lite trace navigator\n   */\n  children: QuickTraceEvent[];\n  current: QuickTraceEvent;\n  /**\n   * `[]` represents the lack of descendants in a full trace navigator\n   * `null` represents the uncertainty of descendants in a lite trace navigator\n   */\n  descendants: QuickTraceEvent[] | null;\n  /**\n   * `null` represents either the lack of a direct parent or the uncertainty\n   * of what the parent is\n   */\n  parent: QuickTraceEvent | null;\n  /**\n   * `null` represents the lack of a root. It may still have a parent\n   */\n  root: QuickTraceEvent | null;\n};\n\nexport function parseQuickTrace(\n  quickTrace: QuickTrace,\n  event: Event,\n  organization: OrganizationSummary\n): ParsedQuickTrace | null {\n  const {type, trace} = quickTrace;\n\n  if (type === 'empty' || trace === null) {\n    throw new Error('Current event not in trace navigator!');\n  }\n\n  const isFullTrace = type === 'full';\n\n  const current = trace.find(e => isCurrentEvent(e, event)) ?? null;\n  if (current === null) {\n    throw new Error('Current event not in trace navigator!');\n  }\n\n  /**\n   * The parent event is the direct ancestor of the current event.\n   * This takes priority over the root, meaning if the parent is\n   * the root of the trace, this favours showing it as the parent.\n   */\n  const parent = current.parent_event_id\n    ? trace.find(e => e.event_id === current.parent_event_id) ?? null\n    : null;\n\n  /**\n   * The root event is the first event in the trace. This has lower priority\n   * than the parent event, meaning if the root event is the parent event of\n   * the current event, this favours showing it as the parent event.\n   */\n  const root =\n    trace.find(\n      e =>\n        // a root can't be the current event\n        e.event_id !== current.event_id &&\n        // a root can't be the direct parent\n        e.event_id !== parent?.event_id &&\n        // a root has to to be the first generation\n        e.generation === 0\n    ) ?? null;\n\n  const isChildren = e => e.parent_event_id === current.event_id;\n\n  const isDescendant = e =>\n    // the current generation needs to be known to determine a descendant\n    current.generation !== null &&\n    // the event's generation needs to be known to determine a descendant\n    e.generation !== null &&\n    // a descendant is the generation after the direct children\n    current.generation + 1 < e.generation;\n\n  const isAncestor = e =>\n    // the current generation needs to be known to determine an ancestor\n    current.generation !== null &&\n    // the event's generation needs to be known to determine an ancestor\n    e.generation !== null &&\n    // an ancestor can't be the root\n    e.generation > 0 &&\n    // an ancestor is the generation before the direct parent\n    current.generation - 1 > e.generation;\n\n  const ancestors: TraceLite | null = isFullTrace ? [] : null;\n  const children: TraceLite = [];\n  const descendants: TraceLite | null = isFullTrace ? [] : null;\n  const projects = new Set();\n\n  trace.forEach(e => {\n    projects.add(e.project_id);\n    if (isChildren(e)) {\n      children.push(e);\n    } else if (isFullTrace) {\n      if (isAncestor(e)) {\n        ancestors?.push(e);\n      } else if (isDescendant(e)) {\n        descendants?.push(e);\n      }\n    }\n  });\n\n  if (isFullTrace && projects.size > 1) {\n    handleProjectMeta(organization, projects.size);\n  }\n\n  return {\n    root,\n    ancestors: ancestors === null ? null : sortTraceLite(ancestors),\n    parent,\n    current,\n    children: sortTraceLite(children),\n    descendants: descendants === null ? null : sortTraceLite(descendants),\n  };\n}\n\nfunction sortTraceLite(trace: TraceLite): TraceLite {\n  return trace.sort((a, b) => b['transaction.duration'] - a['transaction.duration']);\n}\n\nexport function getTraceRequestPayload({\n  eventView,\n  location,\n}: Pick<DiscoverQueryProps, 'eventView' | 'location'>) {\n  return omit(eventView.getEventsAPIPayload(location), ['field', 'sort', 'per_page']);\n}\n\nexport function makeEventView({\n  start,\n  end,\n  statsPeriod,\n}: {\n  end?: string;\n  start?: string;\n  statsPeriod?: string | null;\n}) {\n  return EventView.fromSavedQuery({\n    id: undefined,\n    version: 2,\n    name: '',\n    // This field doesn't actually do anything,\n    // just here to satisfy a constraint in EventView.\n    fields: ['transaction.duration'],\n    projects: [ALL_ACCESS_PROJECTS],\n    query: '',\n    environment: [],\n    start,\n    end,\n    range: statsPeriod ?? undefined,\n  });\n}\n\nexport function getTraceTimeRangeFromEvent(event: Event): {end: string; start: string} {\n  const start = isTransaction(event)\n    ? event.startTimestamp\n    : moment(event.dateReceived ? event.dateReceived : event.dateCreated).valueOf() /\n      1000;\n  const end = isTransaction(event) ? event.endTimestamp : start;\n  return getTraceDateTimeRange({start, end});\n}\n\nexport function reduceTrace<T>(\n  trace: TraceFullDetailed,\n  visitor: (acc: T, e: TraceFullDetailed) => T,\n  initialValue: T\n): T {\n  let result = initialValue;\n\n  const events = [trace];\n  while (events.length) {\n    const current = events.pop()!;\n    for (const child of current.children) {\n      events.push(child);\n    }\n    result = visitor(result, current);\n  }\n\n  return result;\n}\n\nexport function filterTrace(\n  trace: TraceFullDetailed,\n  predicate: (transaction: TraceFullDetailed) => boolean\n): TraceFullDetailed[] {\n  return reduceTrace<TraceFullDetailed[]>(\n    trace,\n    (transactions, transaction) => {\n      if (predicate(transaction)) {\n        transactions.push(transaction);\n      }\n      return transactions;\n    },\n    []\n  );\n}\n\nexport function isTraceFull(transaction): transaction is TraceFull {\n  return Boolean((transaction as TraceFull).event_id);\n}\n\nexport function isTraceFullDetailed(transaction): transaction is TraceFullDetailed {\n  return Boolean((transaction as TraceFullDetailed).event_id);\n}\n\nfunction handleProjectMeta(organization: OrganizationSummary, projects: number) {\n  trackAnalyticsEvent({\n    eventKey: 'quick_trace.connected_services',\n    eventName: 'Quick Trace: Connected Services',\n    organization_id: parseInt(organization.id, 10),\n    projects,\n  });\n}\n","import {t} from 'sentry/locale';\nimport {measurementType, MobileVital, WebVital} from 'sentry/utils/discover/fields';\nimport {Vital} from 'sentry/utils/performance/vitals/types';\n\nexport const WEB_VITAL_DETAILS: Record<WebVital, Vital> = {\n  [WebVital.FP]: {\n    slug: 'fp',\n    name: t('First Paint'),\n    acronym: 'FP',\n    description: t(\n      'Render time of the first pixel loaded in the viewport (may overlap with FCP).'\n    ),\n    poorThreshold: 3000,\n    type: measurementType(WebVital.FP),\n  },\n  [WebVital.FCP]: {\n    slug: 'fcp',\n    name: t('First Contentful Paint'),\n    acronym: 'FCP',\n    description: t(\n      'Render time of the first image, text or other DOM node in the viewport.'\n    ),\n    poorThreshold: 3000,\n    type: measurementType(WebVital.FCP),\n  },\n  [WebVital.LCP]: {\n    slug: 'lcp',\n    name: t('Largest Contentful Paint'),\n    acronym: 'LCP',\n    description: t(\n      'Render time of the largest image, text or other DOM node in the viewport.'\n    ),\n    poorThreshold: 4000,\n    type: measurementType(WebVital.LCP),\n  },\n  [WebVital.FID]: {\n    slug: 'fid',\n    name: t('First Input Delay'),\n    acronym: 'FID',\n    description: t(\n      'Response time of the browser to a user interaction (clicking, tapping, etc).'\n    ),\n    poorThreshold: 300,\n    type: measurementType(WebVital.FID),\n  },\n  [WebVital.CLS]: {\n    slug: 'cls',\n    name: t('Cumulative Layout Shift'),\n    acronym: 'CLS',\n    description: t(\n      'Sum of layout shift scores that measure the visual stability of the page.'\n    ),\n    poorThreshold: 0.25,\n    type: measurementType(WebVital.CLS),\n  },\n  [WebVital.TTFB]: {\n    slug: 'ttfb',\n    name: t('Time to First Byte'),\n    acronym: 'TTFB',\n    description: t(\n      \"The time that it takes for a user's browser to receive the first byte of page content.\"\n    ),\n    poorThreshold: 600,\n    type: measurementType(WebVital.TTFB),\n  },\n  [WebVital.RequestTime]: {\n    slug: 'ttfb.requesttime',\n    name: t('Request Time'),\n    acronym: 'RT',\n    description: t(\n      'Captures the time spent making the request and receiving the first byte of the response.'\n    ),\n    poorThreshold: 600,\n    type: measurementType(WebVital.RequestTime),\n  },\n};\n\nexport const MOBILE_VITAL_DETAILS: Record<MobileVital, Vital> = {\n  [MobileVital.AppStartCold]: {\n    slug: 'app_start_cold',\n    name: t('App Start Cold'),\n    description: t(\n      'Cold start is a measure of the application start up time from scratch.'\n    ),\n    type: measurementType(MobileVital.AppStartCold),\n  },\n  [MobileVital.AppStartWarm]: {\n    slug: 'app_start_warm',\n    name: t('App Start Warm'),\n    description: t(\n      'Warm start is a measure of the application start up time while still in memory.'\n    ),\n    type: measurementType(MobileVital.AppStartWarm),\n  },\n  [MobileVital.FramesTotal]: {\n    slug: 'frames_total',\n    name: t('Total Frames'),\n    description: t(\n      'Total frames is a count of the number of frames recorded within a transaction.'\n    ),\n    type: measurementType(MobileVital.FramesTotal),\n  },\n  [MobileVital.FramesSlow]: {\n    slug: 'frames_slow',\n    name: t('Slow Frames'),\n    description: t(\n      'Slow frames is a count of the number of slow frames recorded within a transaction.'\n    ),\n    type: measurementType(MobileVital.FramesSlow),\n  },\n  [MobileVital.FramesFrozen]: {\n    slug: 'frames_frozen',\n    name: t('Frozen Frames'),\n    description: t(\n      'Frozen frames is a count of the number of frozen frames recorded within a transaction.'\n    ),\n    type: measurementType(MobileVital.FramesFrozen),\n  },\n  [MobileVital.FramesSlowRate]: {\n    slug: 'frames_slow_rate',\n    name: t('Slow Frames Rate'),\n    description: t(\n      'Slow Frames Rate is the percentage of frames recorded within a transaction that is considered slow.'\n    ),\n    type: measurementType(MobileVital.FramesSlowRate),\n  },\n  [MobileVital.FramesFrozenRate]: {\n    slug: 'frames_frozen_rate',\n    name: t('Frozen Frames Rate'),\n    description: t(\n      'Frozen Frames Rate is the percentage of frames recorded within a transaction that is considered frozen.'\n    ),\n    type: measurementType(MobileVital.FramesFrozenRate),\n  },\n  [MobileVital.StallCount]: {\n    slug: 'stall_count',\n    name: t('Stalls'),\n    description: t(\n      'Stalls is the number of times the application stalled within a transaction.'\n    ),\n    type: measurementType(MobileVital.StallCount),\n  },\n  [MobileVital.StallTotalTime]: {\n    slug: 'stall_total_time',\n    name: t('Total Stall Time'),\n    description: t(\n      'Stall Total Time is the total amount of time the application is stalled within a transaction.'\n    ),\n    type: measurementType(MobileVital.StallTotalTime),\n  },\n  [MobileVital.StallLongestTime]: {\n    slug: 'stall_longest_time',\n    name: t('Longest Stall Time'),\n    description: t(\n      'Stall Longest Time is the longest amount of time the application is stalled within a transaction.'\n    ),\n    type: measurementType(MobileVital.StallLongestTime),\n  },\n  [MobileVital.StallPercentage]: {\n    slug: 'stall_percentage',\n    name: t('Stall Percentage'),\n    description: t(\n      'Stall Percentage is the percentage of the transaction duration the application was stalled.'\n    ),\n    type: measurementType(MobileVital.StallPercentage),\n  },\n};\n\nexport enum Browser {\n  CHROME = 'Chrome',\n  EDGE = 'Edge',\n  OPERA = 'Opera',\n  FIREFOX = 'Firefox',\n  SAFARI = 'Safari',\n  IE = 'IE',\n}\n","import {LocationDescriptor, Query} from 'history';\n\nimport {PAGE_URL_PARAM} from 'sentry/constants/pageFilters';\nimport {OrganizationSummary} from 'sentry/types';\nimport {TraceFullDetailed} from 'sentry/utils/performance/quickTrace/types';\nimport {reduceTrace} from 'sentry/utils/performance/quickTrace/utils';\n\nimport {TraceInfo} from './types';\n\nexport function getTraceDetailsUrl(\n  organization: OrganizationSummary,\n  traceSlug: string,\n  dateSelection,\n  query: Query\n): LocationDescriptor {\n  const {start, end, statsPeriod} = dateSelection;\n  return {\n    pathname: `/organizations/${organization.slug}/performance/trace/${traceSlug}/`,\n    query: {\n      ...query,\n      statsPeriod,\n      [PAGE_URL_PARAM.PAGE_START]: start,\n      [PAGE_URL_PARAM.PAGE_END]: end,\n    },\n  };\n}\n\nfunction traceVisitor() {\n  return (accumulator: TraceInfo, event: TraceFullDetailed) => {\n    for (const error of event.errors ?? []) {\n      accumulator.errors.add(error.event_id);\n    }\n\n    accumulator.transactions.add(event.event_id);\n    accumulator.projects.add(event.project_slug);\n\n    accumulator.startTimestamp = Math.min(\n      accumulator.startTimestamp,\n      event.start_timestamp\n    );\n    accumulator.endTimestamp = Math.max(accumulator.endTimestamp, event.timestamp);\n\n    accumulator.maxGeneration = Math.max(accumulator.maxGeneration, event.generation);\n\n    return accumulator;\n  };\n}\n\nexport function getTraceInfo(traces: TraceFullDetailed[]) {\n  const initial = {\n    projects: new Set<string>(),\n    errors: new Set<string>(),\n    transactions: new Set<string>(),\n    startTimestamp: Number.MAX_SAFE_INTEGER,\n    endTimestamp: 0,\n    maxGeneration: 0,\n  };\n\n  return traces.reduce(\n    (info: TraceInfo, trace: TraceFullDetailed) =>\n      reduceTrace<TraceInfo>(trace, traceVisitor(), info),\n    initial\n  );\n}\n\nexport function isRootTransaction(trace: TraceFullDetailed): boolean {\n  // Root transactions has no parent_span_id\n  return trace.parent_span_id === null;\n}\n"],"names":["MINIMAP_HEIGHT","MINIMAP_SPAN_BAR_HEIGHT","NUM_OF_SPANS_FIT_IN_MINI_MAP","TIME_AXIS_HEIGHT","MINIMAP_CONTAINER_HEIGHT","VIEW_HANDLE_HEIGHT","MERGE_LABELS_THRESHOLD_PERCENT","setSpansOnTransaction","spanCount","transaction","getPerformanceTransaction","spanGroup","find","g","setTag","normalizeTimestamps","spanBounds","startTimestamp","endTimestamp","TimestampStatus","boundsGenerator","bounds","viewStart","viewEnd","traceStartTimestamp","traceEndTimestamp","traceDuration","viewStartTimestamp","viewDuration","type","isSpanVisibleInView","timestampStatus","Stable","Equal","Reversed","parseSpanTimestamps","start","end","width","generateRootSpan","trace","trace_id","traceID","span_id","rootSpanID","parent_span_id","parentSpanID","start_timestamp","timestamp","op","description","data","status","rootSpanStatus","hash","exclusive_time","exclusiveTime","getTraceDateTimeRange","input","moment","subtract","utc","format","add","isGapSpan","span","isOrphanSpan","isOrphan","getSpanID","defaultSpanID","getSpanOperation","getTraceContext","event","contexts","parseTrace","spanEntry","entries","entry","EntryType","spans","traceContext","rootSpanOpName","length","childSpans","potentialParents","Set","map","init","reduced","reduce","acc","inputSpan","parentSpanId","getSpanParentSpanID","hasParent","has","maybeSpanID","isString","assert","spanChildren","push","set","hasEndTimestamp","isNumber","Object","values","forEach","sort","sortSpans","firstSpan","secondSpan","isOrphanTreeDepth","treeDepth","unwrapTreeDepth","depth","isEventFromBrowserJavaScriptSDK","sdkName","sdk","name","includes","toLowerCase","durationlessBrowserOps","hasFailedThreshold","marks","names","keys","WEB_VITAL_DETAILS","filter","vital","slug","some","record","value","poorThreshold","getMeasurements","generateBounds","measurements","Map","startsWith","slice","associatedMeasurement","undefined","mergedMeasurements","measurement","roundedPos","Math","round","otherPos","abs","verticalMark","get","failedThreshold","getMeasurementBounds","warning","left","scrollToSpan","spanId","scrollToHash","location","e","preventDefault","spanTargetHash","browserHistory","getSiblingGroupKey","occurrence","getSpanGroupTimestamps","spanGroupItem","newStartTimestamp","newEndTimestamp","getSpanGroupBounds","SpansInViewMap","constructor","this","spanDepthsInView","treeDepthSum","isRootSpanInView","addSpan","removeSpan","delete","getScrollVal","TOGGLE_BORDER_BOX","TOGGLE_BUTTON_MAX_WIDTH","ConnectorBar","p","orphanBranch","theme","border","TreeConnector","isLast","ROW_HEIGHT","borderRadius","TreeToggle","space","dropShadowLightest","getToggleTheme","TreeToggleContainer","zIndex","traceView","spanTreeToggler","TreeToggleIcon","IconChevron","showAlert","msg","IndicatorStore","duration","PendingChangeQueue","getForItem","itemId","changes","change","changeId","remove","args","apply","storeConfig","listenables","GroupActions","pendingChanges","items","statuses","reset","loadInitialData","itemIds","item","id","trigger","isArray","itemsById","idx","addStatus","isUndefined","clearStatus","hasStatus","indexOfActivity","group_id","group","i","activity","addActivity","index","unshift","splice","numComments","updateActivity","assign","removeActivity","pendingForId","rItem","c","params","getAllItemIds","getAllItems","pendingById","onAssignTo","_changeId","_data","onAssignToError","_error","t","onAssignToSuccess","response","assignedTo","onDelete","_itemIdsOrAll","onDeleteError","_response","onDeleteSuccess","shortId","GroupStore","join","itemIdSet","onDiscard","onDiscardError","onDiscardSuccess","onMerge","onMergeError","onMergeSuccess","mergedIds","mergedIdSet","merge","parent","onUpdate","onUpdateError","failSilently","onUpdateSuccess","indexOf","onPopulateStats","groupStatsMap","stats","onPopulateReleases","releaseData","createStore","makeSafeRefluxStore","isTransaction","isCurrentEvent","currentEvent","event_id","errors","flattenRelevantPaths","traceFull","relevantPath","events","paths","path","current","shift","node","simplifyEvent","child","children","Error","omit","parseQuickTrace","quickTrace","organization","isFullTrace","parent_event_id","root","generation","ancestors","descendants","projects","project_id","isChildren","isAncestor","isDescendant","size","trackAnalyticsEvent","eventKey","eventName","organization_id","parseInt","handleProjectMeta","sortTraceLite","a","b","getTraceRequestPayload","eventView","getEventsAPIPayload","makeEventView","statsPeriod","EventView","version","fields","ALL_ACCESS_PROJECTS","query","environment","range","getTraceTimeRangeFromEvent","dateReceived","dateCreated","valueOf","reduceTrace","visitor","initialValue","result","pop","filterTrace","predicate","transactions","isTraceFull","Boolean","isTraceFullDetailed","WebVital","acronym","measurementType","MOBILE_VITAL_DETAILS","MobileVital","Browser","getTraceDetailsUrl","traceSlug","dateSelection","pathname","PAGE_URL_PARAM","getTraceInfo","traces","initial","Number","MAX_SAFE_INTEGER","maxGeneration","info","accumulator","error","project_slug","min","max","isRootTransaction"],"sourceRoot":""}