{"version":3,"file":"chunks/app_views_profiling_profileGroupProvider_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/profiling/breadcrumb.tsx","webpack:///./app/utils/profiling/callTreeNode.tsx","webpack:///./app/utils/profiling/frame.tsx","webpack:///./app/utils/profiling/guards/profile.tsx","webpack:///./app/utils/profiling/profile/eventedProfile.tsx","webpack:///./app/utils/profiling/profile/chromeTraceProfile.tsx","webpack:///./app/utils/profiling/formatters/stackMarkerToHumanReadable.tsx","webpack:///./app/utils/profiling/jsSelfProfiling.tsx","webpack:///./app/utils/profiling/profile/jsSelfProfile.tsx","webpack:///./app/utils/profiling/profile/sampledProfile.tsx","webpack:///./app/utils/profiling/profile/importProfile.tsx","webpack:///./app/utils/profiling/profile/profile.tsx","webpack:///./app/utils/profiling/profile/utils.tsx","webpack:///./app/utils/profiling/routes.tsx","webpack:///./app/utils/profiling/weightedNode.tsx","webpack:///./app/utils/useLocation.tsx","webpack:///./app/utils/useParams.tsx","webpack:///./app/components/profiling/profileHeader.tsx","webpack:///./app/views/profiling/profileGroupProvider.tsx"],"sourcesContent":["import {useMemo} from 'react';\nimport styled from '@emotion/styled';\nimport {Location} from 'history';\n\nimport Breadcrumbs, {Crumb} from 'sentry/components/breadcrumbs';\nimport {t} from 'sentry/locale';\nimport {Organization, Project} from 'sentry/types';\nimport {\n  generateProfileFlamegraphRouteWithQuery,\n  generateProfileSummaryRouteWithQuery,\n  generateProfilingRouteWithQuery,\n} from 'sentry/utils/profiling/routes';\n\ninterface BreadcrumbProps {\n  location: Location;\n  organization: Organization;\n  trails: Trail[];\n}\n\nfunction Breadcrumb({location, organization, trails}: BreadcrumbProps) {\n  const crumbs = useMemo(\n    () => trails.map(trail => trailToCrumb(trail, {location, organization})),\n    [location, organization, trails]\n  );\n  return <StyledBreadcrumbs crumbs={crumbs} />;\n}\n\nfunction trailToCrumb(\n  trail: Trail,\n  {\n    location,\n    organization,\n  }: {\n    location: Location;\n    organization: Organization;\n  }\n): Crumb {\n  switch (trail.type) {\n    case 'landing': {\n      return {\n        to: generateProfilingRouteWithQuery({\n          location,\n          orgSlug: organization.slug,\n        }),\n        label: t('Profiling'),\n        preservePageFilters: true,\n      };\n    }\n    case 'profile summary': {\n      return {\n        to: generateProfileSummaryRouteWithQuery({\n          location,\n          orgSlug: organization.slug,\n          projectSlug: trail.payload.projectSlug,\n          transaction: trail.payload.transaction,\n        }),\n        label: t('Profile Summary'),\n        preservePageFilters: true,\n      };\n    }\n    case 'flamegraph': {\n      return {\n        to: generateProfileFlamegraphRouteWithQuery({\n          location,\n          orgSlug: organization.slug,\n          projectSlug: trail.payload.projectSlug,\n          profileId: trail.payload.profileId,\n        }),\n        label: trail.payload.transaction,\n        preservePageFilters: true,\n      };\n    }\n    default:\n      throw new Error(`Unknown breadcrumb type: ${JSON.stringify(trail)}`);\n  }\n}\n\ntype ProfilingTrail = {\n  type: 'landing';\n};\n\ntype ProfileSummaryTrail = {\n  payload: {\n    projectSlug: Project['slug'];\n    transaction: string;\n  };\n  type: 'profile summary';\n};\n\ntype FlamegraphTrail = {\n  payload: {\n    profileId: string;\n    projectSlug: string;\n    transaction: string;\n  };\n  type: 'flamegraph';\n};\n\ntype Trail = ProfilingTrail | ProfileSummaryTrail | FlamegraphTrail;\n\nconst StyledBreadcrumbs = styled(Breadcrumbs)`\n  padding: 0;\n`;\n\nexport {Breadcrumb};\n","import {Frame} from './frame';\nimport {WeightedNode} from './weightedNode';\n\nexport class CallTreeNode extends WeightedNode {\n  readonly frame: Frame;\n\n  private locked = false;\n\n  parent: CallTreeNode | null;\n  recursive: CallTreeNode | null;\n  children: CallTreeNode[] = [];\n\n  constructor(frame: Frame, parent: CallTreeNode | null) {\n    super();\n    this.recursive = null;\n    this.parent = parent;\n    this.frame = frame;\n  }\n\n  setParent(parent: CallTreeNode): void {\n    this.parent = parent;\n  }\n\n  setRecursiveThroughNode(node: CallTreeNode): void {\n    this.recursive = node;\n  }\n\n  isRecursive(): boolean {\n    return !!this.recursive;\n  }\n\n  isDirectRecursive(): boolean {\n    if (!this.parent) {\n      return false;\n    }\n    return this.parent.frame === this.frame;\n  }\n\n  isLocked(): boolean {\n    return this.locked;\n  }\n\n  lock(): void {\n    this.locked = true;\n  }\n\n  isRoot(): boolean {\n    return Frame.Root === this.frame;\n  }\n\n  static readonly Root = new CallTreeNode(Frame.Root, null);\n}\n","import {t} from 'sentry/locale';\n\nimport {WeightedNode} from './weightedNode';\n\nexport class Frame extends WeightedNode {\n  readonly key: string | number;\n  readonly name: string;\n  readonly file?: string;\n  readonly line?: number;\n  readonly column?: number;\n  readonly is_application: boolean;\n  readonly image?: string;\n  readonly resource?: string;\n  readonly threadId?: number;\n\n  static Root = new Frame(\n    {\n      key: 'sentry root',\n      name: 'sentry root',\n      is_application: false,\n    },\n    'mobile'\n  );\n\n  constructor(frameInfo: Profiling.FrameInfo, type?: 'mobile' | 'web') {\n    super();\n\n    this.key = frameInfo.key;\n    this.file = frameInfo.file;\n    this.name = frameInfo.name;\n    this.resource = frameInfo.resource;\n    this.line = frameInfo.line;\n    this.column = frameInfo.column;\n    this.is_application =\n      type === 'web'\n        ? frameInfo.line === undefined && frameInfo.column === undefined\n        : !!frameInfo.is_application;\n    this.image = frameInfo.image;\n    this.threadId = frameInfo.threadId;\n\n    if (type === 'web') {\n      // If the frame is a web frame and there is no name associated to it, then it was likely invoked as an iife or anonymous callback as\n      // most modern browser engines properly show anonymous functions when they are assigned to references (e.g. `let foo = function() {};`)\n      if (!frameInfo.name) {\n        this.name = t('anonymous');\n      }\n      // If the frame had no line or column, it was part of the native code, (e.g. calling String.fromCharCode)\n      if (frameInfo.line === undefined && frameInfo.column === undefined) {\n        this.name += ` ${t('[native code]')}`;\n      }\n    }\n  }\n\n  isRoot(): boolean {\n    return Frame.Root === this;\n  }\n}\n","export function isSchema(input: any): input is Profiling.Schema {\n  return (\n    typeof input === 'object' &&\n    'transactionName' in input &&\n    'profiles' in input &&\n    Array.isArray(input.profiles) &&\n    'shared' in input\n  );\n}\nexport function isEventedProfile(profile: any): profile is Profiling.EventedProfile {\n  return 'type' in profile && profile.type === 'evented';\n}\n\nexport function isSampledProfile(profile: any): profile is Profiling.SampledProfile {\n  return 'type' in profile && profile.type === 'sampled';\n}\n\nexport function isJSProfile(profile: any): profile is JSSelfProfiling.Trace {\n  return !('type' in profile) && Array.isArray(profile.resources);\n}\n\nexport function isChromeTraceFormat(input: any): input is ChromeTrace.ProfileType {\n  return isChromeTraceArrayFormat(input) || isChromeTraceObjectFormat(input);\n}\n\nexport function isChromeTraceObjectFormat(input: any): input is ChromeTrace.ObjectFormat {\n  return typeof input === 'object' && 'traceEvents' in input;\n}\n\nexport function isChromeTraceArrayFormat(input: any): input is ChromeTrace.ArrayFormat {\n  // @TODO we need to check if the profile actually includes the v8 profile nodes.\n  return Array.isArray(input);\n}\n","import {lastOfArray} from 'sentry/utils';\nimport {CallTreeNode} from 'sentry/utils/profiling/callTreeNode';\nimport {Frame} from 'sentry/utils/profiling/frame';\n\nimport {Profile} from './profile';\nimport {createFrameIndex} from './utils';\n\nexport class EventedProfile extends Profile {\n  appendOrderStack: CallTreeNode[] = [this.appendOrderTree];\n  stack: Frame[] = [];\n\n  lastValue = 0;\n\n  static FromProfile(\n    eventedProfile: Profiling.EventedProfile,\n    frameIndex: ReturnType<typeof createFrameIndex>\n  ): EventedProfile {\n    const profile = new EventedProfile(\n      eventedProfile.endValue - eventedProfile.startValue,\n      eventedProfile.startValue,\n      eventedProfile.endValue,\n      eventedProfile.name,\n      eventedProfile.unit,\n      eventedProfile.threadID\n    );\n\n    // If frames are offset, we need to set lastValue to profile start, so that delta between\n    // samples is correctly offset by the start value.\n    profile.lastValue = Math.max(0, eventedProfile.startValue);\n\n    for (const event of eventedProfile.events) {\n      const frame = frameIndex[event.frame];\n\n      if (!frame) {\n        throw new Error(`Cannot retrieve event: ${event.frame} from frame index`);\n      }\n\n      switch (event.type) {\n        // Open a new frame\n        case 'O': {\n          profile.enterFrame(frame, event.at);\n          break;\n        }\n        // Close a frame\n        case 'C': {\n          profile.leaveFrame(frame, event.at);\n          break;\n        }\n        default: {\n          throw new TypeError(`Unknown event type ${event.type}`);\n        }\n      }\n    }\n\n    return profile.build();\n  }\n\n  addWeightToFrames(weight: number): void {\n    const weightDelta = weight - this.lastValue;\n\n    for (const frame of this.stack) {\n      frame.addToTotalWeight(weightDelta);\n    }\n\n    const top = lastOfArray(this.stack);\n    if (top) {\n      top.addToSelfWeight(weight);\n    }\n  }\n\n  addWeightsToNodes(value: number) {\n    const delta = value - this.lastValue;\n\n    for (const node of this.appendOrderStack) {\n      node.addToTotalWeight(delta);\n    }\n    const stackTop = lastOfArray(this.appendOrderStack);\n\n    if (stackTop) {\n      stackTop.addToSelfWeight(delta);\n    }\n  }\n\n  enterFrame(frame: Frame, at: number): void {\n    this.addWeightToFrames(at);\n    this.addWeightsToNodes(at);\n\n    const lastTop = lastOfArray(this.appendOrderStack);\n\n    if (lastTop) {\n      const sampleDelta = at - this.lastValue;\n\n      if (sampleDelta < 0) {\n        throw new Error(\n          'Sample delta cannot be negative, samples may be corrupt or out of order'\n        );\n      }\n\n      // If the sample timestamp is not the same as the same as of previous frame,\n      // we can deduce that this is a new sample and need to push it on the stack\n      if (sampleDelta > 0) {\n        this.samples.push(lastTop);\n        this.weights.push(sampleDelta);\n      }\n\n      const last = lastOfArray(lastTop.children);\n      let node: CallTreeNode;\n\n      if (last && !last.isLocked() && last.frame === frame) {\n        node = last;\n      } else {\n        node = new CallTreeNode(frame, lastTop);\n        lastTop.children.push(node);\n      }\n\n      // TODO: This is On^2, because we iterate over all frames in the stack to check if our\n      // frame is a recursive frame. We could do this in O(1) by keeping a map of frames in the stack with their respective indexes\n      // We check the stack in a top-down order to find the first recursive frame.\n      let start = this.appendOrderStack.length - 1;\n      while (start >= 0) {\n        if (this.appendOrderStack[start].frame === node.frame) {\n          // The recursion edge is bidirectional\n          this.appendOrderStack[start].setRecursiveThroughNode(node);\n          node.setRecursiveThroughNode(this.appendOrderStack[start]);\n          break;\n        }\n        start--;\n      }\n\n      this.appendOrderStack.push(node);\n    }\n\n    this.stack.push(frame);\n    this.lastValue = at;\n  }\n\n  leaveFrame(_event: Frame, at: number): void {\n    this.addWeightToFrames(at);\n    this.addWeightsToNodes(at);\n\n    const leavingStackTop = this.appendOrderStack.pop();\n\n    if (leavingStackTop === undefined) {\n      throw new Error('Unbalanced stack');\n    }\n\n    // Lock the stack node, so we make sure we dont mutate it in the future.\n    // The samples should be ordered by timestamp when processed so we should never\n    // iterate over them again in the future.\n    leavingStackTop.lock();\n    const sampleDelta = at - this.lastValue;\n\n    if (sampleDelta > 0) {\n      this.samples.push(leavingStackTop);\n      this.weights.push(sampleDelta);\n      // Keep track of the minFrameDuration\n      this.minFrameDuration = Math.min(sampleDelta, this.minFrameDuration);\n    }\n\n    this.stack.pop();\n    this.lastValue = at;\n  }\n\n  build(): EventedProfile {\n    if (this.appendOrderStack.length > 1) {\n      throw new Error('Unbalanced append order stack');\n    }\n\n    this.duration = Math.max(\n      this.duration,\n      this.weights.reduce((a, b) => a + b, 0)\n    );\n\n    // We had no frames with duration > 0, so set min duration to timeline duration\n    // which effectively disables any zooming on the flamegraphs\n    if (\n      this.minFrameDuration === Number.POSITIVE_INFINITY ||\n      this.minFrameDuration === 0\n    ) {\n      this.minFrameDuration = this.duration;\n    }\n\n    return this;\n  }\n}\n","/**\n * The import code is very similar to speedscope's import code. The queue approach works well and allows us\n * to easily split the X events and handle them. There are some small differences when it comes to building\n * profiles where we opted to throw instead of closing a frame that was never opened.\n *\n * Overall, it seems that mostly typescript compiler uses this output, so we could possibly do a bit more\n * in order to detect if this is a tsc trace and mark the different compiler phases and give users the preference\n * to color encode by the program/bind/check/emit phases.\n */\nimport {Frame} from 'sentry/utils/profiling/frame';\nimport {Profile} from 'sentry/utils/profiling/profile/profile';\nimport {wrapWithSpan} from 'sentry/utils/profiling/profile/utils';\n\nimport {EventedProfile} from './eventedProfile';\nimport {ImportOptions, ProfileGroup} from './importProfile';\n\nexport class ChromeTraceProfile extends EventedProfile {}\n\ntype ProcessId = number;\ntype ThreadId = number;\n\nexport function splitEventsByProcessAndTraceId(\n  trace: ChromeTrace.ArrayFormat\n): Map<ProcessId, Map<ThreadId, ChromeTrace.Event[]>> {\n  const collections: Map<ProcessId, Map<ThreadId, ChromeTrace.Event[]>> = new Map();\n\n  for (let i = 0; i < trace.length; i++) {\n    const event = trace[i];\n\n    if (typeof event.pid !== 'number') {\n      continue;\n    }\n    if (typeof event.tid !== 'number') {\n      continue;\n    }\n\n    let processes = collections.get(event.pid);\n    if (!processes) {\n      processes = new Map();\n      collections.set(event.pid, processes);\n    }\n\n    let threads = processes.get(event.tid);\n    if (!threads) {\n      threads = [];\n      processes.set(event.tid, threads);\n    }\n\n    threads.push(event);\n  }\n\n  return collections;\n}\n\nfunction reverseChronologicalSort(a: ChromeTrace.Event, b: ChromeTrace.Event): number {\n  return b.ts - a.ts;\n}\n\nfunction getNextQueue(\n  beginQueue: ChromeTrace.Event[],\n  endQueue: ChromeTrace.Event[]\n): 'B' | 'E' {\n  if (!beginQueue.length && !endQueue.length) {\n    throw new Error('Profile contains no events');\n  }\n\n  const nextBegin = beginQueue[beginQueue.length - 1];\n  const nextEnd = endQueue[endQueue.length - 1];\n\n  if (!nextEnd) {\n    return 'B';\n  }\n  if (!nextBegin) {\n    return 'E';\n  }\n  if (nextBegin.ts < nextEnd.ts) {\n    return 'B';\n  }\n  if (nextEnd.ts < nextBegin.ts) {\n    return 'E';\n  }\n  return 'B';\n}\n\nfunction buildProfile(\n  processId: number,\n  threadId: number,\n  events: ChromeTrace.Event[]\n): ChromeTraceProfile {\n  let processName: string = `pid (${processId})`;\n  let threadName: string = `tid (${threadId})`;\n\n  // We dont care about other events besides begin, end, instant events and metadata events\n  const timelineEvents = events.filter(\n    e => e.ph === 'B' || e.ph === 'E' || e.ph === 'X' || e.ph === 'M'\n  );\n\n  const beginQueue: Array<ChromeTrace.Event> = [];\n  const endQueue: Array<ChromeTrace.Event> = [];\n\n  for (let i = 0; i < timelineEvents.length; i++) {\n    const event = timelineEvents[i];\n\n    // M events are not pushed to the queue, we just store their information\n    if (event.ph === 'M') {\n      if (event.name === 'thread_name' && typeof event.args.name === 'string') {\n        threadName = `${event.args.name} (${threadId})`;\n        continue;\n      }\n\n      if (event.name === 'process_name' && typeof event.args.name === 'string') {\n        processName = `${event.args.name} (${processId})`;\n        continue;\n      }\n    }\n\n    // B, E and X events are pushed to the timeline. We transform all X events into\n    // B and E event, so that they can be pushed onto the queue and handled\n    if (event.ph === 'B') {\n      beginQueue.push(event);\n      continue;\n    }\n\n    if (event.ph === 'E') {\n      endQueue.push(event);\n      continue;\n    }\n\n    if (event.ph === 'X') {\n      if (typeof event.dur === 'number' || typeof event.tdur === 'number') {\n        beginQueue.push({...event, ph: 'B'});\n        endQueue.push({...event, ph: 'E', ts: event.ts + (event.dur ?? event.tdur ?? 0)});\n        continue;\n      }\n    }\n  }\n\n  beginQueue.sort(reverseChronologicalSort);\n  endQueue.sort(reverseChronologicalSort);\n\n  if (!beginQueue.length) {\n    throw new Error('Profile does not contain any frame events');\n  }\n\n  const firstTimestamp = beginQueue[beginQueue.length - 1].ts;\n  const lastTimestamp = endQueue[0]?.ts ?? beginQueue[0].ts;\n\n  if (typeof firstTimestamp !== 'number') {\n    throw new Error('First begin event contains no timestamp');\n  }\n\n  if (typeof lastTimestamp !== 'number') {\n    throw new Error('Last end event contains no timestamp');\n  }\n\n  const profile = new ChromeTraceProfile(\n    lastTimestamp - firstTimestamp,\n    firstTimestamp,\n    lastTimestamp,\n    `${processName}: ${threadName}`,\n    'microseconds', // the trace event format provides timestamps in microseconds\n    threadId\n  );\n\n  const stack: ChromeTrace.Event[] = [];\n  const frameCache = new Map<string, Frame>();\n\n  while (beginQueue.length > 0 || endQueue.length > 0) {\n    const next = getNextQueue(beginQueue, endQueue);\n\n    if (next === 'B') {\n      const item = beginQueue.pop();\n      if (!item) {\n        throw new Error('Nothing to take from begin queue');\n      }\n\n      const frameInfo = createFrameInfoFromEvent(item);\n\n      if (!frameCache.has(frameInfo.key)) {\n        frameCache.set(frameInfo.key, new Frame(frameInfo));\n      }\n\n      const frame = frameCache.get(frameInfo.key)!;\n      profile.enterFrame(frame, item.ts - firstTimestamp);\n      stack.push(item);\n      continue;\n    }\n\n    if (next === 'E') {\n      const item = endQueue.pop()!;\n      let frameInfo = createFrameInfoFromEvent(item);\n\n      if (stack[stack.length - 1] === undefined) {\n        throw new Error(\n          `Unable to close frame from an empty stack, attempting to close ${JSON.stringify(\n            item\n          )}`\n        );\n      }\n      const topFrameInfo = createFrameInfoFromEvent(stack[stack.length - 1]);\n\n      // We check frames with the same ts and look for a match. We do this because\n      // chronological sort will not break ties on frames that end at the same time,\n      // but may not be in the same order as they were opened.\n      for (let i = endQueue.length - 2; i > 0; i--) {\n        if (endQueue[i].ts > endQueue[endQueue.length - 1].ts) {\n          break;\n        }\n\n        const nextEndInfo = createFrameInfoFromEvent(endQueue[i]);\n        if (topFrameInfo.key === nextEndInfo.key) {\n          const tmp = endQueue[endQueue.length - 1];\n          endQueue[endQueue.length - 1] = endQueue[i];\n          endQueue[i] = tmp;\n\n          frameInfo = nextEndInfo;\n          break;\n        }\n      }\n\n      if (!frameCache.has(frameInfo.key)) {\n        throw new Error(\n          `Cannot leave frame that was never entered, leaving ${frameInfo.key}`\n        );\n      }\n\n      const frame = frameCache.get(frameInfo.key)!;\n      profile.leaveFrame(frame, item.ts - firstTimestamp);\n      stack.pop();\n      continue;\n    }\n  }\n\n  // Close the leftover frames in stack\n  while (stack.length) {\n    const item = stack.pop()!;\n    const frameInfo = createFrameInfoFromEvent(item);\n\n    const frame = frameCache.get(frameInfo.key);\n    if (!frame) {\n      throw new Error(\n        `Cannot leave frame that was never entered, leaving ${frameInfo.key}`\n      );\n    }\n    profile.leaveFrame(frame, frame.totalWeight);\n  }\n\n  return profile.build();\n}\n\nfunction createFrameInfoFromEvent(event: ChromeTrace.Event) {\n  const key = JSON.stringify(event.args);\n\n  return {\n    key,\n    name: `${event?.name || 'Unknown'} ${key}`.trim(),\n  };\n}\n\nexport function parseChromeTraceArrayFormat(\n  input: ChromeTrace.ArrayFormat,\n  traceID: string,\n  options?: ImportOptions\n): ProfileGroup {\n  const profiles: Profile[] = [];\n  const eventsByProcessAndThreadID = splitEventsByProcessAndTraceId(input);\n\n  for (const [processId, threads] of eventsByProcessAndThreadID) {\n    for (const [threadId, events] of threads) {\n      wrapWithSpan(\n        options?.transaction,\n        () => profiles.push(buildProfile(processId, threadId, events ?? [])),\n        {\n          op: 'profile.import',\n          description: 'chrometrace',\n        }\n      );\n    }\n  }\n\n  return {\n    name: 'chrometrace',\n    traceID,\n    activeProfileIndex: 0,\n    profiles,\n  };\n}\n","import {t} from 'sentry/locale';\n\nexport function stackMarkerToHumanReadable(marker: JSSelfProfiling.Marker): string {\n  switch (marker) {\n    case 'gc':\n      return t('Garbage Collection');\n    case 'style':\n      return t('Style');\n    case 'layout':\n      return t('Layout');\n    case 'paint':\n      return t('Paint');\n    case 'script':\n      return t('Script');\n    case 'other':\n      return t('Other');\n    default:\n      // since spec is still in dev, just gracefully return whatever we received.\n      return marker;\n  }\n}\n","import {stackMarkerToHumanReadable} from './formatters/stackMarkerToHumanReadable';\nimport {Frame} from './frame';\n\nfunction createMarkerFrame(marker: JSSelfProfiling.Marker): JSSelfProfiling.Frame {\n  return {\n    name: stackMarkerToHumanReadable(marker),\n    resourceId: undefined,\n    line: undefined,\n    column: undefined,\n  };\n}\n/**\n * Utility fn to resolve stack frames starting from the top most frame.\n * Each frame points to it's parent, with the initial stackId pointer pointing to the top of the frame.\n * We walk down the stack until no more frames are found, appending the parent frame to the list.\n * As a result we end up with a list of frames starting from the root most frame.\n *\n * There is a caching opportunity here, as stackId's point to the same parts of the stack, resolving it once is sufficient\n * and all subsequent calls could be cached. Some instrumentation and testing would be required, leaving as is for now.\n */\nexport function resolveJSSelfProfilingStack(\n  trace: JSSelfProfiling.Trace,\n  stackId: JSSelfProfiling.Sample['stackId'],\n  frameIndex: Record<number, Frame>,\n  marker?: JSSelfProfiling.Marker\n): Frame[] {\n  // If there is no stack associated with a sample, it means the thread was idle\n\n  const callStack: Frame[] = [];\n\n  // There can only be one marker per callStack, so prepend it to the start of the stack\n  if (marker && marker !== 'script') {\n    callStack.unshift(new Frame({...createMarkerFrame(marker), key: marker}));\n  }\n\n  if (stackId === undefined) {\n    return callStack;\n  }\n\n  let stack: JSSelfProfiling.Stack | undefined = trace.stacks[stackId];\n\n  // If the stackId cannot be resolved from the stacks dict, it means the format is corrupt or partial (possibly due to termination reasons).\n  // This should never happen, but in the offchance that it somehow does, it should be handled.\n  if (!stack) {\n    throw new Error(`Missing stackId ${stackId} in trace, cannot resolve stack`);\n  }\n\n  while (stack !== undefined) {\n    // If the frameId pointer cannot be resolved, it means the format is corrupt or partial (possibly due to termination reasons).\n    // This should never happen, but in the offchance that it somehow does, it should be handled.\n    if (!trace.frames[stack.frameId]) {\n      return callStack;\n    }\n\n    callStack.unshift(frameIndex[stack.frameId]);\n\n    if (stack.parentId !== undefined) {\n      stack = trace.stacks[stack.parentId];\n    } else {\n      stack = undefined;\n    }\n  }\n\n  return callStack;\n}\n","import {lastOfArray} from 'sentry/utils';\nimport {CallTreeNode} from 'sentry/utils/profiling/callTreeNode';\nimport {Frame} from 'sentry/utils/profiling/frame';\n\nimport {stackMarkerToHumanReadable} from './../formatters/stackMarkerToHumanReadable';\nimport {resolveJSSelfProfilingStack} from './../jsSelfProfiling';\nimport {Profile} from './profile';\nimport {createFrameIndex} from './utils';\n\nexport class JSSelfProfile extends Profile {\n  static FromProfile(\n    profile: JSSelfProfiling.Trace,\n    frameIndex: ReturnType<typeof createFrameIndex>\n  ): JSSelfProfile {\n    // In the case of JSSelfProfiling, we need to index the abstract marker frames\n    // as they will otherwise not be present in the ProfilerStack.\n    const markers: JSSelfProfiling.Marker[] = [\n      'gc',\n      'layout',\n      'other',\n      'paint',\n      'script',\n      'style',\n    ];\n\n    for (const marker of markers) {\n      frameIndex[marker] = new Frame(\n        {\n          key: marker,\n          name: stackMarkerToHumanReadable(marker),\n          line: undefined,\n          column: undefined,\n          is_application: false,\n        },\n        'web'\n      );\n    }\n\n    const startedAt = profile.samples[0].timestamp;\n    const endedAt = lastOfArray(profile.samples).timestamp;\n\n    const jsSelfProfile = new JSSelfProfile(\n      endedAt - startedAt,\n      startedAt,\n      endedAt,\n      'JSSelfProfiling',\n      'milliseconds',\n      0\n    );\n\n    // Because JS self profiling takes an initial sample when we call new Profiler(),\n    // it means that the first sample weight will always be zero. We want to append the sample with 0 weight,\n    //  because the 2nd sample may part of the first sample's stack. This way we keep the most information we can of the stack trace\n    jsSelfProfile.appendSample(\n      resolveJSSelfProfilingStack(\n        profile,\n        profile.samples[0].stackId,\n        frameIndex,\n        profile.samples[0].marker\n      ),\n      0\n    );\n\n    // We start at stack 1, because we've already appended stack 0 above. The weight of each sample is the\n    // difference between the current sample and the previous one.\n    for (let i = 1; i < profile.samples.length; i++) {\n      jsSelfProfile.appendSample(\n        resolveJSSelfProfilingStack(\n          profile,\n          profile.samples[i].stackId,\n          frameIndex,\n          profile.samples[i].marker\n        ),\n        profile.samples[i].timestamp - profile.samples[i - 1].timestamp\n      );\n    }\n\n    return jsSelfProfile.build();\n  }\n\n  appendSample(stack: Frame[], weight: number): void {\n    let node = this.appendOrderTree;\n    const framesInStack: CallTreeNode[] = [];\n\n    for (const frame of stack) {\n      const last = lastOfArray(node.children);\n\n      if (last && !last.isLocked() && last.frame === frame) {\n        node = last;\n      } else {\n        const parent = node;\n        node = new CallTreeNode(frame, node);\n        parent.children.push(node);\n      }\n\n      node.addToTotalWeight(weight);\n\n      // TODO: This is On^2, because we iterate over all frames in the stack to check if our\n      // frame is a recursive frame. We could do this in O(1) by keeping a map of frames in the stack\n      // We check the stack in a top-down order to find the first recursive frame.\n      let stackHeight = framesInStack.length - 1;\n\n      while (stackHeight >= 0) {\n        if (framesInStack[stackHeight].frame === node.frame) {\n          // The recursion edge is bidirectional\n          framesInStack[stackHeight].setRecursiveThroughNode(node);\n          node.setRecursiveThroughNode(framesInStack[stackHeight]);\n          break;\n        }\n        stackHeight--;\n      }\n\n      framesInStack.push(node);\n    }\n\n    node.addToSelfWeight(weight);\n\n    if (weight > 0) {\n      this.minFrameDuration = Math.min(weight, this.minFrameDuration);\n    }\n\n    // Lock the stack node, so we make sure we dont mutate it in the future.\n    // The samples should be ordered by timestamp when processed so we should never\n    // iterate over them again in the future.\n    for (const child of node.children) {\n      child.lock();\n    }\n\n    node.frame.addToSelfWeight(weight);\n\n    for (const stackNode of framesInStack) {\n      stackNode.frame.addToTotalWeight(weight);\n    }\n\n    // If node is the same as the previous sample, add the weight to the previous sample\n    if (node === lastOfArray(this.samples)) {\n      this.weights[this.weights.length - 1] += weight;\n    } else {\n      this.samples.push(node);\n      this.weights.push(weight);\n    }\n  }\n\n  build(): JSSelfProfile {\n    this.duration = Math.max(\n      this.duration,\n      this.weights.reduce((a, b) => a + b, 0)\n    );\n\n    // We had no frames with duration > 0, so set min duration to timeline duration\n    // which effectively disables any zooming on the flamegraphs\n    if (\n      this.minFrameDuration === Number.POSITIVE_INFINITY ||\n      this.minFrameDuration === 0\n    ) {\n      this.minFrameDuration = this.duration;\n    }\n\n    return this;\n  }\n}\n","import {lastOfArray} from 'sentry/utils';\nimport {CallTreeNode} from 'sentry/utils/profiling/callTreeNode';\n\nimport {Frame} from './../frame';\nimport {Profile} from './profile';\nimport {createFrameIndex} from './utils';\n\nexport class SampledProfile extends Profile {\n  static FromProfile(\n    sampledProfile: Profiling.SampledProfile,\n    frameIndex: ReturnType<typeof createFrameIndex>\n  ): Profile {\n    const profile = new SampledProfile(\n      sampledProfile.endValue - sampledProfile.startValue,\n      sampledProfile.startValue,\n      sampledProfile.endValue,\n      sampledProfile.name,\n      sampledProfile.unit,\n      sampledProfile.threadID\n    );\n\n    if (sampledProfile.samples.length !== sampledProfile.weights.length) {\n      throw new Error(\n        `Expected samples.length (${sampledProfile.samples.length}) to equal weights.length (${sampledProfile.weights.length})`\n      );\n    }\n\n    for (let i = 0; i < sampledProfile.samples.length; i++) {\n      const stack = sampledProfile.samples[i];\n      const weight = sampledProfile.weights[i];\n\n      profile.appendSampleWithWeight(\n        stack.map(n => {\n          if (!frameIndex[n]) {\n            throw new Error(`Could not resolve frame ${n} in frame index`);\n          }\n\n          return frameIndex[n];\n        }),\n        weight\n      );\n    }\n\n    return profile.build();\n  }\n\n  appendSampleWithWeight(stack: Frame[], weight: number): void {\n    // Ignore samples with 0 weight\n    if (weight === 0) {\n      return;\n    }\n\n    let node = this.appendOrderTree;\n    const framesInStack: CallTreeNode[] = [];\n\n    for (const frame of stack) {\n      const last = lastOfArray(node.children);\n      // Find common frame between two stacks\n      if (last && !last.isLocked() && last.frame === frame) {\n        node = last;\n      } else {\n        const parent = node;\n        node = new CallTreeNode(frame, node);\n        parent.children.push(node);\n      }\n\n      node.addToTotalWeight(weight);\n\n      // TODO: This is On^2, because we iterate over all frames in the stack to check if our\n      // frame is a recursive frame. We could do this in O(1) by keeping a map of frames in the stack\n      // We check the stack in a top-down order to find the first recursive frame.\n      let start = framesInStack.length - 1;\n      while (start >= 0) {\n        if (framesInStack[start].frame === node.frame) {\n          // The recursion edge is bidirectional\n          framesInStack[start].setRecursiveThroughNode(node);\n          node.setRecursiveThroughNode(framesInStack[start]);\n          break;\n        }\n        start--;\n      }\n\n      framesInStack.push(node);\n    }\n\n    node.addToSelfWeight(weight);\n    this.minFrameDuration = Math.min(weight, this.minFrameDuration);\n\n    // Lock the stack node, so we make sure we dont mutate it in the future.\n    // The samples should be ordered by timestamp when processed so we should never\n    // iterate over them again in the future.\n    for (const child of node.children) {\n      child.lock();\n    }\n\n    node.frame.addToSelfWeight(weight);\n\n    for (const stackNode of framesInStack) {\n      stackNode.frame.addToTotalWeight(weight);\n    }\n\n    // If node is the same as the previous sample, add the weight to the previous sample\n    if (node === lastOfArray(this.samples)) {\n      this.weights[this.weights.length - 1] += weight;\n    } else {\n      this.samples.push(node);\n      this.weights.push(weight);\n    }\n  }\n\n  build(): Profile {\n    this.duration = Math.max(\n      this.duration,\n      this.weights.reduce((a, b) => a + b, 0)\n    );\n\n    // We had no frames with duration > 0, so set min duration to timeline duration\n    // which effectively disables any zooming on the flamegraphs\n    if (\n      this.minFrameDuration === Number.POSITIVE_INFINITY ||\n      this.minFrameDuration === 0\n    ) {\n      this.minFrameDuration = this.duration;\n    }\n\n    return this;\n  }\n}\n","import * as Sentry from '@sentry/react';\nimport {Transaction} from '@sentry/types';\n\nimport {\n  isChromeTraceArrayFormat,\n  isChromeTraceFormat,\n  isChromeTraceObjectFormat,\n  isEventedProfile,\n  isJSProfile,\n  isSampledProfile,\n  isSchema,\n} from '../guards/profile';\n\nimport {parseChromeTraceArrayFormat} from './chromeTraceProfile';\nimport {EventedProfile} from './eventedProfile';\nimport {JSSelfProfile} from './jsSelfProfile';\nimport {Profile} from './profile';\nimport {SampledProfile} from './sampledProfile';\nimport {createFrameIndex, wrapWithSpan} from './utils';\n\nexport interface ImportOptions {\n  transaction: Transaction | undefined;\n}\n\nexport interface ProfileGroup {\n  activeProfileIndex: number;\n  name: string;\n  profiles: Profile[];\n  traceID: string;\n}\n\nexport function importProfile(\n  input: Profiling.Schema | JSSelfProfiling.Trace | ChromeTrace.ProfileType,\n  traceID: string\n): ProfileGroup {\n  const transaction = Sentry.startTransaction({\n    op: 'import',\n    name: 'profiles.import',\n  });\n\n  try {\n    if (isJSProfile(input)) {\n      // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n      if (transaction) {\n        transaction.setTag('profile.type', 'js-self-profile');\n      }\n      return importJSSelfProfile(input, traceID, {transaction});\n    }\n\n    if (isChromeTraceFormat(input)) {\n      // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n      if (transaction) {\n        transaction.setTag('profile.type', 'chrometrace');\n      }\n      return importChromeTrace(input, traceID, {transaction});\n    }\n\n    if (isSchema(input)) {\n      // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n      if (transaction) {\n        transaction.setTag('profile.type', 'schema');\n      }\n      return importSchema(input, traceID, {transaction});\n    }\n\n    throw new Error('Unsupported trace format');\n  } catch (error) {\n    if (transaction) {\n      transaction.setStatus('internal_error');\n    }\n    throw error;\n  } finally {\n    if (transaction) {\n      transaction.finish();\n    }\n  }\n}\n\nfunction importJSSelfProfile(\n  input: JSSelfProfiling.Trace,\n  traceID: string,\n  options: ImportOptions\n): ProfileGroup {\n  const frameIndex = createFrameIndex(input.frames);\n\n  return {\n    traceID,\n    name: traceID,\n    activeProfileIndex: 0,\n    profiles: [importSingleProfile(input, frameIndex, options)],\n  };\n}\n\nfunction importChromeTrace(\n  input: ChromeTrace.ProfileType,\n  traceID: string,\n  options: ImportOptions\n): ProfileGroup {\n  if (isChromeTraceObjectFormat(input)) {\n    throw new Error('Chrometrace object format is not yet supported');\n  }\n\n  if (isChromeTraceArrayFormat(input)) {\n    return parseChromeTraceArrayFormat(input, traceID, options);\n  }\n\n  throw new Error('Failed to parse trace input format');\n}\n\nfunction importSchema(\n  input: Profiling.Schema,\n  traceID: string,\n  options: ImportOptions\n): ProfileGroup {\n  const frameIndex = createFrameIndex(input.shared.frames);\n\n  return {\n    traceID,\n    name: input.transactionName,\n    activeProfileIndex: input.activeProfileIndex ?? 0,\n    profiles: input.profiles.map(profile =>\n      importSingleProfile(profile, frameIndex, options)\n    ),\n  };\n}\n\nfunction importSingleProfile(\n  profile: Profiling.ProfileTypes,\n  frameIndex: ReturnType<typeof createFrameIndex>,\n  {transaction}: ImportOptions\n): Profile {\n  if (isEventedProfile(profile)) {\n    // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n    if (!transaction) {\n      return EventedProfile.FromProfile(profile, frameIndex);\n    }\n\n    return wrapWithSpan(\n      transaction,\n      () => EventedProfile.FromProfile(profile, frameIndex),\n      {\n        op: 'profile.import',\n        description: 'evented',\n      }\n    );\n  }\n  if (isSampledProfile(profile)) {\n    // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n    if (!transaction) {\n      return SampledProfile.FromProfile(profile, frameIndex);\n    }\n\n    return wrapWithSpan(\n      transaction,\n      () => SampledProfile.FromProfile(profile, frameIndex),\n      {\n        op: 'profile.import',\n        description: 'sampled',\n      }\n    );\n  }\n  if (isJSProfile(profile)) {\n    // In some cases, the SDK may return transaction as undefined and we dont want to throw there.\n    if (!transaction) {\n      return JSSelfProfile.FromProfile(profile, createFrameIndex(profile.frames));\n    }\n\n    return wrapWithSpan(\n      transaction,\n      () => JSSelfProfile.FromProfile(profile, createFrameIndex(profile.frames)),\n      {\n        op: 'profile.import',\n        description: 'js-self-profile',\n      }\n    );\n  }\n  throw new Error('Unrecognized trace format');\n}\n\nconst tryParseInputString: JSONParser = input => {\n  try {\n    return [JSON.parse(input), null];\n  } catch (e) {\n    return [null, e];\n  }\n};\n\ntype JSONParser = (input: string) => [any, null] | [null, Error];\n\nconst TRACE_JSON_PARSERS: ((string) => ReturnType<JSONParser>)[] = [\n  (input: string) => tryParseInputString(input),\n  (input: string) => tryParseInputString(input + ']'),\n];\n\nfunction readFileAsString(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.addEventListener('load', (e: ProgressEvent<FileReader>) => {\n      if (typeof e.target?.result === 'string') {\n        resolve(e.target.result);\n        return;\n      }\n\n      reject('Failed to read string contents of input file');\n    });\n\n    reader.addEventListener('error', () => {\n      reject('Failed to read string contents of input file');\n    });\n\n    reader.readAsText(file);\n  });\n}\n\nexport async function importDroppedProfile(\n  file: File,\n  parsers: JSONParser[] = TRACE_JSON_PARSERS\n): Promise<ProfileGroup> {\n  const fileContents = await readFileAsString(file);\n\n  for (const parser of parsers) {\n    const [json] = parser(fileContents);\n\n    if (json) {\n      if (typeof json !== 'object' || json === null) {\n        throw new TypeError('Input JSON is not an object');\n      }\n\n      return importProfile(json, file.name);\n    }\n  }\n\n  throw new Error('Failed to parse input JSON');\n}\n","import {lastOfArray} from 'sentry/utils';\n\nimport {CallTreeNode} from '../callTreeNode';\nimport {Frame} from '../frame';\n\n// This is ported from speedscope with a lot of modifications and simplifications\n// head at commit e37f6fa7c38c110205e22081560b99cb89ce885e\nexport class Profile {\n  // Duration of the profile\n  duration: number;\n  // Started at ts of the profile - varies between implementations of the profiler.\n  // For JS self profiles, this is the time origin (https://www.w3.org/TR/hr-time-2/#dfn-time-origin), for others it's epoch time\n  startedAt: number;\n  // Ended at ts of the profile - varies between implementations of the profiler.\n  // For JS self profiles, this is the time origin (https://www.w3.org/TR/hr-time-2/#dfn-time-origin), for others it's epoch time\n  endedAt: number;\n  threadId: number;\n\n  // Unit in which the timings are reported in\n  unit = 'microseconds';\n  // Name of the profile\n  name = 'Unknown';\n\n  appendOrderTree: CallTreeNode = new CallTreeNode(Frame.Root, null);\n  framesInStack: Set<Profiling.Event['frame']> = new Set();\n\n  // Min duration of the profile\n  minFrameDuration = Number.POSITIVE_INFINITY;\n\n  samples: CallTreeNode[] = [];\n  weights: number[] = [];\n\n  constructor(\n    duration: number,\n    startedAt: number,\n    endedAt: number,\n    name: string,\n    unit: string,\n    threadId: number\n  ) {\n    this.threadId = threadId;\n    this.duration = duration;\n    this.startedAt = startedAt;\n    this.endedAt = endedAt;\n    this.name = name;\n    this.unit = unit;\n  }\n\n  static Empty() {\n    return new Profile(1000, 0, 1000, '', 'milliseconds', 0).build();\n  }\n\n  forEach(\n    openFrame: (node: CallTreeNode, value: number) => void,\n    closeFrame: (node: CallTreeNode, value: number) => void\n  ): void {\n    let prevStack: CallTreeNode[] = [];\n    let value = 0;\n\n    let sampleIndex = 0;\n\n    for (const stackTop of this.samples) {\n      let top: CallTreeNode | null = stackTop;\n\n      while (top && !top.isRoot() && prevStack.indexOf(top) === -1) {\n        top = top.parent;\n      }\n\n      while (prevStack.length > 0 && lastOfArray(prevStack) !== top) {\n        const node = prevStack.pop()!;\n        closeFrame(node, value);\n      }\n\n      const toOpen: CallTreeNode[] = [];\n\n      let node: CallTreeNode | null = stackTop;\n\n      while (node && !node.isRoot() && node !== top) {\n        toOpen.unshift(node);\n        node = node.parent;\n      }\n\n      for (const toOpenNode of toOpen) {\n        openFrame(toOpenNode, value);\n      }\n\n      prevStack = prevStack.concat(toOpen);\n      value += this.weights[sampleIndex++];\n    }\n\n    for (let i = prevStack.length - 1; i >= 0; i--) {\n      closeFrame(prevStack[i], value);\n    }\n  }\n\n  build(): Profile {\n    this.duration = Math.max(\n      this.duration,\n      this.weights.reduce((a, b) => a + b, 0)\n    );\n\n    // We had no frames with duration > 0, so set min duration to timeline duration\n    // which effectively disables any zooming on the flamegraphs\n    if (\n      this.minFrameDuration === Number.POSITIVE_INFINITY ||\n      this.minFrameDuration === 0\n    ) {\n      this.minFrameDuration = this.duration;\n    }\n\n    return this;\n  }\n}\n","import {Span} from '@sentry/types';\n\nimport {defined} from 'sentry/utils';\nimport {FlamegraphFrame} from 'sentry/utils/profiling/flamegraphFrame';\nimport {Frame} from 'sentry/utils/profiling/frame';\n\nimport {CallTreeNode} from '../callTreeNode';\n\ntype FrameIndex = Record<string | number, Frame>;\n\nexport function createFrameIndex(\n  frames: Profiling.Schema['shared']['frames']\n): FrameIndex;\nexport function createFrameIndex(\n  frames: JSSelfProfiling.Frame[],\n  trace: JSSelfProfiling.Trace\n): FrameIndex;\nexport function createFrameIndex(\n  frames: Profiling.Schema['shared']['frames'] | JSSelfProfiling.Frame[],\n  trace?: JSSelfProfiling.Trace\n): FrameIndex {\n  if (trace) {\n    return (frames as JSSelfProfiling.Frame[]).reduce((acc, frame, index) => {\n      acc[index] = new Frame(\n        {\n          key: index,\n          resource:\n            frame.resourceId !== undefined\n              ? trace.resources[frame.resourceId]\n              : undefined,\n          ...frame,\n        },\n        'web'\n      );\n      return acc;\n    }, {});\n  }\n\n  return (frames as Profiling.Schema['shared']['frames']).reduce((acc, frame, index) => {\n    acc[index] = new Frame({\n      key: index,\n      ...frame,\n    });\n    return acc;\n  }, {});\n}\n\ntype Cache<Arguments extends ReadonlyArray<any> | any, Value> = {\n  args: Arguments;\n  value: Value;\n};\n\nexport function memoizeByReference<Arguments, Value>(\n  fn: (args: Arguments) => Value\n): (t: Arguments) => Value {\n  let cache: Cache<Arguments, Value> | null = null;\n\n  return function memoizeByReferenceCallback(args: Arguments) {\n    // If this is the first run then eval the fn and cache the result\n    if (!cache) {\n      cache = {args, value: fn(args)};\n      return cache.value;\n    }\n    // If args match by reference, then return cached value\n    if (cache.args === args && cache.args !== undefined && args !== undefined) {\n      return cache.value;\n    }\n\n    // Else eval the fn and store the new value\n    cache.args = args;\n    cache.value = fn(args);\n    return cache.value;\n  };\n}\n\nexport function memoizeVariadicByReference<Arguments, Value>(\n  fn: (...args: ReadonlyArray<Arguments>) => Value\n): (...t: ReadonlyArray<Arguments>) => Value {\n  let cache: Cache<ReadonlyArray<Arguments>, Value> | null = null;\n\n  return function memoizeByReferenceCallback(...args: ReadonlyArray<Arguments>) {\n    // If this is the first run then eval the fn and cache the result\n    if (!cache) {\n      cache = {args, value: fn(...args)};\n      return cache.value;\n    }\n    // If args match by reference, then return cached value\n    if (\n      cache.args.length === args.length &&\n      cache.args.length !== 0 &&\n      args.length !== 0 &&\n      args.every((arg, i) => arg === cache?.args[i])\n    ) {\n      return cache.value;\n    }\n\n    // Else eval the fn and store the new value\n    cache.args = args;\n    cache.value = fn(...args);\n    return cache.value;\n  };\n}\n\nexport function wrapWithSpan<T>(parentSpan: Span | undefined, fn: () => T, options): T {\n  if (!defined(parentSpan)) {\n    return fn();\n  }\n\n  const sentrySpan = parentSpan.startChild(options);\n  try {\n    return fn();\n  } catch (error) {\n    sentrySpan.setStatus('internal_error');\n    throw error;\n  } finally {\n    sentrySpan.finish();\n  }\n}\n\nexport const isSystemCall = (node: CallTreeNode): boolean => {\n  return !node.frame.is_application;\n};\n\nexport const isApplicationCall = (node: CallTreeNode): boolean => {\n  return !!node.frame.is_application;\n};\n\nfunction indexNodeToParents(\n  roots: FlamegraphFrame[],\n  map: Record<string, FlamegraphFrame[]>,\n  leafs: FlamegraphFrame[]\n) {\n  // Index each child node to its parent\n  function indexNode(node: FlamegraphFrame, parent: FlamegraphFrame) {\n    if (!map[node.key]) {\n      map[node.key] = [];\n    }\n\n    map[node.key].push(parent);\n\n    if (!node.children.length) {\n      leafs.push(node);\n      return;\n    }\n\n    for (let i = 0; i < node.children.length; i++) {\n      indexNode(node.children[i], node);\n    }\n  }\n\n  // Begin in each root node\n  for (let i = 0; i < roots.length; i++) {\n    // If the root is a leaf node, push it to the leafs array\n    if (!roots[i].children?.length) {\n      leafs.push(roots[i]);\n    }\n\n    // Init the map for the root in case we havent yet\n    if (!map[roots[i].key]) {\n      map[roots[i].key] = [];\n    }\n\n    // descend down to each child and index them\n    for (let j = 0; j < roots[i].children.length; j++) {\n      indexNode(roots[i].children[j], roots[i]);\n    }\n  }\n}\n\nfunction reverseTrail(\n  nodes: FlamegraphFrame[],\n  parentMap: Record<string, FlamegraphFrame[]>\n): FlamegraphFrame[] {\n  const splits: FlamegraphFrame[] = [];\n\n  for (const n of nodes) {\n    const nc = {\n      ...n,\n      parent: null as FlamegraphFrame | null,\n      children: [] as FlamegraphFrame[],\n    };\n\n    if (!parentMap[n.key]) {\n      continue;\n    }\n\n    for (const parent of parentMap[n.key]) {\n      nc.children.push(...reverseTrail([parent], parentMap));\n    }\n    splits.push(nc);\n  }\n\n  return splits;\n}\n\nexport const invertCallTree = (roots: FlamegraphFrame[]): FlamegraphFrame[] => {\n  const nodeToParentIndex: Record<string, FlamegraphFrame[]> = {};\n  const leafNodes: FlamegraphFrame[] = [];\n\n  indexNodeToParents(roots, nodeToParentIndex, leafNodes);\n  const reversed = reverseTrail(leafNodes, nodeToParentIndex);\n  return reversed;\n};\n","import {Location, LocationDescriptor, Path} from 'history';\n\nimport {Organization, Project} from 'sentry/types';\nimport {Trace} from 'sentry/types/profiling/core';\n\nexport function generateProfilingRoute({orgSlug}: {orgSlug: Organization['slug']}): Path {\n  return `/organizations/${orgSlug}/profiling/`;\n}\n\nexport function generateProfileSummaryRoute({\n  orgSlug,\n  projectSlug,\n}: {\n  orgSlug: Organization['slug'];\n  projectSlug: Project['slug'];\n}): Path {\n  return `/organizations/${orgSlug}/profiling/summary/${projectSlug}/`;\n}\n\nexport function generateProfileFlamegraphRoute({\n  orgSlug,\n  projectSlug,\n  profileId,\n}: {\n  orgSlug: Organization['slug'];\n  profileId: Trace['id'];\n  projectSlug: Project['slug'];\n}): string {\n  return `/organizations/${orgSlug}/profiling/profile/${projectSlug}/${profileId}/flamegraph/`;\n}\n\nexport function generateProfileDetailsRoute({\n  orgSlug,\n  projectSlug,\n  profileId,\n}: {\n  orgSlug: Organization['slug'];\n  profileId: Trace['id'];\n  projectSlug: Project['slug'];\n}): string {\n  return `/organizations/${orgSlug}/profiling/profile/${projectSlug}/${profileId}/details/`;\n}\n\nexport function generateProfilingRouteWithQuery({\n  location,\n  orgSlug,\n  query,\n}: {\n  orgSlug: Organization['slug'];\n  location?: Location;\n  query?: Location['query'];\n}): LocationDescriptor {\n  const pathname = generateProfilingRoute({orgSlug});\n  return {\n    pathname,\n    query: {\n      ...location?.query,\n      ...query,\n    },\n  };\n}\n\nexport function generateProfileSummaryRouteWithQuery({\n  location,\n  orgSlug,\n  projectSlug,\n  transaction,\n  query,\n}: {\n  orgSlug: Organization['slug'];\n  projectSlug: Project['slug'];\n  transaction: string;\n  location?: Location;\n  query?: Location['query'];\n}): LocationDescriptor {\n  const pathname = generateProfileSummaryRoute({orgSlug, projectSlug});\n  return {\n    pathname,\n    query: {\n      ...location?.query,\n      ...query,\n      transaction,\n    },\n  };\n}\n\nexport function generateProfileFlamegraphRouteWithQuery({\n  location,\n  orgSlug,\n  projectSlug,\n  profileId,\n  query,\n}: {\n  orgSlug: Organization['slug'];\n  profileId: Trace['id'];\n  projectSlug: Project['slug'];\n  location?: Location;\n  query?: Location['query'];\n}): LocationDescriptor {\n  const pathname = generateProfileFlamegraphRoute({orgSlug, projectSlug, profileId});\n  return {\n    pathname,\n    query: {\n      ...location?.query,\n      ...query,\n    },\n  };\n}\n\nexport function generateProfileDetailsRouteWithQuery({\n  location,\n  orgSlug,\n  projectSlug,\n  profileId,\n  query,\n}: {\n  orgSlug: Organization['slug'];\n  profileId: Trace['id'];\n  projectSlug: Project['slug'];\n  location?: Location;\n  query?: Location['query'];\n}): LocationDescriptor {\n  const pathname = generateProfileDetailsRoute({orgSlug, projectSlug, profileId});\n  return {\n    pathname,\n    query: {\n      ...location?.query,\n      ...query,\n    },\n  };\n}\n","/**\n * This is a utility class for profiling - we extend it in order to be able to construct\n * a stack of nodes (or call trees) and append weights to them.\n */\nexport class WeightedNode {\n  // Total weight is the weight of the node and all its children.\n  totalWeight: number = 0;\n  // Self weight is the weight of the node itself.\n  selfWeight: number = 0;\n\n  addToTotalWeight(delta: number): number {\n    this.totalWeight += delta;\n    return this.totalWeight;\n  }\n  addToSelfWeight(delta: number): number {\n    this.selfWeight += delta;\n    return this.selfWeight;\n  }\n}\n","import {Location, Query} from 'history';\n\nimport {useRouteContext} from 'sentry/utils/useRouteContext';\n\ntype DefaultQuery<T = string> = {\n  [key: string]: T | T[] | null | undefined;\n};\n\nexport function useLocation<Q extends Query = DefaultQuery>(): Location<Q> {\n  const route = useRouteContext();\n  return route.location;\n}\n","import {useRouteContext} from 'sentry/utils/useRouteContext';\n\nexport function useParams() {\n  const route = useRouteContext();\n  return route.params;\n}\n","import {Link} from 'react-router';\n\nimport * as Layout from 'sentry/components/layouts/thirds';\nimport {Breadcrumb} from 'sentry/components/profiling/breadcrumb';\nimport {t} from 'sentry/locale';\nimport {\n  generateProfileDetailsRouteWithQuery,\n  generateProfileFlamegraphRouteWithQuery,\n} from 'sentry/utils/profiling/routes';\nimport {useLocation} from 'sentry/utils/useLocation';\nimport useOrganization from 'sentry/utils/useOrganization';\nimport {useParams} from 'sentry/utils/useParams';\nimport {useProfileGroup} from 'sentry/views/profiling/profileGroupProvider';\n\nfunction ProfileHeader() {\n  const params = useParams();\n  const location = useLocation();\n  const organization = useOrganization();\n  const [profileGroup] = useProfileGroup();\n\n  return (\n    <Layout.Header style={{gridTemplateColumns: 'minmax(0, 1fr)'}}>\n      <Layout.HeaderContent style={{marginBottom: 0}}>\n        <Breadcrumb\n          location={location}\n          organization={organization}\n          trails={[\n            {type: 'landing'},\n            {\n              type: 'flamegraph',\n              payload: {\n                transaction:\n                  profileGroup.type === 'resolved' ? profileGroup.data.name : '',\n                profileId: params.eventId ?? '',\n                projectSlug: params.projectId ?? '',\n              },\n            },\n          ]}\n        />\n      </Layout.HeaderContent>\n      <Layout.HeaderNavTabs underlined>\n        <li className={location.pathname.endsWith('details/') ? 'active' : undefined}>\n          <Link\n            to={generateProfileDetailsRouteWithQuery({\n              orgSlug: organization.slug,\n              projectSlug: params.projectId,\n              profileId: params.eventId,\n              location,\n            })}\n          >\n            {t('Details')}\n          </Link>\n        </li>\n        <li className={location.pathname.endsWith('flamegraph/') ? 'active' : undefined}>\n          <Link\n            to={generateProfileFlamegraphRouteWithQuery({\n              orgSlug: organization.slug,\n              projectSlug: params.projectId,\n              profileId: params.eventId,\n              location,\n            })}\n          >\n            {t('Flamegraph')}\n          </Link>\n        </li>\n      </Layout.HeaderNavTabs>\n    </Layout.Header>\n  );\n}\n\nexport {ProfileHeader};\n","import {createContext, useContext, useEffect, useState} from 'react';\nimport * as Sentry from '@sentry/react';\n\nimport {Client} from 'sentry/api';\nimport {ProfileHeader} from 'sentry/components/profiling/profileHeader';\nimport {t} from 'sentry/locale';\nimport {Organization, Project} from 'sentry/types';\nimport {RequestState} from 'sentry/types/core';\nimport {importProfile, ProfileGroup} from 'sentry/utils/profiling/profile/importProfile';\nimport useApi from 'sentry/utils/useApi';\nimport useOrganization from 'sentry/utils/useOrganization';\nimport {useParams} from 'sentry/utils/useParams';\n\nfunction fetchFlamegraphs(\n  api: Client,\n  eventId: string,\n  projectId: Project['id'],\n  organization: Organization\n): Promise<ProfileGroup> {\n  return api\n    .requestPromise(\n      `/projects/${organization.slug}/${projectId}/profiling/profiles/${eventId}/`,\n      {\n        method: 'GET',\n        includeAllArgs: true,\n      }\n    )\n    .then(([data]) => importProfile(data, eventId));\n}\n\ninterface FlamegraphViewProps {\n  children: React.ReactNode;\n}\n\nconst ProfileGroupContext = createContext<\n  | [\n      RequestState<ProfileGroup>,\n      React.Dispatch<React.SetStateAction<RequestState<ProfileGroup>>>\n    ]\n  | null\n>(null);\n\nexport const useProfileGroup = () => {\n  const context = useContext(ProfileGroupContext);\n  if (!context) {\n    throw new Error('useProfileGroup was called outside of ProfileGroupProvider');\n  }\n  return context;\n};\n\nfunction ProfileGroupProvider(props: FlamegraphViewProps): React.ReactElement {\n  const api = useApi();\n  const organization = useOrganization();\n  const params = useParams();\n\n  const [profileGroupState, setProfileGroupState] = useState<RequestState<ProfileGroup>>({\n    type: 'initial',\n  });\n\n  useEffect(() => {\n    if (!params.eventId || !params.projectId) {\n      return undefined;\n    }\n\n    setProfileGroupState({type: 'loading'});\n\n    fetchFlamegraphs(api, params.eventId, params.projectId, organization)\n      .then(importedFlamegraphs => {\n        setProfileGroupState({type: 'resolved', data: importedFlamegraphs});\n      })\n      .catch(err => {\n        const message = err.toString() || t('Error: Unable to load profiles');\n        setProfileGroupState({type: 'errored', error: message});\n        Sentry.captureException(err);\n      });\n\n    return () => {\n      api.clear();\n    };\n  }, [params.eventId, params.projectId, api, organization]);\n\n  return (\n    <ProfileGroupContext.Provider value={[profileGroupState, setProfileGroupState]}>\n      <ProfileHeader />\n      {props.children}\n    </ProfileGroupContext.Provider>\n  );\n}\n\nexport default ProfileGroupProvider;\n"],"names":["Breadcrumb","location","organization","trails","crumbs","useMemo","map","trail","type","to","generateProfilingRouteWithQuery","orgSlug","slug","label","t","preservePageFilters","generateProfileSummaryRouteWithQuery","projectSlug","payload","transaction","generateProfileFlamegraphRouteWithQuery","profileId","Error","JSON","stringify","trailToCrumb","StyledBreadcrumbs","Breadcrumbs","CallTreeNode","WeightedNode","constructor","frame","parent","super","this","recursive","setParent","setRecursiveThroughNode","node","isRecursive","isDirectRecursive","isLocked","locked","lock","isRoot","Frame","frameInfo","key","file","name","resource","line","column","is_application","undefined","image","threadId","Root","isJSProfile","profile","Array","isArray","resources","isChromeTraceObjectFormat","input","isChromeTraceArrayFormat","EventedProfile","Profile","appendOrderTree","eventedProfile","frameIndex","endValue","startValue","unit","threadID","lastValue","Math","max","event","events","enterFrame","at","leaveFrame","TypeError","build","addWeightToFrames","weight","weightDelta","stack","addToTotalWeight","top","lastOfArray","addToSelfWeight","addWeightsToNodes","value","delta","appendOrderStack","stackTop","lastTop","sampleDelta","samples","push","weights","last","children","start","length","_event","leavingStackTop","pop","minFrameDuration","min","duration","reduce","a","b","Number","POSITIVE_INFINITY","ChromeTraceProfile","reverseChronologicalSort","ts","getNextQueue","beginQueue","endQueue","nextBegin","nextEnd","buildProfile","processId","processName","threadName","timelineEvents","filter","e","ph","i","args","dur","tdur","sort","firstTimestamp","lastTimestamp","frameCache","Map","next","item","createFrameInfoFromEvent","topFrameInfo","nextEndInfo","tmp","has","get","set","totalWeight","trim","stackMarkerToHumanReadable","marker","createMarkerFrame","resourceId","resolveJSSelfProfilingStack","trace","stackId","callStack","unshift","stacks","frames","frameId","parentId","JSSelfProfile","markers","startedAt","timestamp","endedAt","jsSelfProfile","appendSample","framesInStack","stackHeight","child","stackNode","SampledProfile","sampledProfile","appendSampleWithWeight","n","importProfile","traceID","Sentry","op","setTag","options","activeProfileIndex","profiles","importSingleProfile","createFrameIndex","importJSSelfProfile","isChromeTraceFormat","eventsByProcessAndThreadID","collections","pid","tid","processes","threads","splitEventsByProcessAndTraceId","wrapWithSpan","description","parseChromeTraceArrayFormat","importChromeTrace","isSchema","shared","transactionName","importSchema","error","setStatus","finish","isEventedProfile","FromProfile","isSampledProfile","tryParseInputString","parse","TRACE_JSON_PARSERS","readFileAsString","Promise","resolve","reject","reader","FileReader","addEventListener","target","result","readAsText","async","importDroppedProfile","parsers","fileContents","parser","json","Set","forEach","openFrame","closeFrame","prevStack","sampleIndex","indexOf","toOpen","toOpenNode","concat","acc","index","memoizeByReference","fn","cache","parentSpan","defined","sentrySpan","startChild","reverseTrail","nodes","parentMap","splits","nc","invertCallTree","roots","nodeToParentIndex","leafNodes","leafs","indexNode","j","indexNodeToParents","generateProfileDetailsRoute","query","pathname","generateProfilingRoute","generateProfileSummaryRoute","generateProfileFlamegraphRoute","generateProfileDetailsRouteWithQuery","selfWeight","useLocation","useRouteContext","useParams","params","ProfileHeader","useOrganization","profileGroup","useProfileGroup","style","gridTemplateColumns","marginBottom","data","eventId","projectId","underlined","className","endsWith","Link","ProfileGroupContext","createContext","context","useContext","ProfileGroupProvider","props","api","useApi","profileGroupState","setProfileGroupState","useState","useEffect","requestPromise","method","includeAllArgs","then","fetchFlamegraphs","importedFlamegraphs","catch","err","message","toString","clear","Provider"],"sourceRoot":""}